//@author: a0119432l



	/**
	 * origin: src\main\message\AddSuccessfulMessage.java
	 */

public class AddSuccessfulMessage implements Message {

    private TaskInfo task;
    
    public AddSuccessfulMessage(TaskInfo task, TaskId taskId) {
        this.task = task;
    }
    
    public Type getType() {
        return Type.ADD_SUCCESSFUL;
    }
    
    public TaskInfo getTask() {
        return task;
    }

}

	// End of segment: src\main\message\AddSuccessfulMessage.java





	/**
	 * origin: src\main\message\DeleteSuccessfulMessage.java
	 */

public class DeleteSuccessfulMessage implements Message {

    private TaskInfo[] tasks;
    
    public DeleteSuccessfulMessage(TaskInfo[] tasks, TaskId[] taskIds) {
        this.tasks = tasks;
    }
    
    public Type getType() {
        return Type.DELETE_SUCCESSFUL;
    }
    
    public TaskInfo[] getTask() {
        return tasks;
    }
}

	// End of segment: src\main\message\DeleteSuccessfulMessage.java





	/**
	 * origin: src\main\message\EditSuccessfulMessage.java
	 */

public class EditSuccessfulMessage implements Message{
    
    public enum Field {
        NAME,
        TIME,
        STATUS,
        DETAILS,
        PRIORITY,
        TAGS_ADD,
        TAGS_DELETE,
    }
    
    Field[] changedField;
    private TaskInfo[] tasks;
    private TaskId[] taskIds;
    
    public EditSuccessfulMessage(TaskInfo[] tasks, TaskId[] taskIds, Field[] changedField) {
        this.taskIds = taskIds;
        this.tasks = tasks;
        this.changedField = changedField;
    }
    
    public Type getType() {
        return Type.EDIT_SUCCESSFUL;
    }
    
    public Field[] getChangedField() {
        return changedField;
    }
    
    public TaskInfo[] getTask() {
        return tasks;
    }
    
    public TaskId[] getTaskId() {
        return taskIds;
    }
}

	// End of segment: src\main\message\EditSuccessfulMessage.java





	/**
	 * origin: src\main\message\FreeDaySearchMessage.java
	 */

public class FreeDaySearchMessage implements Message {


    private ArrayList<LocalDate> freeDates;
    private LocalDate lastBusyDate;
    private LocalDate firstBusyDate;
    private LocalDate searchStartDate;
    private LocalDate searchEndDate;
    
    public FreeDaySearchMessage(ArrayList<LocalDate> freeDates,
            LocalDate startDate, LocalDate lastTaskEndDate,
            LocalDate searchStartDate, LocalDate searchEndDate) {
        this.freeDates = freeDates;
        this.firstBusyDate = startDate;
        this.lastBusyDate = lastTaskEndDate;
        this.searchStartDate = searchStartDate;
        this.searchEndDate = searchEndDate;
    }
    
    @Override
    public Type getType() {
        return Type.FREE_DAY_SEARCH_SUCCESSFUL;
    }
    
    public ArrayList<LocalDate> getFreeDateList(){
        return freeDates;
    }
    
    public LocalDate getLastBusyDate(){
        return lastBusyDate;
    }
    
    public LocalDate getFirstBusyDate(){
        return firstBusyDate;
    }
    
    public LocalDate getSearchStartDate(){
    	return searchStartDate;
    }
    
    public LocalDate getSearchEndDate(){
    	return searchEndDate;
    }
}

	// End of segment: src\main\message\FreeDaySearchMessage.java





	/**
	 * origin: src\main\message\FreeTimeSearchMessage.java
	 */

public class FreeTimeSearchMessage implements Message{
	
	private ArrayList<Interval> freeTimeList;
	private LocalDate date;

	public FreeTimeSearchMessage(LocalDate date, ArrayList<Interval> list){
		this.date = date;
		this.freeTimeList = list;
	}
	
	public Type getType() {
		return Type.FREE_TIME_SEARCH_SUCCESSFUL;
	}
	
	public LocalDate getDate(){
		return date;
	}
	
	public ArrayList<Interval> getFreeTimelist(){
		return freeTimeList;
	}

	
}

	// End of segment: src\main\message\FreeTimeSearchMessage.java





	/**
	 * origin: src\main\message\ReportMessage.java
	 */

public class ReportMessage implements Message{
	
	private final int countTodayTasks;
	private final int countTmrTasks;
    private final ArrayList<TaskInfo> urgentTasks;
    private final ArrayList<TaskInfo> nonUrgentTasks;
    private final ArrayList<TaskInfo> missedTasks;
	
	public ReportMessage(int countTodayTask, int countTmrTask,
	        ArrayList<TaskInfo> urgentTasks, ArrayList<TaskInfo> nonUrgentTasks,
	        ArrayList<TaskInfo> missedTasks) {
		this.countTodayTasks = countTodayTask;
		this.countTmrTasks = countTmrTask;
        this.urgentTasks = urgentTasks;
        this.nonUrgentTasks = nonUrgentTasks;
        this.missedTasks = missedTasks;
	}
	
	public int getCountTodayTask() {
		return countTodayTasks;
	}
	
	public int getCountTmrTask() {
		return countTmrTasks;
	}
    
    public ArrayList<TaskInfo> getUrgentTasks() {
        return urgentTasks;
    }
    
    public ArrayList<TaskInfo> getNonUrgentTasks() {
        return nonUrgentTasks;
    }

    public ArrayList<TaskInfo> getMissedTasks() {
        return missedTasks;
    }

	public Type getType() {
		return Type.REPORT;
	}
}

	// End of segment: src\main\message\ReportMessage.java





	/**
	 * origin: src\manager\datamanager\AddManager.java
	 */

/**
 * This is an add manager that enables creating a new task with given
 * taskInfo in the TaskData.
 */
public class AddManager extends AbstractManager {
	
	private TaskId id = null;
    
    public AddManager(TaskData taskData) {
        super(taskData);
    }

    public Result addTask(TaskInfo taskInfo) {
    	if (taskInfo == null){
    		return new SimpleResult(Result.Type.ADD_FAILURE);
    	}
    	taskInfo.assertValidDateTime();
    	
    	id = taskData.add(taskInfo);
    	
    	if (id == null){
    		return new SimpleResult(Result.Type.ADD_FAILURE);
    	}
    	
    	return new AddResult(taskInfo, id);
    	
    }
    
}

	// End of segment: src\manager\datamanager\AddManager.java





	/**
	 * origin: src\manager\datamanager\DeleteManager.java
	 */

/**
 * This is a delete manager that enables deletion of a task with specified
 * taskId inside the taskData.
 */
public class DeleteManager extends AbstractManager {

    public DeleteManager(TaskData taskData) {
        super(taskData);
    }

    public Result deleteTask(TaskIdSet taskIdSet) {
    	
        boolean allSuccessful = true;
        
        List<TaskId> idList = new ArrayList<TaskId>();
        List<TaskInfo> taskList = new ArrayList<TaskInfo>();
        
        for (TaskId taskId : taskIdSet) {
        	if (taskId == null) {
        	    allSuccessful = false;
        	    break;
        	}

            idList.add(taskId);
            taskList.add(taskData.getTaskInfo(taskId));
        	boolean isSuccessful = taskData.remove(taskId);
        	
        	if (!isSuccessful){
                allSuccessful = false;
                break;
        	}
        }
        
        if (allSuccessful) {
            TaskId[] taskIds = new TaskId[idList.size()];
            TaskInfo[] tasks = new TaskInfo[taskList.size()];
            
            idList.toArray(taskIds);
            taskList.toArray(tasks);
            return new DeleteResult(taskIds, tasks);
        } else {
            taskData.reverseLastChange();
            return new SimpleResult(Result.Type.DELETE_FAILURE);
        }
    }
       
}

	// End of segment: src\manager\datamanager\DeleteManager.java





	/**
	 * origin: src\manager\datamanager\EditManager.java
	 */

/**
 * This is a edit manager that enables editing a certain TaskInfo with specific
 * taskId in the taskData.
 */
public class EditManager extends AbstractManager {

    private TaskIdSet editingTasks;

    public EditManager(TaskData taskData) {
        super(taskData);
    }

    /**
     * enable batch edit functionality
     * @param taskInfo taskInfo of editing content
     * @param taskIdSet task Ids that are to change
     * @return result of changing task
     */
    public Result editTask(TaskInfo taskInfo, TaskIdSet taskIdSet) {

        boolean allSuccessful = true;
        List<TaskId> taskIdList = new ArrayList<TaskId>();
        List<TaskInfo> taskList = new ArrayList<TaskInfo>();
        
        TaskInfo editedTask = null;
        EditSuccessfulMessage.Field[] fields = setChangedFields(taskInfo);

        for (TaskId taskId : taskIdSet) {
            if (taskId == null){
                allSuccessful = false;
                break;
            }

            TaskInfo originTask = taskData.getTaskInfo(taskId);
            if (originTask == null){
                allSuccessful = false;
                break;
            }

            editedTask = mergeTasks(originTask, taskInfo);
            boolean isSuccessful = taskData.setTaskInfo(taskId, editedTask);

            taskIdList.add(taskId);
            taskList.add(taskData.getTaskInfo(taskId));
            
            if (!isSuccessful){
                allSuccessful = false;
                break;
            }
        }

        if (allSuccessful) {
            TaskId[] taskIds = new TaskId[taskIdList.size()];
            TaskInfo[] tasks = new TaskInfo[taskList.size()];
            
            taskIdList.toArray(taskIds);
            taskList.toArray(tasks);
            
            return new EditResult(Result.Type.EDIT_SUCCESS, tasks, taskIds,
                    fields);
        } else {
            taskData.reverseLastChange();
            return new SimpleResult(Result.Type.EDIT_FAILURE);
        }
    }

    public TaskIdSet getEditingTasks() {
        return editingTasks;
    }
    
    /**
     * To clear certain info from a given set of task Ids
     * @param taskIdSet set of task Ids that are to change
     * @param infoToClear info to clear
     * @return
     */
    public Result clearInfo(TaskIdSet taskIdSet, EditCommand.Info infoToClear) {
        boolean allSuccessful = true;
        List<TaskId> taskIdList = new ArrayList<TaskId>();
        List<TaskInfo> taskList = new ArrayList<TaskInfo>();
        Field field = null;
        
        for (TaskId taskId : taskIdSet) {
            switch (infoToClear) {
                case TIME :
                    if (!tryClearTime(taskId)) {
                        allSuccessful = false;   
                    }
                    field = Field.TIME;
                    break;
                case DATE :
                case DATETIME :
                    if (!tryClearDate(taskId)) {
                        allSuccessful = false;
                    }
                    field = Field.TIME;
                    break;
                case DESCRIPTION :
                    if (!taskData.setTaskDetails(taskId, null)) {
                        allSuccessful = false;
                    }
                    field = Field.DETAILS;
                    break;
                case PRIORITY :
                    if (!taskData.setTaskPriority(taskId,
                            Priority.defaultPriority())) {
                        allSuccessful = false;
                    }
                    field = Field.PRIORITY;
                    break;
                case STATUS :
                    if (!taskData.setTaskStatus(taskId,
                            Status.defaultStatus())) {
                        allSuccessful = false;
                    }
                    field = Field.STATUS;
                    break;
                case TAGS :
                    if (!taskData.clearTags(taskId)) {
                        allSuccessful = false;
                    }
                    field = Field.TAGS_DELETE;
                    break;
                default :
                    allSuccessful = false;
                    break;
            }

            taskIdList.add(taskId);
            taskList.add(taskData.getTaskInfo(taskId));
            if (!allSuccessful) {
                break;
            }
        }
        

        if (allSuccessful) {
            TaskId[] taskIds = new TaskId[taskIdList.size()];
            TaskInfo[] tasks = new TaskInfo[taskList.size()];
            
            taskIdList.toArray(taskIds);
            taskList.toArray(tasks);
            
            return new EditResult(Result.Type.EDIT_SUCCESS, tasks,
                    taskIds, new Field[]{field});
        } else {
            taskData.reverseLastChange();
            return new SimpleResult(Result.Type.EDIT_FAILURE);
        }
    }

    private boolean tryClearTime(TaskId taskId) {
        if (!taskData.setTaskStartDate(taskId, null)) {
            return false;
        }
        if (!taskData.setTaskStartTime(taskId, null)) {
            return false;
        }
        if (!taskData.setTaskEndTime(taskId, null)) {
            return false;
        }
        
        return true;
    }

    private boolean tryClearDate(TaskId taskId) {
        if (!taskData.setTaskStartDate(taskId, null)) {
            return false;
        }
        if (!taskData.setTaskStartTime(taskId, null)) {
            return false;
        }
        if (!taskData.setTaskEndTime(taskId, null)) {
            return false;
        }
        if (!taskData.setTaskDate(taskId, null)) {
            return false;
        }
        
        return true;
    }

    /**
     * THis is to start editing mode and note the editing id set
     * @param taskIdSet
     * @return
     */
    public Result startEditMode(TaskIdSet taskIdSet) {
        editingTasks = taskIdSet;
        return new StartEditModeResult(taskIdSet);
    }

    public Result endEditMode() {
        editingTasks = null;
        return new SimpleResult(Result.Type.EDIT_MODE_END);
    }

    /**
     * This is to add tags to multiple tasks
     * @param tags tags list to add
     * @param taskIdSet set of tasks to add tags
     * @return result of adding tags
     */
    public Result addTaskTags(Tag[] tags, TaskIdSet taskIdSet){
        boolean allSuccessful = true;
        
        List<TaskId> taskIdList = new ArrayList<TaskId>();
        List<TaskInfo> taskList = new ArrayList<TaskInfo>();

        for (TaskId taskId : taskIdSet) {
            if (taskId == null){
                allSuccessful = false;
                break;
            }

            boolean isSuccessful = taskData.taskExists(taskId);
            for (Tag tag : tags) {
                taskData.addTag(taskId, tag);
            }

            taskIdList.add(taskId);
            taskList.add(taskData.getTaskInfo(taskId));
            
            if (!isSuccessful) {
                allSuccessful = false;
                break;
            }
        }

        if (allSuccessful) {
            TaskId[] taskIds = new TaskId[taskIdList.size()];
            TaskInfo[] tasks = new TaskInfo[taskList.size()];
            
            taskIdList.toArray(taskIds);
            taskList.toArray(tasks);
            
            return new EditResult(Result.Type.TAG_ADD_SUCCESS, tasks, taskIds,
                     EditSuccessfulMessage.Field.TAGS_ADD);
        } else {
            taskData.reverseLastChange();
            return new SimpleResult(Result.Type.TAG_ADD_FAILURE);
        }
    }

    /**
     * This is to delete tags to multiple tasks
     * @param tags tags list to delete
     * @param taskIdSet set of tasks to delete tags
     * @return result of deleting tags
     */
    public Result deleteTaskTags(Tag[] tags, TaskIdSet taskIdSet){

        boolean allSuccessful = true;
        List<TaskId> taskIdList = new ArrayList<TaskId>();
        List<TaskInfo> taskList = new ArrayList<TaskInfo>();

        for (TaskId taskId : taskIdSet) {
            if (taskId == null) {
                allSuccessful = false;
                break;
            }

            boolean isSuccessful = taskData.taskExists(taskId);
            boolean isTagSuccess = false;
            for (Tag tag : tags) {
                Boolean  isDeleteSuccess = taskData.removeTag(taskId, tag);
                if (isDeleteSuccess){
                	isTagSuccess = true;
                }
            }

            taskIdList.add(taskId);
            taskList.add(taskData.getTaskInfo(taskId));
            
            if ((!isSuccessful) || (!isTagSuccess)) {
                allSuccessful = false;
                break;
            }
        }

        if (allSuccessful) {
            TaskId[] taskIds = new TaskId[taskIdList.size()];
            TaskInfo[] tasks = new TaskInfo[taskList.size()];
            
            taskIdList.toArray(taskIds);
            taskList.toArray(tasks);
            
            return new EditResult(Result.Type.TAG_DELETE_SUCCESS, tasks, taskIds, 
                    EditSuccessfulMessage.Field.TAGS_DELETE);
        } else {
            taskData.reverseLastChange();
            return new SimpleResult(Result.Type.TAG_DELETE_FAILURE);
        }
    }


    /**
     * This method is to modify origin task with some changes specified
     * in modifTask, and return the modified task
     * @param originTask task to modify
     * @param modifTask changes to be modified
     * @return modified TaskInfo
     */
    private TaskInfo mergeTasks(TaskInfo originTask, TaskInfo modifTask ){
    	TaskInfo mergedTask = new TaskInfo(originTask);
    	
    	mergedTask = mergeTasksTime(originTask, modifTask);
    	if (modifTask.name != null){
    		mergedTask.name = modifTask.name;
    	}
    	if (modifTask.details != null){
    		mergedTask.details = modifTask.details;
    	}
    	if ((modifTask.priority != null)){
    		mergedTask.priority = modifTask.priority;
    	}
    	if ((modifTask.status != null)){
    		mergedTask.status = modifTask.status;
    	}
    	if (modifTask.numberOfTimes != 0){
    		mergedTask.numberOfTimes = modifTask.numberOfTimes;
    	}
    	if (modifTask.repeatInterval != null){
    		mergedTask.repeatInterval = modifTask.repeatInterval;
    	}
       	return mergedTask;
    }


    
    /**
     * This is to merge the time between origin taskInfo and modifying taskInfo
     * @param originTask original taskInfo
     * @param modifTask modifying taskInfo
     * @return Modified task
     */
    private TaskInfo mergeTasksTime(TaskInfo originTask, TaskInfo modifTask){
    	TaskInfo mergedTask = new TaskInfo(originTask);
    	if ((modifTask.startDate == null) && (modifTask.startTime == null)
    		&& (modifTask.endDate != null) && (modifTask.endTime == null)){
    		mergedTask.startTime = null;
    		mergedTask.startDate = null;
    		mergedTask.endDate = modifTask.endDate;
    	}
    	if ((modifTask.startDate == null) && (modifTask.startTime == null)
        		&& (modifTask.endDate == null) && (modifTask.endTime != null)){
    		mergedTask.startTime = null;
    		mergedTask.startDate = null;
    		mergedTask.endTime = modifTask.endTime;
    	}
    	if ((modifTask.startDate == null) && (modifTask.startTime == null)
        		&& (modifTask.endDate != null) && (modifTask.endTime != null)){
    		mergedTask.startTime = null;
    		mergedTask.startDate = null;
    		mergedTask.endDate = modifTask.endDate;
    		mergedTask.endTime = modifTask.endTime;
    	}
    	if ((modifTask.startDate != null) && (modifTask.startTime == null)
        		&& (modifTask.endDate != null) && (modifTask.endTime == null)){
    		mergedTask.startDate = modifTask.startDate;
    		mergedTask.endDate = modifTask.endDate;
    	}
    	if ((modifTask.startDate == null) && (modifTask.startTime != null)
        		&& (modifTask.endDate == null) && (modifTask.endTime != null)){
    		mergedTask.startTime = modifTask.startTime;
    		mergedTask.endTime = modifTask.endTime;
    		if (mergedTask.startDate == null){
    			mergedTask.startDate = mergedTask.endDate;
    		}
    	}
    	if ((modifTask.startDate != null) && (modifTask.startTime != null)
        		&& (modifTask.endDate != null) && (modifTask.endTime != null)){
    		mergedTask.startTime = modifTask.startTime;
    		mergedTask.startDate = modifTask.startDate;
    		mergedTask.endDate = modifTask.endDate;
    		mergedTask.endTime = modifTask.endTime;
    	}
    	return mergedTask;
    }
    
    private EditSuccessfulMessage.Field[] setChangedFields(TaskInfo taskInfo){

        ArrayList<EditSuccessfulMessage.Field> fields =
                new ArrayList<EditSuccessfulMessage.Field>();
    	if (taskInfo.name != null){
    	    fields.add(EditSuccessfulMessage.Field.NAME);
    	}
    	if (taskInfo.priority != null){
    		fields.add(EditSuccessfulMessage.Field.PRIORITY);
    	}
    	if (taskInfo.status != null){
    		fields.add(EditSuccessfulMessage.Field.STATUS);
    	}
    	if (taskInfo.details != null){
    		fields.add(EditSuccessfulMessage.Field.DETAILS);
    	}
    	if ((taskInfo.startTime != null) || (taskInfo.startDate != null) ||
    	        (taskInfo.endTime != null) || (taskInfo.endDate != null)) {
    		fields.add(EditSuccessfulMessage.Field.TIME);
    	}

    	EditSuccessfulMessage.Field[] fieldsArray =
    	        new EditSuccessfulMessage.Field[fields.size()];
    	for (int i = 0; i < fields.size(); i++) {
    	    fieldsArray[i] = fields.get(i);
    	}

    	return fieldsArray;
    }
}

	// End of segment: src\manager\datamanager\EditManager.java





	/**
	 * origin: src\manager\datamanager\FreeDaySearchManager.java
	 */

public class FreeDaySearchManager extends AbstractManager {

	private static final LocalTime END_OF_DAY = LocalTime.of(23, 59, 59);
    private static final LocalTime START_OF_DAY = LocalTime.of(0, 0);
    
    private ArrayList<TaskInfo> taskList;

	/** 
	 * Constructor
	 * @param taskData
	 */
	public FreeDaySearchManager(TaskData taskData) {
		super(taskData);
	}

	/**
	 * Get the taskInfos of tasks that consist of date, which are not floating
	 * @return ArrayList of taskInfos
	 */
	private ArrayList<TaskInfo> TaskListWithDate() {
		ArrayList<TaskInfo> taskListWithDate = new ArrayList<TaskInfo>();
		TaskId taskId = taskData.getFirst();
		TaskInfo task;
		while (taskId.isValid()) {
			task = taskData.getTaskInfo(taskId);
			if (task.getEndDate() != null) {
				taskListWithDate.add(task);
			}
			taskId = taskData.getNext(taskId);
		}
		return taskListWithDate;
	}

	/**
	 * this is to initialize and update the task list for the sake of searching
	 */
	private void updateTaskList() {
		taskList = TaskListWithDate();
		sortTask();
	}

	private void clearMemory() {
		taskList.clear();
		taskList = null;   
	}
	
	
	/**
	 * Search for those days that are free from start time 
	 * to end time between start date and end date 
	 * @param startTime start time of spare interval
	 * @param startDate start date of searching period
	 * @param endTime end time of spare interval
	 * @param endDate end date of searching period
	 * @return a result containing those free days
	 */
	public Result searchFreeDay(LocalTime startTime, LocalDate startDate,
			LocalTime endTime, LocalDate endDate) {
	    
	    assert startBeforeEnd(startTime, startDate, endTime, endDate);
	    
		updateTaskList();

		LocalDate checkDate = null;
		ArrayList<LocalDate> freeDays = new ArrayList<LocalDate>();
		ArrayList<TaskInfo> taskListContainingTimeSlot = findTaskContainingTimeSlot(
				startTime, endTime);
		LocalDate firstStartDate = null;

		if (taskListContainingTimeSlot.size() == 0){
			return new FreeDayResult(null,null,null,startDate, endDate);
		}
		
		for (TaskInfo task : taskListContainingTimeSlot) {
			if (isMatchTimeSlot(startTime, startDate, endTime, endDate, task)) {
                LocalDate taskStartDate = getTaskStartDate(task);
                
                if (firstStartDate == null || 
                        taskStartDate.isBefore(firstStartDate)) {
                    firstStartDate = taskStartDate;
                }
                
				if (checkDate == null) {
					checkDate = lastContainingDate(task, startTime, endTime);
				} else {
					updateFreeDay(startTime, startDate, endTime, endDate,
							checkDate, freeDays, task);
					checkDate = lastContainingDate(task, startTime, endTime)
							.isBefore(checkDate) ? checkDate : lastContainingDate(task, startTime, endTime);

				}
			}
		}
        assert (firstStartDate == null) == (checkDate == null);

		clearMemory();
		return new FreeDayResult(freeDays, firstStartDate, checkDate, startDate, endDate);
	}

	/**
	 * to check two time date pair whether one come before the other 
	 * @param startTime  time of first task
	 * @param startDate  date of first task
	 * @param endTime  time of second task
	 * @param endDate  date of second task
	 * @return a boolean representing whether first task appears before second task
	 */
	private boolean startBeforeEnd(LocalTime startTime, LocalDate startDate,
            LocalTime endTime, LocalDate endDate) {
        return !endDate.isBefore(startDate) && !endTime.isBefore(startTime);
    }

	
	/**
	 * This function is to update the free day list by adding new free days 
	 * @param startTime
	 * @param startDate
	 * @param endTime
	 * @param endDate
	 * @param checkDate
	 * @param freeDays
	 * @param task
	 */
    private void updateFreeDay(LocalTime startTime, LocalDate startDate,
			LocalTime endTime, LocalDate endDate, LocalDate checkDate,
			ArrayList<LocalDate> freeDays, TaskInfo task) {
		if (firstContainingDate(task, startTime, endTime).isAfter(
				checkDate)) {
			LocalDate tempDate = checkDate.minusDays(-1);
			while (tempDate.isBefore(firstContainingDate(task,
					startTime, endTime))) {
				
				if (tempDate.isAfter(startDate.minusDays(1))
						&& (tempDate.isBefore(endDate.minusDays(-1)))){
					freeDays.add(tempDate);
				}
				tempDate = tempDate.minusDays(-1);
			}
		}
	}

    /**
     * This is to check whether a task happens in the specific time slot
     * @param startTime start time of spare interval
     * @param startDate start date of searching period
     * @param endTime end time of spare interval
     * @param endDate end date of searching period
     * @param task task to check
     * @return a boolean whether task happens in the specific time slot
     */
	private boolean isMatchTimeSlot(LocalTime startTime, LocalDate startDate,
			LocalTime endTime, LocalDate endDate, TaskInfo task) {
	    
        LocalDateTime myStart = LocalDateTime.of(startDate, startTime);
        LocalDateTime myEnd = LocalDateTime.of(endDate, endTime);
        
        LocalDateTime taskStart = LocalDateTime.of(getTaskStartDate(task),
                getTaskStartTime(task));
        LocalDateTime taskEnd = LocalDateTime.of(task.getEndDate(),
                task.getEndTime());

        return (beforeOrEqual(myStart, taskEnd) &&
                beforeOrEqual(taskStart, myEnd));
	}
    
    private boolean beforeOrEqual(LocalDateTime dateTime1, LocalDateTime dateTime2) {
        return (!dateTime1.isAfter(dateTime2));
    }

	
	public Result searchFreeDay(LocalDate startDate, LocalDate endDate) {
        LocalTime startTime = START_OF_DAY;
        LocalTime endTime = END_OF_DAY;
	    
	    return searchFreeDay(startTime, startDate, endTime, endDate) ;
	}

	private void sortTask() {
		Collections.sort(taskList, new Comparator<TaskInfo>() {
			@Override
			public int compare(TaskInfo task1, TaskInfo task2) {

				if (getTaskStartDate(task1).isBefore(getTaskStartDate(task2))) {
					return -1;
				} else if (getTaskStartDate(task1).isAfter(
						getTaskStartDate(task2))) {
					return 1;
				} else {
					return 0;
				}
			}
		});
	}

	private boolean isContainTimeSlot(TaskInfo task, LocalTime startTime,
			LocalTime endTime) {

		if (task.endTime == null){	  // no time task, not count
			return false;
		}

		if (getTaskStartDate(task).equals(task.getEndDate())) { // One day task
			if ((getTaskStartTime(task).isAfter(endTime))
					|| (task.getEndTime().isBefore(startTime))) {
				return false;
			}
		} else if (getTaskStartDate(task) != task.getEndDate()) { // Task that
			// last more
			// than 1
			// day
			if ((getTaskStartDate(task).minusDays(-1)
					.isEqual(task.getEndDate()))
					&& (getTaskStartTime(task).isAfter(endTime))
					&& (task.getEndTime().isBefore(startTime))) {
				return false;
			}
		}
		return true;
	}

	/**
	 * This is to find the list of tasks that appears in a specific time slot
	 * @param startTime start time of time slot
	 * @param endTime end time of time slot
	 * @return list of tasks
	 */
	private ArrayList<TaskInfo> findTaskContainingTimeSlot(LocalTime startTime,
			LocalTime endTime) {
		ArrayList<TaskInfo> matchingTask = new ArrayList<TaskInfo>();
		for (TaskInfo task : taskList) {
		    TaskInfo currentTaskInfo = new TaskInfo(task);
		    if (dateWithoutTime(currentTaskInfo)) {
		        makeIntoWholeDayTask(currentTaskInfo);
		    }
		    
			if (isContainTimeSlot(currentTaskInfo, startTime, endTime)) {
				matchingTask.add(currentTaskInfo);

			}
		}
		return matchingTask;
	}
	
	private boolean dateWithoutTime(TaskInfo taskInfo) {
	    return (taskInfo.endTime == null && taskInfo.endDate != null);
	}
	
	private void makeIntoWholeDayTask(TaskInfo taskInfo) {
	    if (taskInfo.startDate == null) {
	        taskInfo.startDate = taskInfo.endDate;
	    }
        taskInfo.startTime = START_OF_DAY;
        taskInfo.endTime = END_OF_DAY;
	}
	

	private LocalDate lastContainingDate(TaskInfo task, LocalTime startTime,
			LocalTime endTime) {
		if (task.getEndTime().isBefore(startTime)) {
			return task.getEndDate().minusDays(1);
		} else {
			return task.getEndDate();
		}
	}

	private LocalDate firstContainingDate(TaskInfo task, LocalTime startTime,
			LocalTime endTime) {
		if (getTaskStartTime(task).isAfter(endTime)) {
			return getTaskStartDate(task).minusDays(-1);
		} else {
			return getTaskStartDate(task);
		}
	}

	private LocalTime getTaskStartTime(TaskInfo task) {
		if (task.getEndTime() == null) {
			return null;
		} else if (task.getStartTime() == null) {
			return task.getEndTime();
		} else {
			return task.getStartTime();
		}
	}

	private LocalDate getTaskStartDate(TaskInfo task) {
		if (task.getEndDate() == null) {
			return null;
		} else if (task.getStartDate() == null) {
			return task.getEndDate();
		} else {
			return task.getStartDate();
		}
	}
}
	// End of segment: src\manager\datamanager\FreeDaySearchManager.java





	/**
	 * origin: src\manager\datamanager\freetimemanager\FreeTimeSearchManager.java
	 */

public class FreeTimeSearchManager extends AbstractManager {
	
	private ArrayList<TaskInfo> taskList;
	private ArrayList<Interval> freeTimeList;
	private final LocalTime DAY_START_TIME = LocalTime.of(0, 0);
	private final LocalTime DAY_END_TIME = LocalTime.of(23, 59);
	
	public FreeTimeSearchManager(TaskData taskData) {
		super(taskData);
	}

    public Result searchFreeTimeSlot(LocalDate date){
        taskList = getTaskList();
        freeTimeList = generateTimeList();
        processTaskList(date);
        postProcessIntervalList();
        return new FreeTimeResult(date, freeTimeList);
    }
    

    private Interval getTaskTimeOnDate(TaskInfo taskInfo, LocalDate date){
		
		
		if (taskInfo.getEndDate() == null){ // floating task
			return null;
		} else if (taskInfo.getEndTime() == null){ // no time task
			return null;
		} else if (taskInfo.getEndDate().isBefore(date)){ // past task
			return null;
		}
		 
		if (taskInfo.getEndDate().isEqual(date)){ // end that day
			if (taskInfo.getStartDate() == null){
				// if deadline task, set it to be the time interval before the deadline
				return new Interval(taskInfo.getEndTime().minusMinutes(1), taskInfo.getEndTime());
			} else if (taskInfo.getStartDate().equals(date)){
				return new Interval(taskInfo.getStartTime(), taskInfo.getEndTime());
			} else if (taskInfo.getStartDate().isBefore(date)){
				return new Interval(DAY_START_TIME, taskInfo.getEndTime());
			}
		}
		if (taskInfo.getEndDate().isAfter(date)){
			if (taskInfo.getStartDate() == null){
				return null;
			} else if (taskInfo.getStartDate().isAfter(date)){
				return null;
			} else if (taskInfo.getStartDate().equals(date)){
				return new Interval(taskInfo.getStartTime(),DAY_END_TIME);
			} else if (taskInfo.getStartDate().isBefore(date)){
				return new Interval(DAY_START_TIME, DAY_END_TIME);
			}
		}
		return null;
	}
		
	private ArrayList<Interval> generateTimeList(){
		ArrayList<Interval> list = new ArrayList<>();
		for (int i = 0; i < 24; i++){
			list.add(new Interval(LocalTime.of(i, 0), LocalTime.of(i, 59),false));
		}
		return list;
	}

	private ArrayList<TaskInfo> getTaskList(){
		ArrayList<TaskInfo> list = new ArrayList<>();
		TaskId taskId = taskData.getFirst();
		TaskInfo task;
		while (taskId.isValid()){
			task = taskData.getTaskInfo(taskId);
			list.add(task);
			taskId = taskData.getNext(taskId);
		}
		return list;
	}
	
	private void processInterval(Interval interval){
		if (interval == null){
			return;
		}
		int startHour = interval.getStartTime().getHour();
		int endHour = interval.getEndTime().getHour();
		
		for (int i = startHour; i <= endHour; i++){
			freeTimeList.get(i).setOccupied(true);
		}
	}
	
	private void processTaskList(LocalDate date){
		
		for (TaskInfo taskInfo : taskList){
			Interval itvl = getTaskTimeOnDate(taskInfo, date);
			processInterval(itvl);
		}
	}
		
    private void postProcessIntervalList() {
        LinkedList<Interval> mergedIntervals = new LinkedList<>();
        
        for (Interval interval : freeTimeList) {
            if (!interval.isOccupied()) {
                Interval previous = mergedIntervals.isEmpty() ? null :
                    mergedIntervals.getLast();
                
                if (previous != null && interval.immediatelyAfter(previous)) {
                    mergedIntervals.removeLast();
                    mergedIntervals.addLast(previous.concatenate(interval));
                } else {
                    mergedIntervals.add(new Interval(interval));
                }
            }
        }
        
        freeTimeList = new ArrayList<>(mergedIntervals.size());
        for (Interval interval : mergedIntervals) {
            freeTimeList.add(interval);
        }
    }
}

	// End of segment: src\manager\datamanager\freetimemanager\FreeTimeSearchManager.java





	/**
	 * origin: src\manager\datamanager\freetimemanager\Interval.java
	 */

public class Interval {
	
	private final LocalTime startTime;
	private final LocalTime endTime;
	private boolean isOccupied;
	
	public Interval(Interval copy) {
	    this.startTime = copy.startTime;
	    this.endTime = copy.endTime;
	    this.isOccupied = copy.isOccupied;
	}
	
	public Interval(LocalTime startTime, LocalTime endTime) {
		this.startTime = startTime;
		this.endTime = endTime;
	}
	
	public Interval(LocalTime startTime, LocalTime endTime, boolean status) {
		this.startTime = startTime;
		this.endTime = endTime;
		this.isOccupied = status;
	}

	public LocalTime getStartTime(){
		return startTime;
	}
	
	public LocalTime getEndTime(){
		return endTime;
	}
    
    public LocalTime getRoundedEndTime(){
        LocalTime plus30 = endTime.plusMinutes(30);
        return LocalTime.of(plus30.getHour(), 0);
    }
	
	public Boolean isOccupied(){
		return isOccupied;
	}
	
	public void setOccupied(Boolean status){
		isOccupied = status;
	}

    public boolean immediatelyAfter(Interval previous) {
        return previous.endTime.plusMinutes(1).equals(this.startTime);
    }

    public Interval concatenate(Interval next) {
        return new Interval(this.startTime, next.endTime);
    }

    @Override
    public String toString() {
        return "[" + startTime + "-" + endTime
                + "," + isOccupied + "]";
    }
}

	// End of segment: src\manager\datamanager\freetimemanager\Interval.java





	/**
	 * origin: src\manager\datamanager\ReportManager.java
	 */

/**
 * manager to handle report functionality, telling users how many missed task,
 * today task, tomorrow task and urgent task that happen within today and 
 * tomorrow.
 *
 */
public class ReportManager extends AbstractManager{

	private ArrayList<TaskInfo> taskList;

	public ReportManager(TaskData taskData) {
		super(taskData);
	}

    public Result report(){
        taskList = updateTasks();
        ArrayList<TaskInfo> missedTasks = getMissedTasks();
        ArrayList<TaskInfo> todayTasks = getTaskByDate(LocalDate.now());
        ArrayList<TaskInfo> tmrTasks = getTaskByDate(LocalDate.now().minusDays(-1));
        ArrayList<TaskInfo> urgentTasks = getUrgentTasksFrom(todayTasks, tmrTasks);
        ArrayList<TaskInfo> nonUrgentTasks = getNonUrgentTasksFrom(todayTasks, tmrTasks);

        return new ReportResult(todayTasks.size(), tmrTasks.size(),
                urgentTasks, nonUrgentTasks, missedTasks);
    }
    
    /**
     * This is to get the actual date of a task, avoiding the mis-count of midnight
     * @param task task to check
     * @return actual date of task
     */
    private LocalDate getActualDate(TaskInfo task) {
        if (task.endTime == null) {
            return task.endDate;
        } else if (task.startTime == null) {
            return task.endDate;
        } else {
            if (task.endTime == LocalTime.MIDNIGHT) {
                return task.endDate.plusDays(-1);
            } else {
                return task.endDate;
            }
        }
    }
    
    private ArrayList<TaskInfo> split(TaskInfo task) {
        ArrayList<TaskInfo> result = new ArrayList<TaskInfo>();
        if (task.getStartTime() == null) {
            result.add(task);
        } else {
            LocalDate currentDate = task.getStartDate();
            LocalTime currentTime = task.getStartTime();
            while (!currentDate.equals(task.getEndDate())) {
                TaskInfo taskInfo = new TaskInfo(task);
                taskInfo.startTime = currentTime;
                taskInfo.startDate = currentDate;
                taskInfo.endTime = LocalTime.MIDNIGHT;
                taskInfo.endDate = currentDate.plusDays(1);
                result.add(taskInfo);
                currentTime = LocalTime.parse("00:00");
                currentDate = currentDate.plusDays(1);
            }
            
            if (!currentTime.equals(task.getEndTime())) {
                TaskInfo taskInfo = new TaskInfo(task);
                taskInfo.startTime = currentTime;
                taskInfo.startDate = currentDate;
                taskInfo.endTime = task.endTime;
                taskInfo.endDate = task.endDate;
                result.add(taskInfo);
            }
        }
        
        return result;
    }

	private ArrayList<TaskInfo> updateTasks() {
		ArrayList<TaskInfo> list = new ArrayList<>();
		TaskId taskId = taskData.getFirst();
		TaskInfo task;
		while (taskId.isValid()) {
			task = taskData.getTaskInfo(taskId);
			if (task.status == Status.UNDONE) {
			    list.addAll(split(task));
			}
			taskId = taskData.getNext(taskId);
		}

		return list;
	}

	private boolean isTaskOnDate(TaskInfo task, LocalDate date){
	    return date.equals(getActualDate(task));
	}

    private ArrayList<TaskInfo> getTaskByDate(LocalDate date){
        ArrayList<TaskInfo> list = new ArrayList<>();
        for (TaskInfo task : taskList) {
            if (isTaskOnDate(task, date)) {
                list.add(task);
            }
        }
        return list;
    }

    private ArrayList<TaskInfo> getMissedTasks() {
        ArrayList<TaskInfo> list = new ArrayList<>();
        for (TaskInfo task : taskList) {
            if (task.status != Status.DONE && 
                    isTaskBefore(task, LocalDate.now())) {
                list.add(task);
            }
        }
        return list;
    }

    private boolean isTaskBefore(TaskInfo task, LocalDate date) {
        if (task.getEndDate() == null) {
            return false;
        }

        return task.getEndDate().isBefore(date);
    }

    /**
     * This is to get the urgent task from the task list of today and tomorrow
     * @param todayList tasks that happen today
     * @param tomorrowList tasks that happen tomorrow
     * @return urgent task list 
     */
    private ArrayList<TaskInfo> getUrgentTasksFrom(
            ArrayList<TaskInfo> todayList, ArrayList<TaskInfo> tomorrowList) {
        ArrayList<TaskInfo> list = new ArrayList<>();
        for (TaskInfo task : todayList) {
            if ((task.priority == Priority.HIGH)) {
                list.add(task);
            }
        }
        for (TaskInfo task : tomorrowList) {
            if ((task.priority == Priority.HIGH)) {
                list.add(task);
            }
        }
        return list;
    }

    /**
     * This is to get the non urgent task from the task list of today and tomorrow
     * @param todayList tasks that happen today
     * @param tomorrowList tasks that happen tomorrow
     * @return non urgent task list 
     */
    private ArrayList<TaskInfo> getNonUrgentTasksFrom(
            ArrayList<TaskInfo> todayList, ArrayList<TaskInfo> tomorrowList) {
        
        ArrayList<TaskInfo> list = new ArrayList<>();
        for (TaskInfo task : todayList) {
            if ((task.priority != Priority.HIGH)) {
                list.add(task);
            }
        }
        for (TaskInfo task : tomorrowList) {
            if ((task.priority != Priority.HIGH)) {
                list.add(task);
            }
        }
        return list;
    }
}


	// End of segment: src\manager\datamanager\ReportManager.java





	/**
	 * origin: src\manager\datamanager\test\FreeDayManagerTest.java
	 */

public class FreeDayManagerTest {

	TaskInfo task1 = createTask("apple", getTime(3,0), getDate(11,16),getTime(9, 0), getDate(11, 16));
	TaskInfo task2 = createTask("banana", getTime(5, 0), getDate(11, 16), getTime(12, 0), getDate(11, 17));
	TaskInfo task3 = createTask("cheese", getTime(13, 0), getDate(11,20), getTime(19, 0), getDate(11, 20));
	TaskInfo task4 = createTask("dip", null, null , getTime(10, 0), getDate(11, 19));
	TaskInfo task5 = createTask("egg", getTime(19, 0), getDate(10, 30), getTime(20, 0), getDate(10, 30));
	TaskInfo task6 = createTask("fish", null, null, null, null);
	TaskInfo task7 = createTask("gum", getTime(10, 0), getDate(11, 8), getTime(16, 0), getDate(11, 10));
	TaskInfo task8 = createTask("ham", null, null, null, getDate(11, 3));
	
	@Test
	public void testDate1() {
		TaskData taskData = new TaskData();
		
		// Tasks on 16, 17, 20 november
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task3);
		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getDate(10,9), getDate(11, 28));
		FreeDayResult finResult = (FreeDayResult) result;
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		freeDates.add(getDate(11, 18));
		freeDates.add(getDate(11, 19));
		LocalDate startDate = getDate(11, 16);
        LocalDate lastTaskEndDate = getDate(11, 20);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
	}
	
	
    @Test
    public void testDate2 () {
		
		TaskData taskData = new TaskData();

        // Tasks on 20, 16, 17, 3 november, (8-10) november
		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task8);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getDate(10,9), getDate(11, 18));
		FreeDayResult finResult = (FreeDayResult) result;
		
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		
		freeDates.add(getDate(11, 4));
		freeDates.add(getDate(11, 5));
		freeDates.add(getDate(11, 6));
		freeDates.add(getDate(11, 7));
		freeDates.add(getDate(11, 11));
		freeDates.add(getDate(11, 12));
		freeDates.add(getDate(11, 13));
		freeDates.add(getDate(11, 14));
		freeDates.add(getDate(11, 15));
		
		LocalDate startDate = getDate(11, 3);
		LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
		
//		result = manager.searchFreeTimeSlot(getTime(6, 0), getDate(10, 9), getTime(8, 0), getDate(10, 28));
//		FreeDayResult finResult = (FreeDayResult) result;
//		System.out.println(finResult.getFreeDate().size());
//		System.out.println(finResult.getFreeDate());
//		System.out.println(finResult.getStartDate());
//		System.out.println(finResult.getLastTaskEndDate());
		
	}

    @Test
    public void testDate3 () {
		
		TaskData taskData = new TaskData();

		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task5);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getDate(10,9), getDate(11, 18));
		FreeDayResult finResult = (FreeDayResult) result;
		
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		
		freeDates.add(getDate(10, 31));
		freeDates.add(getDate(11, 1));
		freeDates.add(getDate(11, 2));
		freeDates.add(getDate(11, 3));
		freeDates.add(getDate(11, 4));
		freeDates.add(getDate(11, 5));
		freeDates.add(getDate(11, 6));
		freeDates.add(getDate(11, 7));
		freeDates.add(getDate(11, 11));
		freeDates.add(getDate(11, 12));
		freeDates.add(getDate(11, 13));
		freeDates.add(getDate(11, 14));
		freeDates.add(getDate(11, 15));
		
		LocalDate startDate = getDate(10, 30);
		LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
    }
    
    @Test
    public void testDate4() {
		
		TaskData taskData = new TaskData();

		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task5);
		taskData.add(task6);
		taskData.add(task8);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getDate(10,9), getDate(11, 18));
		FreeDayResult finResult = (FreeDayResult) result;
		
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		
		freeDates.add(getDate(10, 31));
		freeDates.add(getDate(11, 1));
		freeDates.add(getDate(11, 2));
		freeDates.add(getDate(11, 4));
		freeDates.add(getDate(11, 5));
		freeDates.add(getDate(11, 6));
		freeDates.add(getDate(11, 7));
		freeDates.add(getDate(11, 11));
		freeDates.add(getDate(11, 12));
		freeDates.add(getDate(11, 13));
		freeDates.add(getDate(11, 14));
		freeDates.add(getDate(11, 15));
		
		LocalDate startDate = getDate(10, 30);
		LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
    }    
    
    @Test
    public void testTime1() {
    	
    	TaskData taskData = new TaskData();

        // Tasks on 20, 16, 17, 3 november, (8-10) november
		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task8);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;

        // Time matches:
        // Tasks on X20, y16, y17, y3 november, (8-10)->(9-10) november
        // range: 9 oct to 28 nov
		result = manager.searchFreeDay(getTime(6, 0), getDate(10, 9), getTime(8, 0), getDate(11, 28));
		FreeDayResult finResult = (FreeDayResult) result;
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();

        freeDates.add(getDate(11, 4));
        freeDates.add(getDate(11, 5));
        freeDates.add(getDate(11, 6));
        freeDates.add(getDate(11, 7));
        freeDates.add(getDate(11, 8));
        
		freeDates.add(getDate(11, 11));
		freeDates.add(getDate(11, 12));
		freeDates.add(getDate(11, 13));
		freeDates.add(getDate(11, 14));
		freeDates.add(getDate(11, 15));
		
		
		LocalDate startDate = getDate(11, 3);
        LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
    }
    
    @Test
    public void testTime2() {
    	
    	TaskData taskData = new TaskData();
    	
		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task8);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getTime(6, 0), getDate(11,14), getTime(8, 0), getDate(11, 28));
		FreeDayResult finResult = (FreeDayResult) result;
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		
		LocalDate startDate = getDate(11, 16);
        LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);

    }
    
    @Test
    public void testTime3 () {
		
		TaskData taskData = new TaskData();

		taskData.add(task3);
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task7);
		taskData.add(task5);

		
		FreeDaySearchManager manager = new FreeDaySearchManager(taskData);
		Result result;
		
		result = manager.searchFreeDay(getTime(10, 0), getDate(10,9), getTime(11, 0), getDate(11, 18));
		FreeDayResult finResult = (FreeDayResult) result;
		
		
		ArrayList<LocalDate> freeDates = new ArrayList<>();
		
		
		freeDates.add(getDate(11, 11));
		freeDates.add(getDate(11, 12));
		freeDates.add(getDate(11, 13));
		freeDates.add(getDate(11, 14));
		freeDates.add(getDate(11, 15));
		
		LocalDate startDate = getDate(11, 8);
		LocalDate lastTaskEndDate = getDate(11, 17);
        FreeDayResult templateResult = new FreeDayResult(freeDates, startDate, lastTaskEndDate,null,null);
		
		assertResultEquals(templateResult, finResult);
    }
    
    private void assertResultEquals(FreeDayResult actual, FreeDayResult output) {
        assertEquals(actual.getFirstBusyDate(), output.getFirstBusyDate());
        assertEquals(actual.getLastBusyDate(), output.getLastBusyDate());
        assertEquals(actual.getFreeDateList().size(), output.getFreeDateList().size());
        assertEquals(actual.getFreeDateList(), output.getFreeDateList());
    }
	
	
	private static TaskInfo createTask(String name,LocalTime startTime, LocalDate startDate,
			LocalTime endTime, LocalDate endDate){
		TaskInfo taskInfo = TaskInfo.create();
		taskInfo.name = name;
		taskInfo.startTime = startTime;
		taskInfo.startDate = startDate;
		taskInfo.endTime = endTime;
		taskInfo.endDate = endDate;
		return taskInfo;
	}

	private static LocalTime getTime(int hour, int minute){
		return LocalTime.of(hour, minute);
	}

	private static LocalDate getDate(int month, int day){
		return LocalDate.of(2014, month, day);
	}
}

	// End of segment: src\manager\datamanager\test\FreeDayManagerTest.java





	/**
	 * origin: src\manager\datamanager\test\FreeTimeManagerTest.java
	 */

public class FreeTimeManagerTest {
	
	TaskInfo task1 = createTask("apple", getTime(3,0), getDate(11,16),getTime(9, 0), getDate(11, 16));
	TaskInfo task2 = createTask("banana", getTime(5, 0), getDate(11, 16), getTime(12, 0), getDate(11, 17));
	TaskInfo task3 = createTask("cheese", getTime(13, 0), getDate(11,15), getTime(19, 0), getDate(11, 15));
	TaskInfo task4 = createTask("dip", null, null , getTime(11, 0), getDate(11, 16));
	TaskInfo task5 = createTask("egg", getTime(19, 0), getDate(10, 30), getTime(1, 20), getDate(11,16));
	TaskInfo task6 = createTask("fish", null, null, null, null);
	TaskInfo task7 = createTask("gum", getTime(10, 0), getDate(11, 8), getTime(16, 0), getDate(11, 10));
	TaskInfo task8 = createTask("ham", null, null, null, getDate(11, 3));

	/**
	 * Test simple task within a day
	 */
	@Test
	public void test1(){ 
		TaskData taskData = new TaskData();
		FreeTimeSearchManager manager = new FreeTimeSearchManager(taskData);
		Result result;

		taskData.add(task1);
		result = manager.searchFreeTimeSlot(getDate(11, 16));
		FreeTimeResult freeTimeResult = (FreeTimeResult) result;
		
		
		
		ArrayList<Interval> freeTimeList = new ArrayList<>();
        freeTimeList.add(makeInterval(0, 3));
        freeTimeList.add(makeInterval(10, 24));
		
		assertResultEquals(freeTimeList, freeTimeResult.getFreeTimeList());
	}
	
	/**
	 * Test task that last until next day
	 */
	@Test
	public void test2(){
		TaskData taskData = new TaskData();
		FreeTimeSearchManager manager = new FreeTimeSearchManager(taskData);
		Result result;
		
		taskData.add(task1);
		taskData.add(task2);
		result = manager.searchFreeTimeSlot(getDate(11, 16));
		FreeTimeResult freeTimeResult = (FreeTimeResult) result;
		
		
		ArrayList<Interval> freeTimeList = new ArrayList<>();
        freeTimeList.add(makeInterval(0, 3));
		
		
		
		assertResultEquals(freeTimeList, freeTimeResult.getFreeTimeList());
	}
	
	/**
	 * Test task with only end date and time
	 */
	@Test
	public void test3(){
		TaskData taskData = new TaskData();
		FreeTimeSearchManager manager = new FreeTimeSearchManager(taskData);
		Result result;
		
		taskData.add(task1);
		taskData.add(task3);
		taskData.add(task4);
		
		result = manager.searchFreeTimeSlot(getDate(11, 16));
		FreeTimeResult freeTimeResult = (FreeTimeResult) result;
		
				
		ArrayList<Interval> freeTimeList = new ArrayList<>();
        freeTimeList.add(makeInterval(0, 3));
        freeTimeList.add(makeInterval(12, 24));
		
		
		assertResultEquals(freeTimeList, freeTimeResult.getFreeTimeList());
	}
	
	/**
	 * Test task that start before specified date and last until that date
	 */
	@Test
	public void test4(){
		TaskData taskData = new TaskData();
		FreeTimeSearchManager manager = new FreeTimeSearchManager(taskData);
		Result result;
		
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task3);
		taskData.add(task4);
		taskData.add(task5);
		result = manager.searchFreeTimeSlot(getDate(11, 16));
		FreeTimeResult freeTimeResult = (FreeTimeResult) result;
		
		
		ArrayList<Interval> freeTimeList = new ArrayList<>();
        freeTimeList.add(makeInterval(2, 3));
		
		
		assertResultEquals(freeTimeList, freeTimeResult.getFreeTimeList());
	}
	
	/**
	 * Test totally free day with no task
	 */
	@Test
	public void test5(){
		TaskData taskData = new TaskData();
		FreeTimeSearchManager manager = new FreeTimeSearchManager(taskData);
		Result result;
		
		taskData.add(task1);
		taskData.add(task2);
		taskData.add(task3);
		taskData.add(task4);
		taskData.add(task5);
		
		result = manager.searchFreeTimeSlot(getDate(11, 20));
		FreeTimeResult freeTimeResult = (FreeTimeResult) result;
		
		
		ArrayList<Interval> freeTimeList = new ArrayList<>();
        freeTimeList.add(makeInterval(0, 24));
		
		
		assertResultEquals(freeTimeList, freeTimeResult.getFreeTimeList());
	}
	
	private Interval makeInterval(int startHour, int endHour) {
	    return new Interval(getTime(startHour, 0), getTime(endHour-1, 59), false);
	}
	
	private boolean assertResultEquals(ArrayList<Interval> list1, ArrayList<Interval> list2){
		boolean result = true;
		int size1 = list1.size();
		int size2 = list2.size();
		
		assertEquals(size1, size2);
		for (int i = 0; i < size1; i++){
			assertEquals(list1.get(i).getStartTime(), list2.get(i).getStartTime());
			assertEquals(list1.get(i).getEndTime(), list2.get(i).getEndTime());
		}
		return result;
	}
	
	private static TaskInfo createTask(String name,LocalTime startTime, LocalDate startDate,
			LocalTime endTime, LocalDate endDate){
		TaskInfo taskInfo = TaskInfo.create();
		taskInfo.name = name;
		taskInfo.startTime = startTime;
		taskInfo.startDate = startDate;
		taskInfo.endTime = endTime;
		taskInfo.endDate = endDate;
		return taskInfo;
	}
	
	private static LocalTime getTime(int hour, int minute){
		return LocalTime.of(hour, minute);
	}

	private static LocalDate getDate(int month, int day){
		return LocalDate.of(2014, month, day);
	}
}

	// End of segment: src\manager\datamanager\test\FreeTimeManagerTest.java





	/**
	 * origin: src\manager\result\AddResult.java
	 */

public class AddResult implements Result {
	
	private TaskInfo taskInfo;
	private TaskId taskId;

	public AddResult (TaskInfo taskInfo, TaskId taskId) {
		this.taskInfo = taskInfo;
		this.taskId = taskId;
	}
	@Override
	public Type getType() {
		return Type.ADD_SUCCESS;
	}
	
	public TaskInfo getTaskInfo(){
		return taskInfo;
	}
	
	public TaskId getTaskId(){
		return taskId;
	}

}

	// End of segment: src\manager\result\AddResult.java





	/**
	 * origin: src\manager\result\DeleteResult.java
	 */

public class DeleteResult implements Result{
	
	private TaskId[] taskIds;
	private TaskInfo[] tasks;
	
	public DeleteResult(TaskId[] taskIds, TaskInfo[] tasks){
		this.taskIds = taskIds;
		this.tasks = tasks;
	}

	@Override
	public Type getType() {
		return Type.DELETE_SUCCESS;
	}
	
	public TaskId[] getTaskIds(){
		return taskIds;
	}

	public TaskInfo[] getTasks(){
		return tasks;
	}
	
}

	// End of segment: src\manager\result\DeleteResult.java





	/**
	 * origin: src\manager\result\EditResult.java
	 */

public class EditResult implements Result {
	
	private Type type;
	private TaskInfo[] tasks;
	private TaskId[] taskIds;
	private EditSuccessfulMessage.Field[] changedFields;

	public EditResult (Type type, TaskInfo[] tasks, TaskId[] taskIds, EditSuccessfulMessage.Field[] fields){
	    assert type == Type.EDIT_SUCCESS;
		this.type = type;
		this.tasks = tasks;
		this.taskIds = taskIds;
		this.changedFields = fields;
	}
	
	public EditResult (Type type, TaskInfo[] tasks, TaskId[] taskIds, EditSuccessfulMessage.Field field){
		this.type = type;
		this.tasks = tasks;
		this.taskIds = taskIds;
		this.changedFields = new EditSuccessfulMessage.Field[1];
		changedFields[0] = field;
	}

	@Override
	public Type getType() {
		return type;
	}
	
	public TaskInfo[] getTasks(){
		return tasks;
	}
	
	public TaskId[] getTaskIds(){
		return taskIds;
	}

	public EditSuccessfulMessage.Field[] getChangedFields(){
		return changedFields;
	}

}

	// End of segment: src\manager\result\EditResult.java





	/**
	 * origin: src\manager\result\FreeDayResult.java
	 */

/**
 * This is a result generated by FreeTimeSlotManager
 * The result contains the free days (or days with specific time period) from now to 
 * the date of last task
 * firstTaskDate represents the first date that is not free,
 * LastTaskEndDate represents the end date of the latest task.
 * The free days are [now, firstTaskDate -1], {freeDate}, [lastTaskEndDate + 1, future]
 */
public class FreeDayResult implements Result{

	private ArrayList<LocalDate> freeDates;
	private LocalDate lastBusyDate;
	private LocalDate firstBusyDate;
	private LocalDate searchStartDate;
	private LocalDate searchEndDate;
	
	public FreeDayResult(ArrayList<LocalDate> freeDate, LocalDate startDate, LocalDate lastTaskEndDate,
			LocalDate searchStartDate, LocalDate searchEndDate) {
		this.freeDates = freeDate;
		this.firstBusyDate = startDate;
		this.lastBusyDate = lastTaskEndDate;
		this.searchStartDate = searchStartDate;
		this.searchEndDate = searchEndDate;
	}
	
	@Override
	public Type getType() {
		return Type.FREE_DAY;
		
	}
	
	public ArrayList<LocalDate> getFreeDateList(){
		return freeDates;
	}
	
	public LocalDate getLastBusyDate(){
		return lastBusyDate;
	}
	
	public LocalDate getFirstBusyDate(){
		return firstBusyDate;
	}
	
	public LocalDate getSearchStartDate(){
		return searchStartDate;
	}
	
	public LocalDate getSearchEndDate(){
		return searchEndDate;
	}

}

	// End of segment: src\manager\result\FreeDayResult.java





	/**
	 * origin: src\manager\result\FreeTimeResult.java
	 */

public class FreeTimeResult implements Result {

	private ArrayList<Interval> freeTimeList;
	private LocalDate date;
	
	public FreeTimeResult(LocalDate date, ArrayList<Interval> list){
		this.date = date;
		this.freeTimeList = new ArrayList<>(list);
	}
	
	public LocalDate getDate(){
		return date;
	}
	
	public ArrayList<Interval> getFreeTimeList(){
		return freeTimeList;
	}
	

	@Override
	public Type getType() {
		return Type.FREE_TIME;
	}
}

	// End of segment: src\manager\result\FreeTimeResult.java





	/**
	 * origin: src\manager\result\ReportResult.java
	 */

public class ReportResult implements Result{

    private final int nTodayTasks;
    private final int nTomorrowTasks;
    private final ArrayList<TaskInfo> urgentTasks;
    private final ArrayList<TaskInfo> nonUrgentTasks;
    private final ArrayList<TaskInfo> missedTasks;
	
    public ReportResult(int nTodayTasks, int nTomorrowTasks,
            ArrayList<TaskInfo> urgentTasks, ArrayList<TaskInfo> nonUrgentTasks,
            ArrayList<TaskInfo> missedTasks) {
        this.nTodayTasks = nTodayTasks;
        this.nTomorrowTasks = nTomorrowTasks;
        this.urgentTasks = urgentTasks;
        this.nonUrgentTasks = nonUrgentTasks;
        this.missedTasks = missedTasks;
    }

    public Type getType() {
		return Type.REPORT;
	}
	
	public int countTodayTasks() {
	    return nTodayTasks;
	}
	
	public int countTmrTasks() {
	    return nTomorrowTasks;
	}
    
    public ArrayList<TaskInfo> getUrgentTasks() {
        return urgentTasks;
    }
    
    public ArrayList<TaskInfo> getNonUrgentTasks() {
        return nonUrgentTasks;
    }
    
    public ArrayList<TaskInfo> getMissedTasks() {
        return missedTasks;
    }

}

	// End of segment: src\manager\result\ReportResult.java





	/**
	 * origin: src\manager\result\StartEditModeResult.java
	 */

public class StartEditModeResult implements Result {

    private final TaskIdSet taskIdSet;

    public StartEditModeResult(TaskIdSet taskIdSet){
        this.taskIdSet = taskIdSet;
    }
    
    @Override
    public Type getType() {
        return Type.EDIT_MODE_START;
    }

    public TaskIdSet getTaskIdSet(){
        return taskIdSet;
    }
}

	// End of segment: src\manager\result\StartEditModeResult.java





	/**
	 * origin: src\manager\StateManager.java
	 */

/**
 * This is a state manager that keep track of the availability 
 * of executing a certain command.
 * It can also update the state by giving a result generated by managers
 * and return a response to command. *
 */
public class StateManager {
    private static final Logger log = TasklineLogger.getLogger();

	private State currentState;
	private TaskIdSet editingTaskIdSet;
	private UpdateManager updateManager;
	private TargetedCommand savedCommand;
	private Filter[] lastSearchFilters;
	
	public enum State {
	    AVAILABLE,      // Normal state
	    EDIT_MODE,      // Can edit the same task without re-specifying task ID
	    SEARCH_MODE,    // In search mode, searchAgain is called after each command
        WAITING_MODE,     // In waiting mode, a command is waiting for arguments before execution.
        LOCKED_MODE     // In locked mode, no modifying data is allowed
	}

	public StateManager(IFileInputOutput fileInputOutput,
	        IFileInputOutput aliasFileInputOutput, UndoManager undoManager,
	        SearchManager searchManager) {
	    
		this.currentState = State.AVAILABLE;
		this.updateManager = new UpdateManager(fileInputOutput,
		        aliasFileInputOutput, undoManager, searchManager);
	}

    public boolean canExit() {
        return true;
    }


	public boolean canAdd() {
		return true;
	}

	public boolean canSearch() {
        return true;
	}

    public boolean canGetReport() {
        return true;
    }

	public boolean canEdit() {
        return true;
	}

	public boolean canDelete() {
        return true;
	}

	public boolean canUndo() {
        return true;
	}

    public boolean canGoBack() {
        return inState(State.EDIT_MODE) || inState(State.SEARCH_MODE) ||
                inState(State.WAITING_MODE);
    }
    
    public boolean inEditMode() {
        return inState(State.EDIT_MODE);
    }
    
    public boolean canQuerySearchManager() {
        return inState(State.SEARCH_MODE) || inState(State.WAITING_MODE);
    }
	
	private void setState(State newState) {
	    currentState = newState;
	}
	
	private boolean inState(State state) {
	    assert currentState != null : "State cannot be null";
	    return (currentState == state);
	}
    
	private boolean tryEnterEditMode(TaskIdSet idSet) {
	    if (inState(State.EDIT_MODE)) {
	        return false;
	    }
	    
		setState(State.EDIT_MODE);
		editingTaskIdSet = idSet;
		return true;
	}
	
	private boolean tryExitEditMode() {
		if (inState(State.EDIT_MODE)){
			setState(State.AVAILABLE);
			editingTaskIdSet = null;
			return true;
		} else {
			return false;
		}
	}

	private boolean tryEnterSearchMode(SearchResult searchResult) {
	    if (inState(State.WAITING_MODE)) {
	        if (searchResult.noTasksFound()) {
	            exitWaitingMode();
	            setState(State.SEARCH_MODE);
	            return true;
	        } else {
	            return false;
	        }
	    }
        if (inState(State.SEARCH_MODE)) {
            return false;
        }
        
		setState(State.SEARCH_MODE);
		return true;
	}
	
	private boolean tryExitSearchMode() {
		if (inState(State.SEARCH_MODE)){
			setState(State.AVAILABLE);
			return true;
		}else{
			return false;
		}
	}
	
    
    public boolean isWaitingForArguments() {
        return inState(State.WAITING_MODE);
    }
    
    public TargetedCommand retrieveStoredCommand() {
        assert savedCommand != null;
        assert inState(State.WAITING_MODE);
        
        return getAndClearSavedCommand();
    }

    /**
     * This method is called just before anything is done by the command.
     */
    public void beforeCommandUpdate() {
       updateManager.beforeCommandUpdate();
    }

    
	/**
	 * Updates the program's state using the result obtained from the managers.
	 * @param result result returned from the manager
	 * @return response generated accordingly
	 */
	public Response update(Result result) {
        getAndClearSavedCommand();
        
		return processResult(result);
    }

    public Response updateAndStoreCommand(Result result, TargetedCommand command) {
        exitWaitingMode();
        
        setSavedCommand(command);
        return processResult(result);
    }

    private Response processResult(Result result) {
        log.log(Level.FINER, "Apply StateManager update - Result = " + 
                result.getType().name() + " / " + result.getClass().getName());
        
        updateManager.updateUndoHistory();
        
        Message message = applyResult(result);
        ModeInfo modeInfo = generateModeInfo(result);
        
        updateManager.writeToFile();

        postUpdateLog(message, modeInfo);
        return new Response(message, modeInfo);
    }

    private boolean setSavedCommand(TargetedCommand command) {
        assert savedCommand == null;
        assert !inState(State.WAITING_MODE);
        
        this.savedCommand = command;
        setState(State.WAITING_MODE);
        return true;
    }
    
    private void exitWaitingMode() {
        getAndClearSavedCommand();
    }
    
    private TargetedCommand getAndClearSavedCommand() {
        if (inState(State.WAITING_MODE)) {
            TargetedCommand temp = savedCommand;
            savedCommand = null;
            setState(State.AVAILABLE);
            return temp;
        } else {
            assert savedCommand == null;
            return null;
        }
    }
	
	
    private void postUpdateLog(Message message, ModeInfo modeInfo) {
        log.log(Level.FINE, "StateManager updated. Current State: " + currentState.name());
        log.log(Level.FINER, "Return response. Message = " +
                message.getType().name() + " / " +
                message.getClass().getName() + ". ModeInfo = " + 
                modeInfo.getType().name() + " / " + 
                modeInfo.getClass().getName());
    }

    /**
     * Generate corresponding modeInfo according to result and current state
     * @param result result to generate modeinfo
     * @return generated modeInfo
     */
	private ModeInfo generateModeInfo(Result result) {
	    switch (currentState) {
	        case AVAILABLE :
	            return new EmptyModeInfo();

            case SEARCH_MODE :
                return searchModeCheck(result);
                
            case EDIT_MODE :
                return editModeCheck(result);
                
            case WAITING_MODE :
                SearchModeInfo modeInfo = searchModeCheck(result);
                modeInfo.makeIntoWaitingModeInfo();
                return modeInfo;
                
            case LOCKED_MODE :
                return new EmptyModeInfo();
                
            default :
                throw new UnsupportedOperationException("Unknown state: " +
                            currentState.name());
	    }
	}

	/**
	 * This method is to handling Search Mode.
	 * If any command is executed, except a search command again under search mode, 
	 * update the SearchModeInfo by redoLastSearch and store it back to response
	 */
	private SearchModeInfo searchModeCheck(Result result) {
		if (result.getType() != Type.SEARCH_SUCCESS) {
			updateManager.redoSearch(lastSearchFilters);
		} else {
		    SearchResult searchResult = (SearchResult)result;
		    Filter[] newFilters = searchResult.getFilters();
		    if (newFilters != null) {
		        lastSearchFilters = newFilters;
		    }
		}
		
		return updateManager.getSearchModeInfo();
	}
	
	private ModeInfo editModeCheck(Result result) {
//	    TaskInfo taskInfo = searchManager.getTaskInfo(editingTaskId);
	    TaskId taskId = editingTaskIdSet.iterator().next();
	    
		TaskInfo taskInfo = updateManager.getTaskInfo(taskId);
        return new EditModeInfo(taskInfo, taskId);
	}

	
	/**
	 * This method is to generate different response according to the 
	 * type of result.
	 * @param result result to be converted
	 * @return response generated
	 */
	private Message applyResult(Result result) {
		switch (result.getType()){
            case EXIT :
                tryExitEditMode();
                tryExitSearchMode();
                return new EnumMessage(EnumMessage.MessageType.EXIT);
                
            case ADD_SUCCESS :
                tryExitEditMode();
                AddResult addResult = (AddResult)result;
                AddSuccessfulMessage addSuccessMessage = 
                        new AddSuccessfulMessage(addResult.getTaskInfo(),
                        addResult.getTaskId());
                return addSuccessMessage;

            case ADD_FAILURE : 
                return new EnumMessage(EnumMessage.MessageType.ADD_FAILED);
                
            case DELETE_SUCCESS :
                tryExitEditMode();
            	DeleteResult deleteResult = (DeleteResult)result;
                DeleteSuccessfulMessage deleteSuccessMessage = 
                		new DeleteSuccessfulMessage(deleteResult.getTasks(), 
                		        deleteResult.getTaskIds());
                return deleteSuccessMessage;
                
            case DELETE_FAILURE : 
                return new EnumMessage(MessageType.DELETE_FAILED);
                
            case EDIT_MODE_START : {
                StartEditModeResult editResult = (StartEditModeResult)result;
                tryEnterEditMode(editResult.getTaskIdSet());
                return new EnumMessage(MessageType.EDIT_STARTED);
            }

            case EDIT_MODE_END :
                tryExitEditMode();
                return new EnumMessage(EnumMessage.MessageType.EDIT_ENDED);

            case SEARCH_MODE_END : 
                tryExitSearchMode();
                return new EnumMessage(EnumMessage.MessageType.SEARCH_ENDED);
                
            case GO_BACK :
                if (inState(State.EDIT_MODE)) {
                    tryExitEditMode();
                    return new EnumMessage(EnumMessage.MessageType.EDIT_ENDED);
                } else if (inState(State.SEARCH_MODE)) {
                    tryExitSearchMode();
                    return new EnumMessage(EnumMessage.MessageType.SEARCH_ENDED);
                } else {
                    return new EnumMessage(EnumMessage.MessageType.SEARCH_ENDED);
                }

            case EDIT_SUCCESS : 
                EditResult editResult = (EditResult)result;
            	EditSuccessfulMessage editSuccessMessage = 
                        new EditSuccessfulMessage(editResult.getTasks(), editResult.getTaskIds(), editResult.getChangedFields());
            	return editSuccessMessage;

            case EDIT_FAILURE : 
                return new EnumMessage(MessageType.EDIT_FAILED);
            	
            case TAG_ADD_SUCCESS : 
            	EditResult tagAddResult = (EditResult)result;
            	EditSuccessfulMessage tagAddSuccessfulMessage = 
            			new EditSuccessfulMessage(tagAddResult.getTasks(),
            					tagAddResult.getTaskIds(), tagAddResult.getChangedFields());
            	return tagAddSuccessfulMessage;

            case TAG_ADD_FAILURE:
            	return new EnumMessage(MessageType.ADD_TAG_FAILED);

            case TAG_DELETE_SUCCESS : 
            	EditResult tagDeleteResult = (EditResult)result;
            	EditSuccessfulMessage tagDeleteSuccessfulMessage = 
            			new EditSuccessfulMessage(tagDeleteResult.getTasks(),
            					tagDeleteResult.getTaskIds(), tagDeleteResult.getChangedFields());
            	return tagDeleteSuccessfulMessage;
            	
            case TAG_DELETE_FAILURE :
            	return new EnumMessage(MessageType.DELETE_TAG_FAILED);

            case SEARCH_SUCCESS : 
                tryEnterSearchMode((SearchResult)result);
            	return new EnumMessage(MessageType.SEARCH_SUCCESS);
                
            case SEARCH_FAILURE : 
                return new EnumMessage(MessageType.SEARCH_FAILED);
                
            case UNDO_SUCCESS : 
                return new EnumMessage(MessageType.UNDO_SUCCESS);
                
            case UNDO_FAILURE : 
                return new EnumMessage(MessageType.UNDO_FAILED);
                
            case REDO_SUCCESS : 
                return new EnumMessage(MessageType.REDO_SUCCESS);
                
            case REDO_FAILURE : 
                return new EnumMessage(MessageType.REDO_FAILED);

            case INVALID_COMMAND : 
                return new EnumMessage(MessageType.INVALID_COMMAND);

            case INVALID_ARGUMENT : 
                return new EnumMessage(MessageType.INVALID_ARGUMENT);
                
            case REPORT : 
            	ReportResult reportResult = (ReportResult) result;
            	return new ReportMessage(reportResult.countTodayTasks(),
            	        reportResult.countTmrTasks(),
            	        reportResult.getUrgentTasks(),
            	        reportResult.getNonUrgentTasks(),
            	        reportResult.getMissedTasks());
                
            case FREE_DAY : 
            	FreeDayResult freeDayResult = (FreeDayResult) result;
            	FreeDaySearchMessage freeDayMessage = 
            			new FreeDaySearchMessage(freeDayResult.getFreeDateList(),
            					freeDayResult.getFirstBusyDate(), freeDayResult.getLastBusyDate(),
            					freeDayResult.getSearchStartDate(),freeDayResult.getSearchEndDate());
            	return freeDayMessage;
                
            case FREE_TIME :
            	FreeTimeResult freeTimeResult = (FreeTimeResult) result;
            	FreeTimeSearchMessage freeTimeMessage = 
            			new FreeTimeSearchMessage(freeTimeResult.getDate(),
            					freeTimeResult.getFreeTimeList());
            	return freeTimeMessage;
                
            case DETAILS :
                DetailsResult detailsResult = (DetailsResult)result;
                return new DetailsMessage(detailsResult.getTasks(),
                        detailsResult.getTaskIds());
                
            case ALIAS_SUCCESS : {
                AliasSetResult aliasResult = (AliasSetResult)result;
                return new AliasMessage(aliasResult.getAlias(),
                        aliasResult.getValue(), aliasResult.isReplacePrevious(),
                        AliasMessage.AliasType.ALIAS_SET_SUCCESS);
            }
                
            case ALIAS_FAILURE : {
                AliasSetResult aliasResult = (AliasSetResult)result;
                return new AliasMessage(aliasResult.getAlias(), null, false,
                        AliasMessage.AliasType.ALIAS_SET_FAILURE);
            }
                
            case ALIAS_DELETE_SUCCESS : {
                AliasDeleteResult aliasResult = (AliasDeleteResult)result;
                return new AliasMessage(aliasResult.getAlias(), 
                        aliasResult.getValue(),
                        AliasMessage.AliasType.ALIAS_DELETE_SUCCESS);
            }
            
            case ALIAS_DELETE_FAILURE : {
                AliasDeleteResult aliasResult = (AliasDeleteResult)result;
                return new AliasMessage(aliasResult.getAlias(), 
                        aliasResult.getValue(),
                        AliasMessage.AliasType.ALIAS_DELETE_FAILURE);
            }
            
            case VIEW_ALIAS_SUCCESS : {
                ViewAliasResult aliasResult = (ViewAliasResult)result;
                return new ViewAliasMessage(aliasResult.getAliases());
            }

            default:
                throw new UnsupportedOperationException("Unknown state: " +
                            result.getType().name());
        }
	}


}

	// End of segment: src\manager\StateManager.java





	/**
	 * origin: src\manager\test\StateManagerTest.java
	 */

public class StateManagerTest {
	
    @Test
    public void test() {
        TestOutput testOutput = new TestOutput();
        
        StubUndoManager undoManager = new StubUndoManager(testOutput);
        StubSearchManager searchManager = new StubSearchManager(testOutput);
        StubFileInputOutput fileInputOutput =
                new StubFileInputOutput(testOutput, "taskData");
        StubFileInputOutput aliasFileInputOutput =
                new StubFileInputOutput(testOutput, "alias");
        
        StateManager stateManager = new StateManager(fileInputOutput,
                aliasFileInputOutput, undoManager, searchManager);

        Result result;
        
        result = new SimpleResult(Type.ADD_FAILURE);
        stateManager.beforeCommandUpdate();
        assertEquals("taskData read\n", testOutput.getOutputAndClear());
        stateManager.update(result);
        assertEquals("update undo\n"
                + "alias write\n"
                + "taskData write\n",
                testOutput.getOutputAndClear());
    }
}

class TestOutput {
    private StringBuilder output;
    
    public TestOutput() {
        output = new StringBuilder();
    }
    
    public String getOutputAndClear() {
        String temp = output.toString();
        output = new StringBuilder();
        return temp;
    }
    
    public void writeOutput(String message) {
        output.append(message).append("\n");
    }
}


class StubUndoManager extends UndoManager {
    private final TestOutput testOutput;
    
    public StubUndoManager(TestOutput testOutput) {
        super(null);
        this.testOutput = testOutput;
    }
    
    @Override
    public void updateUndoHistory() {
        testOutput.writeOutput("update undo");
    }
    
}


class StubSearchManager extends SearchManager {
    private final TestOutput testOutput;

    public StubSearchManager(TestOutput testOutput) {
        super(null);
        this.testOutput = testOutput;
    }

    @Override
    public Result searchTasks(Filter[] filters) {
        testOutput.writeOutput("do a search");
        return null;
    }

    @Override
    public SearchResult getLastSearchResult() {
        TaskInfo[] tasks = new TaskInfo[0];
        TaskId[] taskIds = new TaskId[0];
        return new SearchResult(tasks, taskIds, null);
    }
    
}


class StubFileInputOutput implements IFileInputOutput {
    private final TestOutput testOutput;
    private final String prefix;

    public StubFileInputOutput(TestOutput testOutput, String prefix) {
        this.testOutput = testOutput;
        this.prefix = prefix;
    }

    @Override
    public boolean read() {
        testOutput.writeOutput(prefix + " read");
        return true;
    }

    @Override
    public boolean write() {
        testOutput.writeOutput(prefix + " write");
        return true;
    }
    
}

	// End of segment: src\manager\test\StateManagerTest.java





	/**
	 * origin: src\manager\UpdateManager.java
	 */

/**
 * In charge of getting updates for StateManager from the managers and
 * the FileInputOutput classes.
 */
public class UpdateManager {

    private final IFileInputOutput aliasFileInputOutput;
    private final IFileInputOutput fileInputOutput;
	private final UndoManager undoManager;
	private final SearchManager searchManager;
	
	public UpdateManager(IFileInputOutput fileInputOutput,
	        IFileInputOutput aliasFileInputOutput, UndoManager undoManager,
	        SearchManager searchManager){
	    
        this.fileInputOutput = fileInputOutput;
        this.aliasFileInputOutput = aliasFileInputOutput;
		this.undoManager = undoManager;
		this.searchManager = searchManager;	
	}

	public void redoSearch(Filter[] filters){
	    assert filters != null : "Can't search with null filters!";
		searchManager.searchTasks(filters);
	}
	
	/**
	 * This is to get the current search info within search mode
	 * @return current search info
	 */
	public SearchModeInfo getSearchModeInfo(){
		SearchResult redoSearchResult = searchManager.getLastSearchResult();
        TaskInfo[] tasks = redoSearchResult.getTasks();
        TaskId[] taskIds = redoSearchResult.getTaskIds();
        String[] suggestions = redoSearchResult.getSuggestions();
        SearchModeInfo searchModeInfo = new SearchModeInfo(tasks, taskIds, 
                suggestions);
        return searchModeInfo;
	}
	
	public TaskInfo getTaskInfo(TaskId taskId){
		return searchManager.getTaskInfo(taskId);
	}
	
	public void updateUndoHistory(){
		undoManager.updateUndoHistory();
	}
	
	public void beforeCommandUpdate(){
		 boolean fileChanged = readFromFile();
	        
        if (fileChanged) {
            undoManager.clearHistory();
        }
    }

	public boolean readFromFile() {
        return fileInputOutput.read();
    }

	public boolean writeToFile() {
	    boolean result1 = aliasFileInputOutput.write();
	    boolean result2 = fileInputOutput.write();
	    
        return result1 && result2;
    }  
	
	
}

	// End of segment: src\manager\UpdateManager.java





