//@author: nathanajah



	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\AddSuccessfulFormatter.java
	 */

 */
public class AddSuccessfulFormatter {
    private final static String FORMAT_LINE = "Task %1$s added successfully." +
            System.lineSeparator();
    
    /**
     * Formats an AddSuccessfulMessage to a String.
     * @param message The Message to be formatted.
     * @return The formatted Message.
     */
    public String format(AddSuccessfulMessage message) {
        return String.format(FORMAT_LINE, message.getTask().name);
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\AddSuccessfulFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\DeleteSuccessfulFormatter.java
	 */

 */
public class DeleteSuccessfulFormatter {
    private final static String FORMAT_SINGLE = "Task %1$s deleted." +
            System.lineSeparator();
    private final static String HEADER_MULTI = "%1$d tasks deleted.";
    private final static String TASKNAME_MULTI = "- %1$s";
    
    /**
     * Formats a DeleteSuccessfulMessage to a String.
     * @param message The DeleteSuccessfulMessage to be formatted.
     * @return The formatted Message.
     */
    public String format(DeleteSuccessfulMessage message) {
        assert message.getTask().length > 0;
        
        switch(message.getTask().length) {
            case 1 :
                return formatSingleTask(message);
            default :
                return formatMultiTask(message);
        }
    }
    
    private String formatSingleTask(DeleteSuccessfulMessage message) {
        assert message.getTask().length == 1;
        return String.format(FORMAT_SINGLE, message.getTask()[0].name);
    }
    
    private String formatMultiTask(DeleteSuccessfulMessage message) {
        assert message.getTask().length > 1;
        return getMultiHeader(message) + getMultiTaskList(message);
    }
    
    private String getMultiHeader(DeleteSuccessfulMessage message) {
        return String.format(HEADER_MULTI, message.getTask().length) + 
                System.lineSeparator();
    }
    
    private String getMultiTaskList(DeleteSuccessfulMessage message) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < message.getTask().length; i++) {
            builder.append(String.format(TASKNAME_MULTI, 
                    message.getTask()[i].name));
            builder.append(System.lineSeparator());
        }
        
        return builder.toString();
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\DeleteSuccessfulFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EditModeFormatter.java
	 */

 *
 */
public class EditModeFormatter {
    private final static String FORMAT_LINE = "You are now editing %1$s." + 
            System.lineSeparator();
    
    private String arrayListToString(ArrayList<String> lines) {
        StringBuilder builder = new StringBuilder("");
        for (String line : lines) {
            builder.append(line);
            builder.append(System.lineSeparator());
        }
        return builder.toString();
    }
    
    /**
     * Format an EditModeInfo to a String.
     * @param editInfo The EditModeInfo that needs to be formatted.
     * @return The formatted ModeInfo.
     */
    public String format(EditModeInfo editInfo) {
        DetailsUtility detailsUtil = new DetailsUtility();
        ArrayList<String> lines = new ArrayList<String>();
        lines.add(String.format(FORMAT_LINE, editInfo.getTaskId()));
        ArrayList<String> detailsLines = detailsUtil.formatToArray(editInfo.getTask(), 
                editInfo.getTaskId());
        lines.addAll(detailsLines);
        return arrayListToString(lines);
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EditModeFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EmptyModeFormatter.java
	 */

 *
 */
public class EmptyModeFormatter {
	
	/**
	 * Returns an empty String, since the ModeInfo is empty.
	 * @param emptyInfo
	 * @return an empty String.
	 */
    public String format(EmptyModeInfo emptyInfo) {
        return "";
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EmptyModeFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EnumFormatter.java
	 */

 *
 */
public class EnumFormatter {
    
    private final static String MESSAGE_INVALID_ARGUMENT = 
            "Sorry, Taskline could not execute your command." +
            System.lineSeparator();    
    private final static String MESSAGE_INVALID_COMMAND =
            "The command is invalid." + System.lineSeparator();            
    private final static String MESSAGE_ADD_FAILED =
            "Add failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_DELETE_FAILED =
            "Delete failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_EDIT_FAILED =
            "Edit failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_ADD_TAG_FAILED =
            "Add tag failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_DELETE_TAG_FAILED =
            "Delete tag failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_SEARCH_SUCCESS = "";
    private final static String MESSAGE_SEARCH_FAILED = 
            "Search failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_EDIT_STARTED = "";
    private final static String MESSAGE_EDIT_ENDED = 
            "Exiting edit mode." + 
            System.lineSeparator();
    private final static String MESSAGE_UNDO_SUCCESS = 
            "Undo successful." + 
            System.lineSeparator();
    private final static String MESSAGE_UNDO_FAILED = 
            "Undo failed. Please try again." +
            System.lineSeparator();
    private final static String MESSAGE_REDO_SUCCESS =
            "Redo successful." +
            System.lineSeparator();
    private final static String MESSAGE_REDO_FAILED =
            "Redo failed." +
            System.lineSeparator();
    private final static String MESSAGE_SEARCH_ENDED =
            "Search ended." +
            System.lineSeparator();
    private final static String MESSAGE_EXIT = 
            "Exiting Taskline." +
            System.lineSeparator();
    private final static String MESSAGE_EMPTY = "";

    /**
     * Format an EnumMessage.
     * @param message The EnumMessage that needs to be formatted.
     * @return The message, formatted to a String.
     */
    public String format(EnumMessage message) {
        String formattedResult;
        switch(message.getMessageType()) {
            case EMPTY_STRING :
                formattedResult = MESSAGE_EMPTY;
                break;
            case INVALID_ARGUMENT :
                formattedResult = MESSAGE_INVALID_ARGUMENT;
                break;
            case INVALID_COMMAND :
                formattedResult = MESSAGE_INVALID_COMMAND;
                break;
            case ADD_FAILED :
                formattedResult = MESSAGE_ADD_FAILED;
                break;
            case EDIT_FAILED :
                formattedResult = MESSAGE_EDIT_FAILED;
                break;
            case DELETE_FAILED :
                formattedResult = MESSAGE_DELETE_FAILED;
                break;
            case ADD_TAG_FAILED :
                formattedResult = MESSAGE_ADD_TAG_FAILED;
                break;
            case DELETE_TAG_FAILED :
                formattedResult = MESSAGE_DELETE_TAG_FAILED;
                break;
            case SEARCH_SUCCESS :
                formattedResult = MESSAGE_SEARCH_SUCCESS;
                break;
            case SEARCH_FAILED :
                formattedResult = MESSAGE_SEARCH_FAILED;
                break;
            case EDIT_STARTED :
                formattedResult = MESSAGE_EDIT_STARTED;
                break;
            case EDIT_ENDED :
                formattedResult = MESSAGE_EDIT_ENDED;
                break;
            case UNDO_SUCCESS :
                formattedResult = MESSAGE_UNDO_SUCCESS;
                break;
            case UNDO_FAILED :
                formattedResult = MESSAGE_UNDO_FAILED;
                break;
            case REDO_SUCCESS :
                formattedResult = MESSAGE_REDO_SUCCESS;
                break;
            case REDO_FAILED :
                formattedResult = MESSAGE_REDO_FAILED;
                break;
            case SEARCH_ENDED :
                formattedResult = MESSAGE_SEARCH_ENDED;
                break;
            case EXIT :
                formattedResult = MESSAGE_EXIT;
                break;
            default :
                formattedResult = "";
                break;
        }
        return formattedResult;
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\EnumFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\Formatter.java
	 */

 */
public class Formatter {
    private AddSuccessfulFormatter addSuccessfulFormatter;
    private DeleteSuccessfulFormatter deleteSuccessfulFormatter;
    private EditSuccessfulFormatter editSuccessfulFormatter;
    private EnumFormatter enumFormatter;
    private DetailsFormatter detailsFormatter;
    private ReportFormatter reportFormatter;
    private FreeDaySearchFormatter freeDaySearchFormatter;
    
    private EditModeFormatter editModeFormatter;
    private SearchModeFormatter searchModeFormatter;
    private EmptyModeFormatter emptyModeFormatter;
    private WaitingModeFormatter waitingModeFormatter;
    
    class MessageModePair {
        public Message.Type messageType;
        public ModeInfo.Type modeInfoType;
        
        public MessageModePair(Message.Type messageType, 
                ModeInfo.Type modeInfoType) {
            this.messageType = messageType;
            this.modeInfoType = modeInfoType;
        }
    }
    
    private final MessageModePair modePrintPair[] = new MessageModePair[]{
            new MessageModePair(Message.Type.ADD_SUCCESSFUL, 
                    ModeInfo.Type.EDIT_MODE),
            new MessageModePair(Message.Type.ADD_SUCCESSFUL, 
                    ModeInfo.Type.SEARCH_MODE),
            new MessageModePair(Message.Type.DELETE_SUCCESSFUL, 
                    ModeInfo.Type.EDIT_MODE),
            new MessageModePair(Message.Type.DELETE_SUCCESSFUL, 
                    ModeInfo.Type.SEARCH_MODE),
            new MessageModePair(Message.Type.ENUM_MESSAGE,
                    ModeInfo.Type.SEARCH_MODE),
            new MessageModePair(Message.Type.ENUM_MESSAGE,
                    ModeInfo.Type.EDIT_MODE),
            new MessageModePair(Message.Type.EDIT_SUCCESSFUL,
                    ModeInfo.Type.SEARCH_MODE),
            new MessageModePair(Message.Type.ENUM_MESSAGE,
                    ModeInfo.Type.WAITING_MODE),
    };

    /**
     * The constructor for Formatter.
     */
    public Formatter() {
        addSuccessfulFormatter = new AddSuccessfulFormatter();
        deleteSuccessfulFormatter = new DeleteSuccessfulFormatter();
        editSuccessfulFormatter = new EditSuccessfulFormatter();
        enumFormatter = new EnumFormatter();
        detailsFormatter = new DetailsFormatter();
        reportFormatter = new ReportFormatter();
        freeDaySearchFormatter = new FreeDaySearchFormatter();
        
        editModeFormatter = new EditModeFormatter();
        searchModeFormatter = new SearchModeFormatter();
        emptyModeFormatter = new EmptyModeFormatter();
        waitingModeFormatter = new WaitingModeFormatter();
    }
    
    private String formatMessage(Message message) {
        String formattedMessage = "";
        switch(message.getType()) {
            case ADD_SUCCESSFUL :
                AddSuccessfulMessage addSuccessfulMessage = 
                        (AddSuccessfulMessage)message;
                formattedMessage = addSuccessfulFormatter.format(
                        addSuccessfulMessage);
                break;
            case EDIT_SUCCESSFUL :
                EditSuccessfulMessage editSuccessfulMessage =
                        (EditSuccessfulMessage)message;
                formattedMessage = editSuccessfulFormatter.format(
                        editSuccessfulMessage);
                break;
            case DELETE_SUCCESSFUL :
                DeleteSuccessfulMessage deleteSuccessfulMessage =
                        (DeleteSuccessfulMessage)message;
                formattedMessage = deleteSuccessfulFormatter.format(
                        deleteSuccessfulMessage);
                break;
            case ENUM_MESSAGE :
                EnumMessage enumMessage = (EnumMessage)message;
                formattedMessage = enumFormatter.format(enumMessage);
                break;
            case DETAILS :
                DetailsMessage detailsMessage = (DetailsMessage)message;
                formattedMessage = detailsFormatter.format(detailsMessage);
                break;
            case REPORT :
                ReportMessage reportMessage = (ReportMessage)message;
                formattedMessage = reportFormatter.format(reportMessage);
                break;
            case FREE_DAY_SEARCH_SUCCESSFUL :
                FreeDaySearchMessage freeDaySearchMessage = 
                        (FreeDaySearchMessage)message;
                formattedMessage = 
                        freeDaySearchFormatter.format(freeDaySearchMessage);

        }
        return formattedMessage;
    }
    
    private String formatModeInfo(ModeInfo modeInfo) {
        String formattedModeInfo = "";
        switch (modeInfo.getType()) {
            case EMPTY_MODE :
                EmptyModeInfo emptyModeInfo = (EmptyModeInfo) modeInfo;
                formattedModeInfo = emptyModeFormatter.format(emptyModeInfo);
                break;
            case EDIT_MODE :
                EditModeInfo editModeInfo = (EditModeInfo) modeInfo;
                formattedModeInfo = editModeFormatter.format(editModeInfo);
                break;
            case SEARCH_MODE :
                SearchModeInfo waitingModeInfo = (SearchModeInfo) modeInfo;
                formattedModeInfo = searchModeFormatter.format(waitingModeInfo);
                break;
            case WAITING_MODE :
                SearchModeInfo searchModeInfo = (SearchModeInfo) modeInfo;
                formattedModeInfo = waitingModeFormatter.format(searchModeInfo);
                break;
        }
        return formattedModeInfo;
    }
    
    private boolean shouldPrintMode(Response response) {
        for (MessageModePair pair : modePrintPair) {
            if (pair.messageType == response.getMessage().getType() && 
                    pair.modeInfoType == response.getModeInfo().getType()) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * Format the Response to String.
     * @param response The Response object to be formatted.
     * @return The formatted String.
     */
    public String format(Response response) {
        if (shouldPrintMode(response)) {
            return formatMessage(response.getMessage()) + 
                    formatModeInfo(response.getModeInfo());
        } else {
            return formatMessage(response.getMessage());
        }
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\Formatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\SearchModeFormatter.java
	 */

 */
public class SearchModeFormatter {
    private final static String LINE_SUGGESTION = "Did you mean: ";
    
    private SummaryUtility summaryUtility;
    
    public SearchModeFormatter() {
        summaryUtility = new SummaryUtility();
    }

    private String getSuggestionLine(String[] suggestions) {
        assert suggestions != null;
        StringBuilder builder = new StringBuilder(LINE_SUGGESTION);
        builder.append(String.join(",", suggestions));
        builder.append("?");
        return builder.toString();
    }
    
    public String format(SearchModeInfo modeInfo) {
        StringBuilder result = new StringBuilder();
        if (modeInfo.getTasks().length != 0 && modeInfo.getSuggestions() != null) {
            result.append(getSuggestionLine(modeInfo.getSuggestions()));
            result.append(System.lineSeparator());
        }
        result.append(summaryUtility.format(modeInfo.getTasks(), 
                modeInfo.getTaskIds()));
        
        return result.toString();
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\SearchModeFormatter.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\utility\DetailsUtility.java
	 */

 */
public class DetailsUtility {
    private final static String FORMAT_ID = "Task [%1$s]";
    private final static String FORMAT_NAME = "Name: %1$s";
    private final static String FORMAT_TIME = "Time: %1$s";
    private final static String DATETIME_FORMAT_TIME = "HH:mm (a)";
    private final static String FORMAT_DATE = "Date: %1$s";
    private final static String DATETIME_FORMAT_DATE = "EEEE, d MMM Y";
    private final static String FORMAT_TAGS = "Tags: %1$s";
    private final static String FORMAT_PRIORITY = "Priority: %1$s";
    private final static String FORMAT_DESCRIPTION = "Description: %1$s";
    private final static String FORMAT_STATUS = "Status: %1$s";

    private final static String ERROR_PRIORITY_NULL = "Priority is null.";
    private final static String ERROR_STATUS_NULL = "Status is null.";

    private String formatTime(LocalTime time) {
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern(DATETIME_FORMAT_TIME);
        String formattedTime = formatter.format(time);
        return String.format(FORMAT_TIME, formattedTime);
    }

    private String formatDate(LocalDate date) {
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern(DATETIME_FORMAT_DATE);
        String formattedDate = formatter.format(date);
        return String.format(FORMAT_DATE, formattedDate);
    }

    private String buildTagsString(Tag[] tags) {
        StringBuilder builder = new StringBuilder("");
        for (int i = 0; i < tags.length; i++) {
            if (i > 0) {
                builder.append(", ");
            }
            builder.append(tags[i].toString());
        }
        return builder.toString();
    }

    private String getPriorityString(Priority priority) {
        assert priority != null : ERROR_PRIORITY_NULL;
        String priorityString = "";
        switch(priority) {
            case HIGH :
                priorityString = "High";
                break;
            case MEDIUM :
                priorityString = "Medium";
                break;
            case LOW :
                priorityString = "Low";
                break;
            case NONE :
                priorityString = "None";
        }
        return priorityString;
    }

    private String getStatusString(Status status) {
        assert status != null : ERROR_STATUS_NULL;

        String statusString = "";
        switch (status) {
            case DONE :
                statusString = "Done";
                break;
            case UNDONE :
                statusString = "Not done";
                break;
        }
        return statusString;
    }

    private String addIndentation(String s, int numberOfSpaces) {
        StringBuilder builder = new StringBuilder();
        for (int i = 0; i < numberOfSpaces; i++) {
            builder.append(" ");
        }
        builder.append(s);
        return builder.toString();
    }

    /**
     * Format a pair of TaskInfo and TaskId to an ArrayList of String, where
     * each entry of the ArrayList corresponds to a line of output.
     * @param task The TaskInfo to be formatted.
     * @param taskId The TaskId to be formatted.
     * @return The formatted task details.
     */
    public ArrayList<String> formatToArray(TaskInfo task, TaskId taskId) {
        ArrayList<String> result = new ArrayList<String>();

        result.add(String.format(FORMAT_ID, taskId.toString()));

        String nameLine = String.format(FORMAT_NAME,  task.name);
        result.add(addIndentation(nameLine, 3));

        if (task.endTime != null) {
            String timeLine = formatTime(task.endTime);
            result.add(addIndentation(timeLine, 3));
        }

        if (task.endDate != null) {
            String dateLine = formatDate(task.endDate);
            result.add(addIndentation(dateLine, 3));
        }

        if (task.tags != null) {
            String tagsLine = String.format(FORMAT_TAGS,
                    buildTagsString(task.tags));
            result.add(addIndentation(tagsLine, 3));
        }

        String priorityLine = String.format(FORMAT_PRIORITY,
                getPriorityString(task.priority));
        result.add(addIndentation(priorityLine, 3));

        String statusLine = String.format(FORMAT_STATUS, getStatusString(task.status));
        result.add(addIndentation(statusLine, 3));

        if (task.details != null) {
            String descriptionLine = String.format(FORMAT_DESCRIPTION,
                    task.details);
            result.add(addIndentation(descriptionLine, 3));
        }

        return result;
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\formatting\utility\DetailsUtility.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\EmptyModeInfo.java
	 */

 *
 */
public class EmptyModeInfo implements ModeInfo {

	/**
	 * Get the Type of the ModeInfo, which is Type.EMPTY_MODE.
	 */
    public Type getType() {
        return Type.EMPTY_MODE;
    }

}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\EmptyModeInfo.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\ModeInfo.java
	 */

 *
 */
public interface ModeInfo {
    public enum Type {
        EMPTY_MODE,
        SEARCH_MODE,
        WAITING_MODE,
        EDIT_MODE
    }
    
    /**
     * Get the Type of the ModeInfo.
     * @return
     */
    public Type getType();
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\ModeInfo.java





	/**
	 * origin: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\SearchModeInfo.java
	 */

 */
public class SearchModeInfo implements ModeInfo {

    private String[] suggestions;
    private TaskInfo[] tasks;
    private TaskId[] taskIds;
    private boolean inWaitingMode;
    
    /**
     * Constructor for SearchModeInfo.
     * @param tasks The TaskInfo of the search results.
     * @param taskIds The TaskId of the search results.
     * @param suggestions The suggestions of the search.
     */
    public SearchModeInfo(TaskInfo[] tasks, TaskId[] taskIds, 
            String[] suggestions) {
        this.tasks = tasks;
        this.taskIds = taskIds;
        this.suggestions = suggestions;
    }
    
    /**
     * Get the type of this ModeInfo, which is Type.SEARCH_MODE.
     */
    public Type getType() {
        if (inWaitingMode) {
            return Type.WAITING_MODE;
        } else {
            return Type.SEARCH_MODE;
        }
    }
    
    /**
     * Return the search results as an array of TaskInfo.
     * @return The array of TaskInfo.
     */
    public TaskInfo[] getTasks() {
        return tasks;
    }
    
    /**
     * Return the IDs of the search results as an array of TaskId.
     * @return The array of TaskId.
     */
    public TaskId[] getTaskIds() {
        return taskIds;
    }
    
    public String[] getSuggestions() {
        return suggestions;
    }
    
    public void  makeIntoWaitingModeInfo() {
        inWaitingMode = true;
    }
}

	// End of segment: C:\Users\bruce\desktop\main\TaskManagerProject\src\main\modeinfo\SearchModeInfo.java





