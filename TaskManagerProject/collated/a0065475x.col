//@author: a0065475x



	/**
	 * origin: src\data\ITaskData.java
	 */

/**
 * Facade for TaskData - used by the managers for read/write operations to
 * TaskData. (e.g. SearchManager)
 */
public interface ITaskData {

    public static final int NO_TASK = -1;

    public abstract TaskId getFirst();

    public abstract TaskId getLast();

    public abstract int getSize();

    public abstract TaskId getNext(TaskId taskId);

    public abstract TaskId getPrevious(TaskId taskId);

    public abstract boolean taskExists(TaskId taskId);

    public abstract String getTaskName(TaskId taskId);

    public abstract boolean setTaskName(TaskId taskId, String name);

    public abstract LocalTime getTaskStartTime(TaskId taskId);

    public abstract boolean setTaskStartTime(TaskId taskId, LocalTime time);

    public abstract LocalDate getTaskStartDate(TaskId taskId);

    public abstract boolean setTaskStartDate(TaskId taskId, LocalDate date);

    public abstract LocalTime getTaskEndTime(TaskId taskId);

    public abstract boolean setTaskEndTime(TaskId taskId, LocalTime time);

    public abstract LocalDate getTaskDate(TaskId taskId);

    public abstract boolean setTaskDate(TaskId taskId, LocalDate date);

    public abstract String getTaskDetails(TaskId taskId);

    public abstract boolean setTaskDetails(TaskId taskId, String details);

    public abstract Priority getTaskPriority(TaskId taskId);

    public abstract boolean setTaskPriority(TaskId taskId, Priority priority);

    public abstract Status getTaskStatus(TaskId taskId);

    public abstract boolean setTaskStatus(TaskId taskId, Status status);

    public abstract Tag[] getTaskTags(TaskId taskId);

    public abstract boolean addTag(TaskId taskId, Tag tag);

    public abstract boolean removeTag(TaskId taskId, Tag tag);

    public abstract boolean clearTags(TaskId taskId);

    public abstract TaskInfo getTaskInfo(TaskId taskId);

    public abstract boolean setTaskInfo(TaskId taskId, TaskInfo taskInfo);

    /**
     * @param taskInfo information about a task.
     * @return the generated taskId of the task.
     * Returns null if unable to add new task.
     */
    public abstract TaskId add(TaskInfo taskInfo);

    /**
     * @param taskId id of the task you wish to remove.
     * @return true iff the deletion is successful.
     * Deletion can be unsuccessful if task does not exist.
     */
    public abstract boolean remove(TaskId taskId);

    /**
     * Use to reverse all the changes in the last undo snapshot.
     */
    public abstract void reverseLastChange();

}
	// End of segment: src\data\ITaskData.java





	/**
	 * origin: src\data\ITaskDataFileInputOutput.java
	 */

/**
 * Facade for TaskData - used by FileInputOutput to synchronise TaskData with
 * an external file.
 */
public interface ITaskDataFileInputOutput {

    public abstract TaskId getFirst();

    public abstract TaskId getLast();

    public abstract int getSize();

    public abstract TaskId getNext(TaskId taskId);

    public abstract TaskId getPrevious(TaskId taskId);

    public abstract TaskInfo getTaskInfo(TaskId taskId);

    /**
     * Resets entire task list with a new list of tasks.
     * @param tasks List of tasks as retrieved from file.
     */
    public abstract void updateTaskList(TaskInfo[] tasks);

    /**
     * Call this whenever a save is successful so that TaskData knows it no
     * longer has any unsaved changes.
     */
    public abstract void saveSuccessful();

    public abstract boolean hasUnsavedChanges();

}
	// End of segment: src\data\ITaskDataFileInputOutput.java





	/**
	 * origin: src\data\ITaskDataUndo.java
	 */

/**
 * Facade for TaskData - used by the undoManager to retrieve undo snapshots.
 */
public interface ITaskDataUndo {

    public static final int NO_TASK = -1;

    /**
     * Purpose is for the undo function to replace tasks to their original Id.
     * Throws an exception if this is not possible.
     * @param taskInfo
     * @param taskId
     */
    public abstract void addTaskWithSpecificId(TaskInfo taskInfo, TaskId taskId);

    /**
     * @param taskId id of the task you wish to remove.
     * @return true iff the deletion is successful.
     * Deletion can be unsuccessful if task does not exist.
     */
    public abstract boolean remove(TaskId taskId);

    /**
     * Retrieves the undo snapshot holding the previous state of all tasks
     * that were changed in the last action.<br>
     * The undo snapshot is cleared (deleted) when this method is called.
     * @return an UndoSnapshot holding the previous state of TaskData.
     */
    public abstract UndoSnapshot retrieveUndoSnapshot();

    /**
     * Used after an undo so that you don't undo an undo. :D
     */
    public abstract void discardUndoSnapshot();


}
	// End of segment: src\data\ITaskDataUndo.java





	/**
	 * origin: src\data\Task.java
	 */

/**
 * The Task object that is stored in the TaskData class. Not available outside
 * of TaskData.<br>
 * In contrast, a TaskInfo object is available outside of TaskData.
 */
public class Task {
    private static final int NOT_FOUND = -1;
    private TaskInfo taskInfo;
    private int id;
    
    public Task (TaskInfo taskInfo) {
        this.taskInfo = new TaskInfo(taskInfo);
        assert taskInfo.isValid() : "Invalid taskInfo detected in TaskData!";
        initialiseFields();
    }

    public TaskInfo getTaskInfo() {
        assert taskInfo.isValid() : "Invalid taskInfo detected in TaskData!";
        return new TaskInfo(taskInfo);
    }
    
    public int getId() {
        return id;
    }
    
    public void setId(int id) {
        this.id = id;
    }
    
    public String getName() {
        return taskInfo.name;
    }
    
    public boolean setName(String name) {
        String original = taskInfo.name;
        
        taskInfo.name = name;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.name = original;
            return false;
        }
    }
    
    public LocalTime getStartTime() {
        return taskInfo.endTime;
    }
    
    public boolean setStartTime(LocalTime startTime) {
        LocalTime original = taskInfo.startTime;
        
        taskInfo.startTime = startTime;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.startTime = original;
            return false;
        }
    }
    
    public LocalDate getStartDate() {
        return taskInfo.endDate;
    }
    
    public boolean setStartDate(LocalDate startDate) {
        LocalDate original = taskInfo.startDate;
        
        taskInfo.startDate = startDate;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.startDate = original;
            return false;
        }
    }
    
    public LocalTime getEndTime() {
        return taskInfo.endTime;
    }
    
    public boolean setEndTime(LocalTime endTime) {
        LocalTime original = taskInfo.endTime;
        
        taskInfo.endTime = endTime;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.endTime = original;
            return false;
        }
    }
    
    public LocalDate getEndDate() {
        return taskInfo.endDate;
    }
    
    public boolean setEndDate(LocalDate endDate) {
        LocalDate original = taskInfo.endDate;
        
        taskInfo.endDate = endDate;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.endDate = original;
            return false;
        }
    }
    
    public String getDetails() {
        return taskInfo.details;
    }
    
    public boolean setDetails(String details) {
        String original = taskInfo.details;
        
        taskInfo.details = details;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.details = original;
            return false;
        }
    }
    
    public Tag[] getTags() {
        return Arrays.copyOf(taskInfo.tags, taskInfo.tags.length);
    }

    public boolean addTag(Tag tag) {
        
        if (findIndexOfTag(tag) == NOT_FOUND) {
            Tag[] tags = Arrays.copyOf(taskInfo.tags, taskInfo.tags.length+1);
            tags[tags.length-1] = tag;
            taskInfo.tags = tags;
            
            return true;
        } else {
            return false;
        }
    }
    
    public boolean removeTag(Tag tag) {
        
        int result = findIndexOfTag(tag);
        if (result == NOT_FOUND)
            return false;
        
        Tag[] tags = copyTagsIntoNewArray(result);
        taskInfo.tags = tags;
        
        return true;
    }
    
    public void clearTags() {
        taskInfo.tags = new Tag[0];
    }
    
    public Priority getPriority() {
        return taskInfo.priority;
    }
    
    public boolean setPriority(Priority priority) {
        Priority original = taskInfo.priority;
        
        taskInfo.priority = priority;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.priority = original;
            return false;
        }
    }
    
    public Status getStatus() {
        return taskInfo.status;
    }
    
    public boolean setStatus(Status status) {
        Status original = taskInfo.status;
        
        taskInfo.status = status;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.status = original;
            return false;
        }
    }
    
    public int getNumberOfTimes() {
        return taskInfo.numberOfTimes;
    }
    
    public boolean setNumberOfTimes(int numberOfTimes) {
        int original = taskInfo.numberOfTimes;
        
        taskInfo.numberOfTimes = numberOfTimes;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.numberOfTimes = original;
            return false;
        }
    }
    
    public Duration getRepeatIntervalDays() {
        return taskInfo.repeatInterval;
    }
    
    public boolean setRepeatIntervalDays(Duration repeatInterval) {
        Duration original = taskInfo.repeatInterval;
        
        taskInfo.repeatInterval = repeatInterval;
        if (taskInfo.isValid()) {
            return true;
        } else {
            taskInfo.repeatInterval = original;
            return false;
        }
    }
    
    public boolean setAllInfo(TaskInfo taskInfo) {
        if (taskInfo.isValid()) {
            this.taskInfo = new TaskInfo(taskInfo);
            return true;
        } else {
            return false;
        }
    }

    private void initialiseFields() {
        if (taskInfo.priority == null) {
            taskInfo.priority = Priority.defaultPriority();
        }
        if (taskInfo.status == null) {
            taskInfo.status = Status.defaultStatus();
        }
        if (taskInfo.tags == null) {
            taskInfo.tags = new Tag[0];
        }
    }
    
    private int findIndexOfTag(Tag tag) {
        for (int i = 0 ; i < taskInfo.tags.length; i++) {
            if (tag.equals(taskInfo.tags[i])) {
                return i;
            }
        }
        return NOT_FOUND;
    }

    private Tag[] copyTagsIntoNewArray(int result) {
        Tag[] tags = new Tag[taskInfo.tags.length-1];
        int index = 0;
        for (int i = 0; i < tags.length; i++) {
            if (index == result)
                index++;
            tags[i] = taskInfo.tags[index];
            index++;
        }
        return tags;
    }
    
}

	// End of segment: src\data\Task.java





	/**
	 * origin: src\data\TaskData.java
	 */

/**
 * Program memory for the tasks in the program.<br>
 * It is the job of TaskData to ensure that the absolute index of each task<br>
 * remains the same even after deletion / addition of tasks.
 */
public class TaskData implements ITaskData, ITaskDataFileInputOutput, ITaskDataUndo {
    private static final String ERROR_NULL_TASKID = "Tried to query/edit TaskData with null task Id.";
    private static final String ERROR_NULL_TASKINFO = "Tried to edit TaskData with null taskInfo.";
    private static final String ERROR_NULL_TASK_ARRAY = "Tried to update TaskData with null task array.";
    
    public static final int NO_TASK = -1;
    private static final Task EMPTY_SLOT = null;
    
    private ArrayList<Task> taskList;
    private ArrayList<Integer> nextTaskList;
    private ArrayList<Integer> previousTaskList;
    private LinkedList<Integer> freeSlotList;
    
    private UndoSnapshot undoSnapshot;
    
    private int firstTask;
    private int lastTask;
    
    private int size = 0;
    
    private boolean hasUnsavedChanges;
    
    public TaskData() {
        initializeTaskData();
    }

    public TaskId getFirst() {
        return new TaskId(firstTask);
    }
    
    public TaskId getLast() {
        return new TaskId(lastTask);
    }
    
    public int getSize() {
        return size;
    }

    public TaskId getNext(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        return new TaskId(next(taskId.id));
    }
    
    public TaskId getPrevious(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        return new TaskId(previous(taskId.id));
    }
    
    public boolean taskExists(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        return getTask(taskId) != EMPTY_SLOT;
    }

    public String getTaskName(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getName();
        }
    }

    public boolean setTaskName(TaskId taskId, String name) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setName(name);
        }
    }
    
    public LocalTime getTaskStartTime(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getStartTime();
        }
    }
    
    public boolean setTaskStartTime(TaskId taskId, LocalTime time) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setStartTime(time);
        }
    }
    
    public LocalDate getTaskStartDate(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getStartDate();
        }
    }

    public boolean setTaskStartDate(TaskId taskId, LocalDate date) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setStartDate(date);
        }
    }
    
    public LocalTime getTaskEndTime(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getEndTime();
        }
    }
    
    public boolean setTaskEndTime(TaskId taskId, LocalTime time) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setEndTime(time);
        }
    }
    
    public LocalDate getTaskDate(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getEndDate();
        }
    }

    public boolean setTaskDate(TaskId taskId, LocalDate date) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setEndDate(date);
        }
    }
    
    public String getTaskDetails(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getDetails();
        }
    }

    public boolean setTaskDetails(TaskId taskId, String details) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setDetails(details);
        }
    }
    
    public Priority getTaskPriority(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getPriority();
        }
    }


    public boolean setTaskPriority(TaskId taskId, Priority priority) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setPriority(priority);
        }
    }
    
    public Status getTaskStatus(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getStatus();
        }
    }

    public boolean setTaskStatus(TaskId taskId, Status status) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setStatus(status);
        }
    }

    public Tag[] getTaskTags(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getTags();
        }
    }
    
    public boolean addTag(TaskId taskId, Tag tag) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.addTag(tag);
        }
    }
    
    public boolean removeTag(TaskId taskId, Tag tag) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.removeTag(tag);
        }
    }
    
    public boolean clearTags(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            task.clearTags();
            return true;
        }
    }

    public TaskInfo getTaskInfo(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return null;
        } else {
            return task.getTaskInfo();
        }
    }
    
    public boolean setTaskInfo(TaskId taskId, TaskInfo taskInfo) {
        assert taskId != null : ERROR_NULL_TASKID;
        assert taskInfo != null : ERROR_NULL_TASKINFO;
        
        addToSnapshot(taskId);
        
        Task task = getTask(taskId);
        if (task == EMPTY_SLOT) {
            return false;
        } else {
            return task.setAllInfo(taskInfo);
        }
    }

    /**
     * Resets entire task list with a new list of tasks.
     * @param tasks List of tasks as retrieved from file.
     */
    public void updateTaskList(TaskInfo[] tasks) {
        assert tasks != null : ERROR_NULL_TASK_ARRAY;
        
        initializeTaskData();
        for (TaskInfo taskInfo : tasks) {
            if (taskInfo.isValid()) {
                add(taskInfo);
                discardUndoSnapshot(); // calling this here actually reduces lag.
            }
        }
        discardUndoSnapshot();
    }
    
    /**
     * Purpose is for the undo function to replace tasks to their original Id.
     * Throws an exception if this is not possible.
     * @param taskInfo
     * @param taskId
     */
    public void addTaskWithSpecificId(TaskInfo taskInfo, TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        assert taskInfo != null : ERROR_NULL_TASKINFO;
        
        if (getTask(taskId) != EMPTY_SLOT) {
            throw new IllegalArgumentException("Unable to add task with id = " + taskId);
        }

        int insertIndex = taskId.id;

        if (!freeSlotList.remove(new Integer(insertIndex))) {
            throw new IllegalArgumentException("Unable to remove id from free slot list.");
        }

        Task task = new Task(taskInfo);
        insertTask(task, insertIndex);
        task.setId(insertIndex);
    }

    /**
     * @param taskInfo information about a task.
     * @return the generated taskId of the task.
     * Returns null if unable to add new task.
     */
    public TaskId add(TaskInfo taskInfo) {
        assert taskInfo != null : ERROR_NULL_TASKINFO;
        
        Task task = new Task(taskInfo);
        int id = insertTask(task);
        
        if (id != NO_TASK) {
            task.setId(id);
            return new TaskId(id);
        }
        else {
            return null;
        }
    }
    
    /**
     * @param taskId id of the task you wish to remove.
     * @return true iff the deletion is successful.
     * Deletion can be unsuccessful if task does not exist.
     */
    public boolean remove(TaskId taskId) {
        assert taskId != null : ERROR_NULL_TASKID;
        return deleteTask(taskId.id);
    }

    
    /**
     * Retrieves the undo snapshot holding the previous state of all tasks
     * that were changed in the last action.<br>
     * The undo snapshot is cleared (deleted) when this method is called.
     * @return an UndoSnapshot holding the previous state of TaskData.
     */
    public UndoSnapshot retrieveUndoSnapshot() {
        UndoSnapshot temp = undoSnapshot;
        discardUndoSnapshot();
        return temp;
    }
    
    /**
     * Used after an undo so that you don't undo an undo. :D
     */
    public void discardUndoSnapshot() {
        undoSnapshot = new UndoSnapshot(this);
    }
    
    /**
     * Use to reverse all the changes in the last undo snapshot.
     */
    public void reverseLastChange() {
        UndoSnapshot lastSnapshot = retrieveUndoSnapshot();
        lastSnapshot.applySnapshotChange();
        discardUndoSnapshot();
    }
    
    
    /**
     * Call this whenever a save is successful so that TaskData knows it no
     * longer has any unsaved changes.
     */
    public void saveSuccessful() {
        hasUnsavedChanges = false;
    }
    
    public boolean hasUnsavedChanges() {
        return hasUnsavedChanges;
    }
    
    private void initializeTaskData() {
        taskList = new ArrayList<>();
        freeSlotList = new LinkedList<>();
        nextTaskList = new ArrayList<>();
        previousTaskList = new ArrayList<>();
        
        firstTask = NO_TASK;
        lastTask = NO_TASK;
        
        undoSnapshot = new UndoSnapshot(this);
        size = 0;
        hasUnsavedChanges = false;
    }
        
    private int maxTasks() {
        return TaskId.MAX_ID;
    }
    
    /**
     * To save a snapshot of the task before a change is made.<br>
     * If a snapshot has already been saved, does nothing.<br>
     * Remember to call this BEFORE a task is modified!
     * @param taskId the id of the task you want to add to snapshot.
     */
    private void addToSnapshot(TaskId taskId) {
        hasUnsavedChanges = true;
        
        Task task = getTask(taskId);
        TaskInfo taskInfo = UndoTaskSnapshot.NO_TASK;
        if (task != null) {
            taskInfo = task.getTaskInfo();
        }
        
        undoSnapshot.addTaskSnapshot(taskInfo, taskId);
    }
    
    /**
     * how do I reference the javadoc of addToSnapshot(TaskId taskId)?
     * @param index the id of the task you want to add to snapshot.
     */
    private void addToSnapshot(int index) {
        addToSnapshot(new TaskId(index));
    }

    private Task getTask(TaskId taskId) {
        if (taskId.id < taskList.size()) {
            return taskList.get(taskId.id);
        }
        return EMPTY_SLOT;
    }
    
    private int insertTask(Task task) {
        
        if (taskList.size() < maxTasks()) {
            taskList.add(EMPTY_SLOT);
            nextTaskList.add(NO_TASK);
            previousTaskList.add(NO_TASK);
            
            int newIndex = taskList.size()-1;
            insertTask(task, newIndex);
            return newIndex;
            
        } else {
            
            if (freeSlotList.isEmpty()) {
                // No more slots to insert tasks. Task list full.
                return NO_TASK;
            }
            
            int newIndex = freeSlotList.removeFirst();
            insertTask(task, newIndex);
            return newIndex;
        }
    }

    private void insertTask(Task task, int newIndex) {
        if (taskList.get(newIndex) != EMPTY_SLOT) {
            throw new IllegalArgumentException("insertTask can only insert to empty slots!");
        }
        
        addToSnapshot(newIndex);
        taskList.set(newIndex, task);
        
        setNext(newIndex, NO_TASK);
        setPrevious(newIndex, lastTask);
        if (lastTask != NO_TASK)
            setNext(lastTask, newIndex);

        if (firstTask == NO_TASK) {
            firstTask = newIndex;
        }
        
        lastTask = newIndex;
        
        size++;
    }
    
    private boolean deleteTask(int index) {
        // Note: Uses lazy deletion to maintain index.
        
        if (taskList.size() <= index)
            return false;
        if (taskList.get(index) == EMPTY_SLOT)
            return false;

        addToSnapshot(index);
        
        if (index == firstTask) {
            firstTask = next(firstTask);
        }
        if (index == lastTask) {
            lastTask = previous(lastTask);
        }
        
        taskList.set(index, null);
        freeSlotList.addLast(index);
        if (previous(index) != NO_TASK) {
            setNext(previous(index), next(index));
        }
        if (next(index) != NO_TASK) {
            setPrevious(next(index), previous(index));
        }
        
        size--;
        return true;
    }
    
    private void setNext(int index, int next) {
        nextTaskList.set(index, next);
    }
    
    private void setPrevious(int index, int previous) {
        previousTaskList.set(index, previous);
    }

    private int next(int index) {
        return nextTaskList.get(index);
    }
    
    private int previous(int index) {
        return previousTaskList.get(index);
    }
    
    
}

	// End of segment: src\data\TaskData.java





	/**
	 * origin: src\data\TaskId.java
	 */

/**
 * Absolute ID of a task.<br>
 * Immutable
 */
public final class TaskId implements Comparable<TaskId> {
    
    private static final char CHAR_Z = 'Z';
    private static final char CHAR_NINE = '9';
    private static final char CHAR_ZERO = '0';
    private static final char CHAR_A = 'A';
    
    private static final int STRINGID_LENGTH = 3;
    
    /**
     * TRANSLATE_PRIME must be coprime to MAX_ID.<br>
     * We can ensure this by simply meeting the below two conditions:<br>
     * 1) TRANSLATE_PRIME > MAX_ID,<br>
     * 2) TRANSLATE_PRIME is prime.<br>
     */
    private static final int TRANSLATE_PRIME = 363767;
    /**
     * TRANSLATE_REVERSE_PRIME should be computed using the Euclidean Algorithm.
     */
    private static final int TRANSLATE_REVERSE_PRIME = 16823;
    private static final int TRANSLATE_SHIFT = new Random().nextInt();
    public static final int MAX_ID = 20280;
    
    public final int id;

    public TaskId(int id) {
        this.id = id;
    }
    
    /**
     * Constructor for a taskId.
     * @param stringId the string form of the taskId. (e.g. a6d)<br>
     * Can be in capital letters.
     * @return a TaskId object corresponding the stringId provided.<br>
     * returns null if the string is an invalid task Id.
     */
    public static TaskId makeTaskId(String stringId) {
        stringId = stringId.toUpperCase();
        
        try {
            int index = toIntId(stringId);
            return new TaskId(index);
            
        } catch (IllegalArgumentException e) {
            return null;
        }
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + id;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        TaskId other = (TaskId) obj;
        if (id != other.id)
            return false;
        return true;
    }

    @Override
    public int compareTo(TaskId o) {
        return id - o.id;
    }
    
    @Override
    public String toString() {
        if (isValid()) {
            return toStringId(id);
        }
        return "NO_TASK";
    }
    
    public boolean isValid() {
        return (id != ITaskData.NO_TASK);
    }
    
    /**
     * Converts a numeric task ID to a string task ID
     * @param indexId numeric task ID
     * @return string task ID
     */
    public static String toStringId(int indexId) {
        if (indexId >= MAX_ID)
            throw new IllegalArgumentException("index ID exceeds range");
        
        int translatedIndex = numberTranslateForward(indexId);
        
        int numberPosition = translatedIndex % 3;
        translatedIndex /= 3;
        int number = translatedIndex % 10;
        translatedIndex /= 10;
        char character1 = (char)(translatedIndex % 26 + CHAR_A);
        translatedIndex /= 26;
        char character2 = (char)(translatedIndex + CHAR_A);
        
        String result = toStringId(numberPosition, number, character1, character2);
        
        return result;
    }
    
    /**
     * Converts a string task ID to a numeric task ID
     * @param stringId string task ID
     * @return numeric task ID
     */
    public static int toIntId(String stringId) {
        int numberPosition;
        int number;
        char character1;
        char character2;

        if (stringId.length() != STRINGID_LENGTH) {
            throw new IllegalArgumentException("Invalid string input: " + stringId);
        }

        if (isDigit(stringId.charAt(0))) {
            
            number = (int)(stringId.charAt(0) - CHAR_ZERO);
            character1 = stringId.charAt(1);
            character2 = stringId.charAt(2);
            numberPosition = 0;
            
        } else if (isDigit(stringId.charAt(1))) {
            
            number = (int)(stringId.charAt(1) - CHAR_ZERO);
            character1 = stringId.charAt(0);
            character2 = stringId.charAt(2);
            numberPosition = 1;
            
        } else if (isDigit(stringId.charAt(2))) {
            
            number = (int)(stringId.charAt(2) - CHAR_ZERO);
            character1 = stringId.charAt(0);
            character2 = stringId.charAt(1);
            numberPosition = 2;
            
        } else {
            throw new IllegalArgumentException("Invalid string input: " + stringId);
        }
        
        if (isInvalid(character1, character2)) {
            throw new IllegalArgumentException("Invalid string input: " + stringId);
        }
        
        int result = toIntId(numberPosition, number, character1, character2);
        
        result = numberTranslateInverse(result);
        
        return result;
    }


    private static String toStringId(int numberPosition, int number,
            char character1, char character2) {
        
        String result = "";
        if (numberPosition == 0) {
            result = "" + number + character1 + character2;
            
        } else if (numberPosition == 1) {
            result = "" + character1 + number + character2;
            
        } else if (numberPosition == 2) {
            result = "" + character1 + character2 + number;
            
        }
        return result;
    }


    private static int toIntId(int numberPosition, int number, char character1,
            char character2) {

        int result = (int)(character2 - CHAR_A);
        result *= 26;
        result += (int)(character1 - CHAR_A);
        result *= 10;
        result += number;
        result *= 3;
        result += numberPosition;
        return result;
    }
    
    private static boolean isInvalid(char character1, char character2) {
        return !(isLowerCaseAlphabet(character1) && isLowerCaseAlphabet(character2));
    }
    
    private static boolean isDigit(char c) {
        return (c >= CHAR_ZERO && c <= CHAR_NINE);
    }
    
    private static boolean isLowerCaseAlphabet(char c) {
        return (c >= CHAR_A && c <= CHAR_Z);
    }
    
    private static int numberTranslateForward(int index) {
        long longIndex = index;
        longIndex += TRANSLATE_SHIFT;
        longIndex *= TRANSLATE_PRIME;
        longIndex += TRANSLATE_SHIFT;
       
        longIndex %= MAX_ID;
        if (longIndex < 0) {
            longIndex += MAX_ID;
        }
        return (int)longIndex;
    }

    private static int numberTranslateInverse(int index) {
        long longIndex = index;
        longIndex -= TRANSLATE_SHIFT;
        longIndex *= TRANSLATE_REVERSE_PRIME;
        longIndex -= TRANSLATE_SHIFT;
        
        longIndex %= MAX_ID;
        if (longIndex < 0) {
            longIndex += MAX_ID;
        }
        return (int)longIndex;
    }
    
    
}

	// End of segment: src\data\TaskId.java





	/**
	 * origin: src\data\taskinfo\Priority.java
	 */

public enum Priority {
    HIGH,
    MEDIUM,
    LOW,
    NONE;
    
    public static Priority defaultPriority() {
        return NONE;
    }
}

	// End of segment: src\data\taskinfo\Priority.java





	/**
	 * origin: src\data\taskinfo\Status.java
	 */

public enum Status {
    UNDONE,
    DONE;
    
    public static Status defaultStatus() {
        return UNDONE;
    }
}

	// End of segment: src\data\taskinfo\Status.java





	/**
	 * origin: src\data\taskinfo\Tag.java
	 */

/**
 * Immutable class. Stores tag as a string.
 */
public final class Tag {

    public final String tag;
    
    public Tag(String tag) {
        this.tag = tag;
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((tag == null) ? 0 : tag.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Tag other = (Tag) obj;
        if (tag == null) {
            if (other.tag != null)
                return false;
        } else if (!tag.equals(other.tag))
            return false;
        return true;
    }

    @Override
    public String toString() {
        return tag;
    }
}

	// End of segment: src\data\taskinfo\Tag.java





	/**
	 * origin: src\data\taskinfo\TaskInfo.java
	 */

/**
 * Carries all the information used by a task.<br>
 * It acts simply as a struct. All of its attributes are public.
 */
public class TaskInfo {

    public String name;
    public LocalTime startTime;
    public LocalDate startDate;
    public LocalTime endTime;
    public LocalDate endDate;

    public String details;
    public Tag[] tags;
    public Priority priority;
    public Status status;
    /**
     * @deprecated
     */
    public int numberOfTimes;
    /**
     * @deprecated
     */
    public Duration repeatInterval;
    

    public static final int REPEAT_INDEFINITELY = -1;

    private TaskInfo() {
    }
    
    /**
     * Default constructor for TaskInfo.<br>
     * Always use this when creating a new task.<br>
     * Initialises priority and status to their default valies.<br>
     * They shouldn't be initialised as null.
     * @return A new template taskInfo.
     */
    public static TaskInfo create() {
        TaskInfo taskInfo = new TaskInfo();
        taskInfo.priority = Priority.defaultPriority();
        taskInfo.status = Status.defaultStatus();
        taskInfo.tags = new Tag[0];
        return taskInfo;
    }
    
    /**
     * USE THIS SPARINGLY<br>
     * This creates a taskInfo object without initialising the priority and
     * status. Avoid using this unless you really need them to be null.
     * Use TaskInfo.create() instead.<br>
     * If you can't decide which one to use, use TaskInfo.create().
     * @return An empty taskInfo with priority and status set to null.
     */
    public static TaskInfo createEmpty() {
        TaskInfo taskInfo = new TaskInfo();
        return taskInfo;
    }

    /**
     * Copy constructor
     * @param taskInfo taskInfo to copy.
     */
    public TaskInfo(TaskInfo taskInfo) {
        this.name = taskInfo.name;
        this.startTime = taskInfo.startTime;
        this.startDate = taskInfo.startDate;
        this.endTime = taskInfo.endTime;
        this.endDate = taskInfo.endDate;
        this.details = taskInfo.details;

        if (taskInfo.tags != null) {
            this.tags = Arrays.copyOf(taskInfo.tags, taskInfo.tags.length);
        }

        this.priority = taskInfo.priority;
        this.status = taskInfo.status;
        this.numberOfTimes = taskInfo.numberOfTimes;
        this.repeatInterval = taskInfo.repeatInterval;
    }
    

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((details == null) ? 0 : details.hashCode());
        result = prime * result + ((endDate == null) ? 0 : endDate.hashCode());
        result = prime * result + ((endTime == null) ? 0 : endTime.hashCode());
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        result = prime * result + numberOfTimes;
        result = prime * result
                + ((priority == null) ? 0 : priority.hashCode());
        result = prime * result
                + ((repeatInterval == null) ? 0 : repeatInterval.hashCode());
        result = prime * result
                + ((startDate == null) ? 0 : startDate.hashCode());
        result = prime * result
                + ((startTime == null) ? 0 : startTime.hashCode());
        result = prime * result + ((status == null) ? 0 : status.hashCode());
        result = prime * result + Arrays.hashCode(tags);
        return result;
    }

    public LocalDate getStartDate(){
    	return startDate;
    }
    
    public LocalTime getStartTime(){
    	return startTime;
    }
    
    public LocalDate getEndDate(){
    	return endDate;
    }
    
    public LocalTime getEndTime(){
    	return endTime;
    }
    
    public boolean isEmpty() {
        TaskInfo emptyTemplate = TaskInfo.createEmpty();
        return (this.equals(emptyTemplate));
    }
    
    public boolean isValid() {
        if (!validDateTime()) {
            return false;
        }
        
        if (name == null || name.trim().isEmpty()) {
            return false;
        }
        
        if (bothStartAndEndExist()) {
            LocalDateTime start = LocalDateTime.of(startDate, startTime);
            LocalDateTime end = LocalDateTime.of(endDate, endTime);
    
            return (start.isBefore(end));
        } else {
            return true;
        }
    }
    
    
    /**
     * Requirements:<br>
     * Keyword: D/T fields = date/time fields.<br>
     * If startTime or startDate exists, then all four D/T fields cannot be null.<br>
     * if endTime exists, then endDate cannot be null.<br>
     * If they exist, startTime cannot be equal to endTime,<br>
     * and startDate cannot be equal to endDate.
     */
    public void assertValidDateTime() {
        assert validDateTime() : "Invalid Date/Time combination!";
    }

    public void assertIsValid() {
        assert isValid() : "Invalid task detected!";
    }

    @Override
    public boolean equals(Object obj) {
        
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        TaskInfo other = (TaskInfo) obj;
        
        return (namesEqual(other) &&
                detailsEqual(other) &&
                startDatesEqual(other) &&
                startTimesEqual(other) &&
                endDatesEqual(other) &&
                endTimesEqual(other) &&
                numberOfTimesEqual(other) &&
                prioritiesEqual(other) &&
                repeatIntervalsEqual(other) &&
                statusesEqual(other) &&
                tagsEqual(other));
    }

    private boolean tagsEqual(TaskInfo other) {
        if (tags != null && other.tags != null) {
            List<Tag> tagsList1 = Arrays.asList(tags);
            List<Tag> tagsList2 = Arrays.asList(other.tags);
    
            if (!tagsList1.containsAll(tagsList2)) {
                return false;
            }
            if (!tagsList2.containsAll(tagsList1)) {
                return false;
            }
            
        } else if (tags != null || other.tags != null) {
            return false;
        }
        return true;
    }

    private boolean bothStartAndEndExist() {
        return (startTime != null &&
                startDate != null &&
                endTime != null &&
                endDate != null);
    }
    
    private boolean validDateTime() {
        if (startTime == null) {
            if (startDate != null) {
                return false;
            }
        } else {
            if (startDate == null) {
                return false;
            } else {
                if (endTime == null) {
                    return false;
                }
            }
        }
        
        if (endTime != null) {
            if (endDate == null) {
                return false;
            }
        }
        
        if (startTime != null) {
            if (startTime.equals(endTime) && startDate.equals(endDate)) {
                return false;
            }
        }
        
        return true;
    }
    

    private boolean statusesEqual(TaskInfo other) {
        if (status != other.status) {
            return false;
        }
        return true;
    }

    private boolean repeatIntervalsEqual(TaskInfo other) {
        if (repeatInterval == null) {
            if (other.repeatInterval != null) {
                return false;
            }
        } else if (!repeatInterval.equals(other.repeatInterval)) {
            return false;
        }
        return true;
    }

    private boolean prioritiesEqual(TaskInfo other) {
        if (priority != other.priority) {
            return false;
        }
        return true;
    }

    private boolean numberOfTimesEqual(TaskInfo other) {
        if (numberOfTimes != other.numberOfTimes) {
            return false;
        }
        return true;
    }

    private boolean endTimesEqual(TaskInfo other) {
        if (endTime == null) {
            if (other.endTime != null) {
                return false;
            }
        } else if (!endTime.equals(other.endTime)) {
            return false;
        }
        return true;
    }

    private boolean endDatesEqual(TaskInfo other) {
        if (endDate == null) {
            if (other.endDate != null) {
                return false;
            }
        } else if (!endDate.equals(other.endDate)) {
            return false;
        }
        return true;
    }


    private boolean startTimesEqual(TaskInfo other) {
        if (startTime == null) {
            if (other.startTime != null) {
                return false;
            }
        } else if (!startTime.equals(other.startTime)) {
            return false;
        }
        return true;
    }

    private boolean startDatesEqual(TaskInfo other) {
        if (startDate == null) {
            if (other.startDate != null) {
                return false;
            }
        } else if (!startDate.equals(other.startDate)) {
            return false;
        }
        return true;
    }
    
    private boolean detailsEqual(TaskInfo other) {
        String details1 = details;
        String details2 = other.details;
        if (details1 == null) {
            details1 = "";
        }
        if (details2 == null) {
            details2 = "";
        }
        if (!details1.equals(details2)) {
            return false;
        }
        return true;
    }

    private boolean namesEqual(TaskInfo other) {
        String name1 = name;
        String name2 = other.name;
        if (name1 == null) {
            name1 = "";
        }
        if (name2 == null) {
            name2 = "";
        }
        if (!name1.equals(name2)) {
            return false;
        }
        return true;
    }

 
}

	// End of segment: src\data\taskinfo\TaskInfo.java





	/**
	 * origin: src\data\test\DataTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
   EuclideanAlgorithmTest.class,
   TaskDataTest.class,
   TaskIdTest.class,
   TaskInfoTest.class
})
public class DataTestSuite {
}

	// End of segment: src\data\test\DataTestSuite.java





	/**
	 * origin: src\data\test\EuclideanAlgorithmTest.java
	 */

public class EuclideanAlgorithmTest {

    /**
     * Run this to compute the multiplicative inverse of a number mod m.
     */
    private void computeReversePrime() {
        EuclideanAlgorithm result;
        // Actual computation of reverse prime.
        result = new EuclideanAlgorithm(363767, 20280);
        System.out.println(result.m);
    }

    @Test
    public void test() {
        
        EuclideanAlgorithm result;
        
        result = new EuclideanAlgorithm(13, 11);
        assertEquals(-5, result.m);
        assertEquals(6, result.q);
        assertEquals(1, result.gcd);
        
        result = new EuclideanAlgorithm(65, 40);
        assertEquals(-3, result.m);
        assertEquals(5, result.q);
        assertEquals(5, result.gcd);
        
        result = new EuclideanAlgorithm(40, 65);
        assertEquals(5, result.m);
        assertEquals(-3, result.q);
        assertEquals(5, result.gcd);

        //computeReversePrime();
    }
}

	// End of segment: src\data\test\EuclideanAlgorithmTest.java





	/**
	 * origin: src\data\test\TaskDataTest.java
	 */

public class TaskDataTest {

    @Test
    public void test() {
        TaskInfo dummyTask = TaskInfo.create();
        dummyTask.name = "testname1";
        
        TaskData taskData = new TaskData();
        
        // Original task list should be empty.
        assertEquals(0, taskData.getSize());
        testSizeAndIteration(taskData, 0);
        
        //Note: every test tests the taskData size and iteration together.
        // Testing iteration means looping through the entire next()/previous() structure
        // and checking whether all the task IDs are iterated through correctly.
        
        // Testing adding of tasks
        TaskId id1 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 1);
        assertEquals("testname1", taskData.getTaskName(id1));

        dummyTask.name = "testname2";
        TaskId id2 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 2);
        assertEquals("testname2", taskData.getTaskName(id2));

        dummyTask.name = "testname3";
        TaskId id3 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 3);
        assertEquals("testname3", taskData.getTaskName(id3));

        dummyTask.name = "testname4";
        TaskId id4 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 4);
        assertEquals("testname4", taskData.getTaskName(id4));


        // Testing removing of tasks
        assertEquals(true, taskData.remove(id2));
        testSizeAndIteration(taskData, 3);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals("testname4", taskData.getTaskName(id4));


        dummyTask.name = "testname5";
        TaskId id5 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 4);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals("testname4", taskData.getTaskName(id4));
        assertEquals("testname5", taskData.getTaskName(id5));


        assertEquals(false, taskData.remove(id2));
        testSizeAndIteration(taskData, 4);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals("testname4", taskData.getTaskName(id4));
        assertEquals("testname5", taskData.getTaskName(id5));


        assertEquals(true, taskData.remove(id5));
        testSizeAndIteration(taskData, 3);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals("testname4", taskData.getTaskName(id4));
        assertEquals(null, taskData.getTaskName(id5));


        assertEquals(true, taskData.remove(id4));
        testSizeAndIteration(taskData, 2);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals(null, taskData.getTaskName(id4));
        assertEquals(null, taskData.getTaskName(id5));
        
        
        dummyTask.name = "testname6";
        TaskId id6 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 3);
        assertEquals("testname1", taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals("testname3", taskData.getTaskName(id3));
        assertEquals(null, taskData.getTaskName(id4));
        assertEquals(null, taskData.getTaskName(id5));
        assertEquals("testname6", taskData.getTaskName(id6));
        

        // Testing clearing of tasks (emptying task data)
        assertEquals(true, taskData.remove(id1));
        assertEquals(false, taskData.remove(id2));
        assertEquals(true, taskData.remove(id3));
        assertEquals(false, taskData.remove(id4));
        assertEquals(false, taskData.remove(id5));
        assertEquals(true, taskData.remove(id6));

        assertEquals(false, taskData.remove(id1));
        assertEquals(false, taskData.remove(id6));

        assertEquals(0, taskData.getSize());
        testSizeAndIteration(taskData, 0);
        
        dummyTask.name = "testname7";
        TaskId id7 = taskData.add(dummyTask);
        testSizeAndIteration(taskData, 1);
        assertEquals(null, taskData.getTaskName(id1));
        assertEquals(null, taskData.getTaskName(id2));
        assertEquals(null, taskData.getTaskName(id3));
        assertEquals(null, taskData.getTaskName(id4));
        assertEquals(null, taskData.getTaskName(id5));
        assertEquals(null, taskData.getTaskName(id6));
        assertEquals("testname7", taskData.getTaskName(id7));

        TaskId testId1 = new TaskId(id7.id+1);
        TaskId testId2 = new TaskId(id7.id+2);
        TaskId testId3 = new TaskId(id7.id+3);
        TaskId testId4 = new TaskId(id7.id+4);

        assertEquals(null, taskData.getTaskName(testId1));
        assertEquals(null, taskData.getTaskName(testId2));
        assertEquals(null, taskData.getTaskName(testId3));
        assertEquals(null, taskData.getTaskName(testId4));

        
        // Fill up entire task data list.
        TaskId resultId = testId1;
        while (resultId != null) {
            taskData.discardUndoSnapshot();
            resultId = taskData.add(dummyTask);
        }
        
        testSizeAndIteration(taskData, TaskId.MAX_ID);
        taskData.remove(testId1);
        taskData.remove(testId4);
        testSizeAndIteration(taskData, TaskId.MAX_ID-2);
        taskData.remove(testId4);
        testSizeAndIteration(taskData, TaskId.MAX_ID-2);

        
        dummyTask.name = "testId5";
        TaskId testId5 = taskData.add(dummyTask);
        assertTrue(testId5 != null);
        testSizeAndIteration(taskData, TaskId.MAX_ID-1);
        assertEquals("testId5", taskData.getTaskName(testId5));
        
        
        taskData.remove(testId2);
        testSizeAndIteration(taskData, TaskId.MAX_ID-2);
        assertEquals("testId5", taskData.getTaskName(testId5));
        

        dummyTask.name = "testId6";
        TaskId testId6 = taskData.add(dummyTask);
        assertTrue(testId6 != null);
        testSizeAndIteration(taskData, TaskId.MAX_ID-1);
        assertEquals("testId5", taskData.getTaskName(testId5));
        assertEquals("testId6", taskData.getTaskName(testId6));
        

        TaskId testId7 = taskData.add(dummyTask);
        assertTrue(testId7 != null);
        testSizeAndIteration(taskData, TaskId.MAX_ID);
        
        TaskId testId8 = taskData.add(dummyTask);
        assertTrue(testId8 == null);
        testSizeAndIteration(taskData, TaskId.MAX_ID);
    }

    /**
     * Checks whether the size of taskData matches size, and checks whether
     * the taskData is able to iterate through the list through next / previous
     * methods properly.
     * 
     * @param taskData taskData to test
     * @param size expected size of taskData.
     */
    private void testSizeAndIteration(ITaskData taskData, int size) {
        assertEquals(size, taskData.getSize());
        
        if (size == 0) {
            assertFalse(taskData.getFirst().isValid());
            assertFalse(taskData.getLast().isValid());
            
        } else {
            TaskId current = taskData.getFirst();
            
            for (int i=0; i<size-1; i++) {
                TaskId next = taskData.getNext(current);
                assertEquals(current, taskData.getPrevious(next));
                current = next;
            }
            assertEquals(current, taskData.getLast());
            assertFalse(taskData.getNext(current).isValid());
        }
    }

}

	// End of segment: src\data\test\TaskDataTest.java





	/**
	 * origin: src\data\test\TaskIdTest.java
	 */

public class TaskIdTest {

    @Test
    public void test() {
        for (int i = 0; i < TaskId.MAX_ID; i++) {
            testStringConvert(i);
        }

        //Test: conversion to int
        testIntConvert("A7D");
        testIntConvert("8AD");
        testIntConvert("0AA");
        testIntConvert("AA0");
        testIntConvert("ZZ9");
        testIntConvert("9ZZ");
        testIntConvert("D3E");
        testIntConvert("A1C");
        testIntConvert("BG0");

        //Test: invalid strings
        testInvalidString("ggg");
        testInvalidString("a00");
        testInvalidString("a0cF");
        testInvalidString("9d");
        testInvalidString("9!d");
        testInvalidString("9-d");
        testInvalidString(",dd");
        testInvalidString(",..");
        testInvalidString(",.0");
        testInvalidString("***");
        testInvalidString("1*1");
        testInvalidString("1 1");
        testInvalidString("dke9");
        testInvalidString("gad");
        testInvalidString("E");
        testInvalidString("ggg");

        //Test: Valid strings
        testValidString("g3d");
        testValidString("e3a");
        testValidString("aa0");
        testValidString("9dR");
    }
    
    
    private void testStringConvert(int a) {
        String stringId = TaskId.toStringId(a);
        assertEquals(3, stringId.length()); 
        
        int c = TaskId.toIntId(stringId);
        assertEquals(a, c);
    }
    
    
    private void testIntConvert(String stringId) {
        int intId = TaskId.toIntId(stringId);
        assertEquals(stringId, TaskId.toStringId(intId));
        
        testValidString(stringId);
    }

    private void testInvalidString(String stringId) {
        TaskId taskId = TaskId.makeTaskId(stringId);
        assertEquals(taskId, null);
    }

    private void testValidString(String stringId) {
        TaskId taskId = TaskId.makeTaskId(stringId);
        assertFalse(taskId == null);
    }
}

	// End of segment: src\data\test\TaskIdTest.java





	/**
	 * origin: src\data\test\TaskInfoTest.java
	 */

public class TaskInfoTest {
    
    @Test
    public void testIsValid() {

        TaskInfo taskInfo = TaskInfo.create();
        
        // Invalid - null name
        assertFalse(taskInfo.isValid());
        
        // Invalid - no name
        taskInfo.name = "";
        assertFalse(taskInfo.isValid());
        
        // Invalid - whitespace only
        taskInfo.name = "   ";
        assertFalse(taskInfo.isValid());
        
        taskInfo.name = "   heh";
        assertTrue(taskInfo.isValid());

        taskInfo.name = "lalala";
        assertTrue(taskInfo.isValid());

        // Time only, no date - invalid.
        taskInfo.endTime = LocalTime.of(8, 30);
        assertFalse(taskInfo.isValid());
        
        taskInfo.endDate = LocalDate.of(2014, 5, 20);
        assertTrue(taskInfo.isValid());

        // No start time - invalid
        taskInfo.startDate = LocalDate.of(2014, 5, 20);
        assertFalse(taskInfo.isValid());

        // Valid - start before end.
        taskInfo.startTime = LocalTime.of(3, 30);
        assertTrue(taskInfo.isValid());

        // Invalid - start after end.
        taskInfo.startTime = LocalTime.of(8, 31);
        assertFalse(taskInfo.isValid());

        // Valid - start before end
        taskInfo.endDate = LocalDate.of(2014, 6, 20);
        assertTrue(taskInfo.isValid());
        
        // Invalid - no name
        taskInfo.name = "";
        assertFalse(taskInfo.isValid());
    }

    @Test
    public void test() {
        //Solely for testing the extremely long equals() method!
        TaskInfo taskInfo = TaskInfo.create();
        TaskInfo taskInfo2 = TaskInfo.create();

        assertEquals(taskInfo, taskInfo);

        taskInfo.details = "";
        assertEquals(taskInfo, taskInfo2);

        taskInfo.name = "";
        assertEquals(taskInfo, taskInfo2);

        taskInfo2.name = "a";
        assertFalse(taskInfo.equals(taskInfo2));

        taskInfo = new TaskInfo(taskInfo2);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.endDate = LocalDate.of(5, 4, 3);
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.endTime = LocalTime.of(23, 14, 0);
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.priority = Priority.HIGH;
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.status = Status.DONE;
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.tags = null;
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo.tags = new Tag[]{new Tag("one"), new Tag("two"), new Tag("four")};
        assertEquals(taskInfo, taskInfo);
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));
        taskInfo2 = new TaskInfo(taskInfo);
        assertEquals(taskInfo, taskInfo2);

        taskInfo2.tags = new Tag[]{new Tag("one"), new Tag("four"), new Tag("two")};
        assertEquals(taskInfo, taskInfo2);
        assertEquals(taskInfo2, taskInfo);

        taskInfo.tags = new Tag[]{new Tag("one"), new Tag("two"), new Tag("two")};
        assertFalse(taskInfo.equals(taskInfo2));
        assertFalse(taskInfo2.equals(taskInfo));

        taskInfo2.tags = new Tag[]{new Tag("one"), new Tag("two")};
        assertEquals(taskInfo, taskInfo2);
        assertEquals(taskInfo2, taskInfo);

        taskInfo2.tags = new Tag[]{new Tag("one"), new Tag("one"), new Tag("two")};
        assertEquals(taskInfo, taskInfo2);
        assertEquals(taskInfo2, taskInfo);

        assertEquals(taskInfo, taskInfo);
        assertEquals(taskInfo2, taskInfo2);
    }

}

	// End of segment: src\data\test\TaskInfoTest.java





	/**
	 * origin: src\data\UndoSnapshot.java
	 */

/**
 * A "Snapshot" container holding all the UndoTaskSnapshots after an action
 * has been executed. (i.e. all the changes to TaskData in the last action)<br>
 * It is used to reverse all modifications to TaskData at once.
 * 
 */
public class UndoSnapshot {
    private ArrayList<UndoTaskSnapshot> taskSnapshotList;
    private final TaskData taskData;
    
    public UndoSnapshot(TaskData taskData) {
        this.taskData = taskData;
        taskSnapshotList = new ArrayList<>();
    }
    
    public void addTaskSnapshot(TaskInfo taskInfo, TaskId taskId) {
        assert taskId != null;
        assert taskSnapshotList != null;
        
        UndoTaskSnapshot taskSnapshot = new UndoTaskSnapshot(taskInfo, taskId);
        if (!taskSnapshotList.contains(taskSnapshot)) {
            taskSnapshotList.add(taskSnapshot);
        }
    }
    
    public boolean hasChanges() {
        return !taskSnapshotList.isEmpty();
    }
    
    /**
     * @return a list of the TaskIds that have been changed in this snapshot.
     * <br>
     * Assumes that the undo snapshot has not been executed
     * (applySnapshotChange) yet.
     */
    public TaskId[] getChangedList() {
        assert taskSnapshotList != null : "TaskSnapshotList has been already extracted";
        
        TaskId[] taskIds = new TaskId[taskSnapshotList.size()];
        int index = 0;
        for (UndoTaskSnapshot taskSnapshot : taskSnapshotList) {
            taskIds[index] = taskSnapshot.getTaskId();
            index++;
        }
        return taskIds;
    }

    /** 
     * Execute this method to apply all the reversions stored in this
     * UndoSnapshot onto TaskData.<br>
     * Calling this destroys this data structure.
     */
    public void applySnapshotChange() {
        ArrayList<UndoTaskSnapshot> taskSnapshotList = retrieveTaskSnapshots();
        for (UndoTaskSnapshot undoTaskSnapshot : taskSnapshotList) {
            undoTaskChange(undoTaskSnapshot);
        }
    }
    

    /**
     * Extracts all the individual task snapshots at once from the UndoSnapshot.<br>
     * This can only be done once.
     * Once extracted,this data structure is destroyed.<br>
     * @return a list of all the individual task snapshots - the previous state
     * for all the tasks that have been modified in the last action.
     */
    private ArrayList<UndoTaskSnapshot> retrieveTaskSnapshots() {
        ArrayList<UndoTaskSnapshot> tempList = taskSnapshotList;
        taskSnapshotList = null;
        return tempList;
    }
    

    private void undoTaskChange(UndoTaskSnapshot undoTaskSnapshot) {
        TaskId taskId = undoTaskSnapshot.getTaskId();
        TaskInfo taskInfo = undoTaskSnapshot.getTaskInfo();
        
        if (taskInfo == UndoTaskSnapshot.NO_TASK) {
            taskData.remove(taskId);
            
        } else {
            if (taskData.taskExists(taskId)) {
                taskData.setTaskInfo(taskId, taskInfo);
            } else {
                taskData.addTaskWithSpecificId(taskInfo, taskId);
            }
        }
    }
    
    
}

	// End of segment: src\data\UndoSnapshot.java





	/**
	 * origin: src\data\UndoTaskSnapshot.java
	 */

/**
 * Immutable. Done by restricting access to taskInfo attribute<br>
 * This class stores a snapshot of a task before a modification.<br>
 * It is used to undo changes.<br>
 * <br>
 * Note: if taskInfo = NO_TASK, it means the task did not exist before the change.
 * 
 */
public class UndoTaskSnapshot {

    public static TaskInfo NO_TASK = null;
    
    private final TaskInfo taskInfo;
    private final TaskId taskId;
    
    public UndoTaskSnapshot(TaskInfo taskInfo, TaskId taskId) {
        assert taskId != null;
        
        this.taskInfo = taskInfo;
        this.taskId = taskId;
    }
    
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((taskId == null) ? 0 : taskId.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        
        UndoTaskSnapshot other = (UndoTaskSnapshot) obj;
        if (taskId == null) {
            if (other.taskId != null) {
                return false;
            }
        } else if (!taskId.equals(other.taskId)) {
            return false;
        }
        return true;
    }

    /**
     * @return copy of stored TaskInfo for immutability.
     */
    public TaskInfo getTaskInfo() {
        if (taskInfo == NO_TASK) {
            return NO_TASK;
        }
        return new TaskInfo(taskInfo);
    }

    public TaskId getTaskId() {
        return taskId;
    }
    
}

	// End of segment: src\data\UndoTaskSnapshot.java





	/**
	 * origin: src\io\AliasFileInputOutput.java
	 */

public class AliasFileInputOutput implements IFileInputOutput {
    
    private final AutoCompleteDictionary autoCompleteDictionary;
    private final IAliasStorageFileInputOutput aliasStorage;
    private final String fileName;
    private String fileHash = "";

    public AliasFileInputOutput(IAliasStorageFileInputOutput aliasStorage,
            String fileName, AutoCompleteDictionary autoCompleteDictionary) {
        this.aliasStorage = aliasStorage;
        this.fileName = fileName;
        this.autoCompleteDictionary = autoCompleteDictionary;
    }

    /* (non-Javadoc)
     * @see io.IFileInputOutput#read()
     */
    public boolean read() {
        if (fileUnchanged()) {
            return false;
        }
        AliasValuePair[] aliases = readAliasesFromFile();
        
        if (aliases == null) {
            return false;
        } else {
            aliasStorage.setAllCustomAliases(aliases);
            updateAutoCompleteDictionary();
            return true;
        }
    }

    /* (non-Javadoc)
     * @see io.IFileInputOutput#write()
     */
    @Override
    public boolean write() {
        boolean result = writeAliasesToFile();
        
        if (result == true) {
            updateAutoCompleteDictionary();
            fileHash = IFileInputOutput.computeHash(fileName);
        }
        
        return result;
    }


    /**
     * @return tasks as read from file, in a TaskInfo[] array.
     * Returns null if there is an error reading.
     */
    private AliasValuePair[] readAliasesFromFile() {
        
        AliasValuePair[] aliases = null;
        
        File file = new File(fileName);
        try {
            FileReader fileReader = new FileReader(file);
            IReaderWriter readerWriter = new JsonReaderWriter();
            aliases = readerWriter.readAliasesFromJson(fileReader);
            
            fileReader.close();
            
        } catch (IOException e) {
            return null;
        }
        
        return aliases;
    }
    
    /**
     * @return true iff successful.
     */
    private boolean writeAliasesToFile() {
        
        AliasValuePair[] aliases = getAliasArrayFromStorage();
        
        File file = new File(fileName);
        boolean result = false;
        
        try {
            FileWriter fileWriter = new FileWriter(file);
            IReaderWriter readerWriter = new JsonReaderWriter();
            result = readerWriter.writeAliasesToJson(fileWriter, aliases);
            
        } catch (IOException e) {
            e.printStackTrace();
            result = false;
        }
        
        return result;
    }
    
    
    private AliasValuePair[] getAliasArrayFromStorage() {
        return aliasStorage.getAllCustomAliases();
    }

    /**
     * The file is unchanged iff the file's hash matches the old hash.
     * @return true iff the file has not changed since the last save.
     */
    private boolean fileUnchanged() {
        String currentHash = IFileInputOutput.computeHash(fileName);
        return fileHash.equals(currentHash);
    }
    
    private void updateAutoCompleteDictionary() {
        String[] allBindedStrings = aliasStorage.getAllBindedStrings();
        autoCompleteDictionary.refreshDictionary(allBindedStrings);
    }
    
}

	// End of segment: src\io\AliasFileInputOutput.java





	/**
	 * origin: src\io\FileInputOutput.java
	 */

public class FileInputOutput implements IFileInputOutput {
    private static final Logger log = TasklineLogger.getLogger();
    
    private final String fileName;
    private String fileHash = "";
    
    private final ITaskDataFileInputOutput taskData;
    
    public FileInputOutput(TaskData taskData, String fileName) {
        this.fileName = fileName;
        this.taskData = taskData;
    }
    
    /* (non-Javadoc)
     * @see io.IFileInputOutput#read()
     */
    @Override
    public boolean read() {
        
        if (fileUnchanged()) {
            log.log(Level.FINER, "Read from file - Hash unchanged. Will not change TaskData");
            return false;
        }
        log.log(Level.FINER, "Read from file - Hash mismatch.");
        
        TaskInfo[] taskInfos = readTasksFromFile();
        
        if (taskInfos == null) {
            log.log(Level.FINER, "Unable to read tasks from file. Will not change TaskData");
            return false;
        } else {
            log.log(Level.FINER, "New task read from file successfully - Updating TaskData...");
            taskData.updateTaskList(taskInfos);
            return true;
        }
    }

    /* (non-Javadoc)
     * @see io.IFileInputOutput#write()
     */
    @Override
    public boolean write() {
        if (taskData.hasUnsavedChanges()) {
            log.log(Level.FINER, "Write to file: TaskData has unsaved changes. Writing...");
            boolean result = writeTasksToFile();
            
            if (result == true) {
                log.log(Level.FINER, "Writing to file successful. Recomputing hash.");
                fileHash = IFileInputOutput.computeHash(fileName);
                taskData.saveSuccessful();
            } 
            
            return result;
            
        } else {
            log.log(Level.FINER, "Write to file: TaskData has no unsaved changes. Do nothing.");
            return true;
        }
    }
    


    /**
     * @return tasks as read from file, in a TaskInfo[] array.
     * Returns null if there is an error reading.
     */
    private TaskInfo[] readTasksFromFile() {
        
        TaskInfo[] taskInfos = null;
        
        File file = new File(fileName);
        try {
            FileReader fileReader = new FileReader(file);
            IReaderWriter readerWriter = new JsonReaderWriter();
            taskInfos = readerWriter.readTasksFromJson(fileReader);
            
            fileReader.close();
            
        } catch (IOException e) {
            return null;
        }
        
        return taskInfos;
    }
    
    /**
     * @return true iff successful.
     */
    private boolean writeTasksToFile() {
        
        TaskInfo[] taskInfos = getTaskInfoArrayFromTaskData();
        
        File file = new File(fileName);
        boolean result = false;
        
        try {
            FileWriter fileWriter = new FileWriter(file);
            IReaderWriter readerWriter = new JsonReaderWriter();
            result = readerWriter.writeTasksToJson(fileWriter, taskInfos);
            
        } catch (IOException e) {
            e.printStackTrace();
            result = false;
        }
        
        return result;
    }

    private TaskInfo[] getTaskInfoArrayFromTaskData() {
        int size = taskData.getSize();
        TaskInfo[] taskInfos = new TaskInfo[size];
        
        int index = 0;
        TaskId current = taskData.getFirst();
        
        while (current.isValid()) {
            taskInfos[index] = taskData.getTaskInfo(current);
            current = taskData.getNext(current);
            index++;
        }
        return taskInfos;
    }

    /**
     * The file is unchanged iff the file's hash matches the old hash.
     * @return true iff the file has not changed since the last save.
     */
    private boolean fileUnchanged() {
        String currentHash = IFileInputOutput.computeHash(fileName);
        return fileHash.equals(currentHash);
    }
}

	// End of segment: src\io\FileInputOutput.java





	/**
	 * origin: src\io\IFileInputOutput.java
	 */

public interface IFileInputOutput {

    /**
     * @return true iff there is a change in the file and we successfully
     * write that change to program memory.
     */
    public abstract boolean read();

    /**
     * @return true for success.
     */
    public abstract boolean write();

    
    
    
    public static String computeHash(String nameOfFile) {
        try {
            MessageDigest md5er = generateMessageDigest(nameOfFile);

            if (md5er == null) {
                return null;
            }
            
            byte[] digest = md5er.digest();
            
            if (digest == null) {
                return null;
            }
            
            StringBuilder result = new StringBuilder();
            
            for (int i = 0; i < digest.length; i++) {
                result.append(byteToHex(digest[i]));
            }
            
            return result.toString();
            
        } catch (Exception e) {
            return null;
        }
    }

    public static String byteToHex(byte b) {
        return Integer.toString((b & 0xff) + 0x100, 16).substring(1);
    }

    public static MessageDigest generateMessageDigest(String nameOfFile) {
        MessageDigest md5er;
        
        try {
            InputStream fin = new FileInputStream(nameOfFile);
            md5er = MessageDigest.getInstance("MD5");
            
            byte[] buffer = new byte[1024];
            
            int read = 0;
            while (read != -1) {
                read = fin.read(buffer);
                if (read > 0) {
                    md5er.update(buffer, 0, read);
                }
            }
            
            fin.close();
            
        } catch (IOException e) {
            return null;
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
            return null;
        }

        return md5er;
    }
}
	// End of segment: src\io\IFileInputOutput.java





	/**
	 * origin: src\io\InvalidFileFormatException.java
	 */

public class InvalidFileFormatException extends Exception {
    private static final long serialVersionUID = -450599715167762851L;

    public InvalidFileFormatException(String message) {
        super(message);
    }
}

	// End of segment: src\io\InvalidFileFormatException.java





	/**
	 * origin: src\io\IReaderWriter.java
	 */

/**
 * A ReaderWriter class interface that is used by File IO to parse data from
 * a (file) Reader into objects, and to convert objects into a String format in
 * a (file) Writer to output to a file.<br>
 * <br>
 * Can parse TaskInfo objects and AliasValuePAir objects.
 */
public interface IReaderWriter {

    /**
     * @param writer Outputs the JSON string to this writer.
     * @param taskInfos an Array of AliasValuePair to be converted into JSON
     * format
     * @return true iff successful.
     */
    public abstract boolean writeAliasesToJson(Writer writer,
            AliasValuePair[] taskInfos);

    /**
     * @param reader A Reader to read a JSON string from.
     * @return an array of AliasValuePairs extracted from parsing the JSON data
     * in the reader.
     */
    public abstract AliasValuePair[] readAliasesFromJson(Reader reader);

    /**
     * @param taskInfos an Array of TaskInfo to be converted into a string.
     * @return a String containing all the data from the taskInfos array,
     * in JSON format, pretty printed.
     */
    public abstract String tasksToJsonString(TaskInfo[] taskInfos);

    /**
     * @param jsonString A string formatted in Json storing the TaskInfos
     * @return an array of TaskInfos extracted from jsonString
     * @throws InvalidFileFormatException
     * thrown when an error occurred during the parsing of the string.
     */
    public abstract TaskInfo[] jsonStringToTasks(String jsonString)
            throws InvalidFileFormatException;

    /**
     * @param writer Outputs the JSON string to this writer.
     * @param taskInfos an Array of TaskInfo to be converted into JSON format
     * @return true iff successful.
     */
    public abstract boolean writeTasksToJson(Writer writer, TaskInfo[] taskInfos);

    /**
     * @param reader A Reader to read a JSON string from.
     * @return an array of TaskInfos extracted from parsing the JSON data in
     * the reader.
     */
    public abstract TaskInfo[] readTasksFromJson(Reader reader);

}
	// End of segment: src\io\IReaderWriter.java





	/**
	 * origin: src\io\json\JsonAliasParser.java
	 */

/**
 * the main Json Parser for Aliases.
 */
public class JsonAliasParser {
    private static final String JSON_ALIASES = "aliases";
    private static final String JSON_ALIAS = "alias";
    private static final String JSON_VALUE = "value";

    
    public static void aliasesToJson(Writer writer, AliasValuePair[] aliases) { 
        
        JsonObjectBuilder builder = Json.createObjectBuilder();
        
        JsonArrayBuilder aliasArrayJson = Json.createArrayBuilder();
        for (AliasValuePair alias : aliases) {
            aliasArrayJson.add(createJsonObjectBuilder(alias));
        }
        
        builder.add(JSON_ALIASES, aliasArrayJson);
        
        JsonObject jsonObject = builder.build();
        JsonItemParser.writePrettyPrint(writer, jsonObject);
    }
    
    public static AliasValuePair[] jsonToAliases(Reader reader)
            throws InvalidFileFormatException {
        
        Queue<AliasValuePair> aliasQueue = new LinkedList<>();
        
        JsonParser parser = Json.createParser(reader);
        try {
            Event event = parser.next();
            
            while (!(event == Event.KEY_NAME && parser.getString().equals(JSON_ALIASES))) {
                event = parser.next();
            }
            
            event = parser.next();
            if (event != Event.START_ARRAY) {
                throw new InvalidFileFormatException("Aliases is not an array.");
            }
            
            event = parser.next();
            while (event == Event.START_OBJECT) {
                aliasQueue.offer(parseAlias(parser));
                event = parser.next();
            } 
            
            if (event == Event.END_ARRAY) {
                parser.close();
                
            } else {
                throw new InvalidFileFormatException("End of tasks array not found");
            }
            
        } catch (NoSuchElementException e) {
            throw new InvalidFileFormatException("Reached end of file unexpectedly.");
        } catch (JsonParsingException e) {
            throw new InvalidFileFormatException("Invalid JSON encountered.");
        } catch (JsonException e) {
            throw new InvalidFileFormatException("Unable to read file.");
        }
        
        AliasValuePair[] aliases = new AliasValuePair[aliasQueue.size()];
        for (int i = 0; i < aliases.length; i++) {
            aliases[i] = aliasQueue.poll();
        }
        
        return aliases;
    }

    private static AliasValuePair parseAlias(JsonParser parser)
            throws InvalidFileFormatException {

        String[] aliasAndValue = new String[2];
        
        Event event = parser.next();
        while (event != Event.END_OBJECT) {
            
            if (event != Event.KEY_NAME) {
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_WRONG_EVENT + event.name());
            }
            String key = parser.getString();
            
            event = parser.next();
            if (event == Event.VALUE_STRING) {
                String value = parser.getString();
                readKeyValuePair(aliasAndValue, key, value);
                
            } else {
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_WRONG_EVENT + event.name());
            }
            
            event = parser.next();
        }
        
        String alias = aliasAndValue[0];
        String value = aliasAndValue[1];
        return new AliasValuePair(alias, value);
    }

    private static void readKeyValuePair(String[] aliasAndValue,
            String key, String value) throws InvalidFileFormatException {
        
        switch(key) {
            case JSON_ALIAS :
                aliasAndValue[0] = JsonItemParser.jsonStringToString(value);
                break;
            case JSON_VALUE :
                aliasAndValue[1] = JsonItemParser.jsonStringToString(value);
                break;
            default :
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_UNKNOWN_ELEMENT + key);
        }
    }

    private static JsonObjectBuilder createJsonObjectBuilder(
            AliasValuePair aliasValuePair) {
        JsonObjectBuilder builder = Json.createObjectBuilder();
        builder.add(JSON_ALIAS,
                JsonItemParser.stringToJsonString(aliasValuePair.alias));
        builder.add(JSON_VALUE,
                JsonItemParser.stringToJsonString(aliasValuePair.value));
        
        return builder;
    }
}

	// End of segment: src\io\json\JsonAliasParser.java





	/**
	 * origin: src\io\json\JsonItemParser.java
	 */

/**
 * Used to parse the individual items used in the Json file. e.g. dates times
 * priorities etc
 */
public class JsonItemParser {
    
    public static final String STRING_EMPTY = "";
    public static final String STRING_NULL = "null";

    private static final String FORMAT_TIME = "%02d:%02d:%02d";
    private static final String FORMAT_DATE = "%d-%02d-%02d";

    public static String localTimeToString(LocalTime time) {
        if (time == null)
            return STRING_NULL;
        
        return String.format(FORMAT_TIME, time.getHour(),
                time.getMinute(), time.getSecond());
    }
    
    public static LocalTime stringToLocalTime(String timeString) {
        if (isNullString(timeString))
            return null;
        
        String[] split = timeString.split(":");
        LocalTime time;
        try {
            int hour = Integer.parseInt(split[0]);
            int minute = Integer.parseInt(split[1]);
            int second = Integer.parseInt(split[2]);
            time = LocalTime.of(hour, minute, second);
            
        } catch (NumberFormatException e) {
            return null;
        }
        return time;
    }

    public static String localDateToString(LocalDate date) {
        if (date == null)
            return STRING_NULL;
        
        return String.format(FORMAT_DATE, date.getYear(),
                date.getMonthValue(), date.getDayOfMonth());
    }
    
    public static LocalDate stringToLocalDate(String dateString) {
        if (isNullString(dateString))
            return null;
        
        String[] split = dateString.split("\\-");
        LocalDate date;
        try {
            int year = Integer.parseInt(split[0]);
            int month = Integer.parseInt(split[1]);
            int dayOfMonth = Integer.parseInt(split[2]);
            date = LocalDate.of(year, month, dayOfMonth);
            
        } catch (NumberFormatException e) {
            return null;
        }
        return date;
        
    }

    public static String durationToString(Duration duration) {
        if (duration == null)
            return STRING_NULL;
        
        return duration.toString();
    }
    
    public static Duration stringToDuration(String durationString) {
        if (isNullString(durationString))
            return null;
        
        Duration duration;
        try {
            duration = Duration.parse(durationString);
            
        } catch (DateTimeParseException e) {
            return null;
        }
        return duration;
    }
    
    public static String statusToString(Status status) {
        if (status == null)
            return Status.defaultStatus().name();
        
        return status.name();
    }

    public static String priorityToString(Priority priority) {
        if (priority == null)
            return Priority.defaultPriority().name();
        
        return priority.name();
    }

    public static Status stringToStatus(String statusString) {
        if (isNullString(statusString))
            return Status.defaultStatus();
        
        return Status.valueOf(statusString);
    }

    public static Priority stringToPriority(String priorityString) {
        if (isNullString(priorityString))
            return Priority.defaultPriority();
        
        return Priority.valueOf(priorityString);
    }

    public static String stringToJsonString(String string) {
        if (string == null)
            return STRING_EMPTY;
        return string;
    }
    
    public static String jsonStringToString(String jsonString) {
        return jsonString;
    }

    
    public static boolean isNullString(String value) {
        return STRING_NULL.equals(value);
    }

    
    static void writePrettyPrint(Writer writer, JsonObject jsonObject) {
        Map<String, Object> properties = new HashMap<>(1);
        properties.put(JsonGenerator.PRETTY_PRINTING, true);
        
        JsonWriterFactory writerFactory = Json.createWriterFactory(properties);
        JsonWriter jsonWriter = writerFactory.createWriter(writer);
        jsonWriter.writeObject(jsonObject);
        jsonWriter.close();
    }
}

	// End of segment: src\io\json\JsonItemParser.java





	/**
	 * origin: src\io\json\JsonReaderWriter.java
	 */

/**
 * A ReaderWriter that uses Json to parse aliases and tasks.<br>
 * This class is mostly a facade. The main implementation is in
 * JsonTaskInfoParser / JsonAliasParser. 
 */
public class JsonReaderWriter implements IReaderWriter {
    private static final Logger log = TasklineLogger.getLogger();

    static final String ERROR_WRONG_EVENT = "Wrong event: ";
    static final String ERROR_UNKNOWN_ELEMENT = "Unknown element: ";
    

    /* (non-Javadoc)
     * @see io.IReaderWriter#writeAliasesToJson(java.io.Writer, main.command.alias.AliasValuePair[])
     */
    @Override
    public boolean writeAliasesToJson(Writer writer, AliasValuePair[] aliases) {
        JsonAliasParser.aliasesToJson(writer, aliases);
        return true;
    }

    /* (non-Javadoc)
     * @see io.IReaderWriter#readAliasesFromJson(java.io.Reader)
     */
    @Override
    public AliasValuePair[] readAliasesFromJson(Reader reader) {
        AliasValuePair[] aliases = null;
        try {
            aliases = JsonAliasParser.jsonToAliases(reader);
            
        } catch (InvalidFileFormatException e) {
            log.log(Level.SEVERE, "Invalid File Format: " + e.getMessage());
            return null;
        }
        return aliases;
    }
    
    /* (non-Javadoc)
     * @see io.IReaderWriter#tasksToJsonString(data.taskinfo.TaskInfo[])
     */
    @Override
    public String tasksToJsonString(TaskInfo[] taskInfos) {
        StringWriter stringWriter = new StringWriter();
        JsonTaskInfoParser.tasksToJson(stringWriter, taskInfos);
        
        return stringWriter.toString();
    }

    /* (non-Javadoc)
     * @see io.IReaderWriter#jsonStringToTasks(java.lang.String)
     */
    @Override
    public TaskInfo[] jsonStringToTasks(String jsonString)
            throws InvalidFileFormatException {
        
        StringReader stringReader = new StringReader(jsonString);
        return JsonTaskInfoParser.jsonToTasks(stringReader);
    }

    /* (non-Javadoc)
     * @see io.IReaderWriter#writeTasksToJson(java.io.Writer, data.taskinfo.TaskInfo[])
     */
    @Override
    public boolean writeTasksToJson(Writer writer, TaskInfo[] taskInfos) {
        JsonTaskInfoParser.tasksToJson(writer, taskInfos);
        return true;
    }

    /* (non-Javadoc)
     * @see io.IReaderWriter#readTasksFromJson(java.io.Reader)
     */
    @Override
    public TaskInfo[] readTasksFromJson(Reader reader) {
        TaskInfo[] taskInfos = null;
        try {
            taskInfos = JsonTaskInfoParser.jsonToTasks(reader);
            
        } catch (InvalidFileFormatException e) {
            return null;
        }
        return taskInfos;
    }
    
}

	// End of segment: src\io\json\JsonReaderWriter.java





	/**
	 * origin: src\io\json\JsonTaskInfoParser.java
	 */

/**
 * the main Json Parser for Tasks.
 */
public class JsonTaskInfoParser {

    private static final String JSON_TASKS = "tasks";
    private static final String JSON_NAME = "name";
    private static final String JSON_START_TIME = "startTime";
    private static final String JSON_START_DATE = "startDate";
    private static final String JSON_END_TIME = "endTime";
    private static final String JSON_END_DATE = "endDate";
    private static final String JSON_DETAILS = "details";
    private static final String JSON_TAGS = "tags";
    private static final String JSON_PRIORITY = "priority";
    private static final String JSON_STATUS = "status";
    /**
     * @deprecated
     */
    private static final String JSON_NUMBER_OF_TIMES = "numberOfTimes";
    /**
     * @deprecated
     */
    private static final String JSON_REPEAT_INTERVAL = "repeatInterval";

    
    public static void tasksToJson(Writer writer, TaskInfo[] taskInfos) { 
        
        JsonObjectBuilder builder = Json.createObjectBuilder();
        
        JsonArrayBuilder taskInfoArrayJson = Json.createArrayBuilder();
        for (TaskInfo taskInfo : taskInfos) {
            taskInfoArrayJson.add(createJsonObjectBuilder(taskInfo));
        }
        
        builder.add(JSON_TASKS, taskInfoArrayJson);
        
        JsonObject jsonObject = builder.build();
        JsonItemParser.writePrettyPrint(writer, jsonObject);
    }
    
    public static TaskInfo[] jsonToTasks(Reader reader)
            throws InvalidFileFormatException {
        
        Queue<TaskInfo> taskInfoQueue = new LinkedList<>();
        
        JsonParser parser = Json.createParser(reader);
        try {
            Event event = parser.next();
            
            while (!(event == Event.KEY_NAME && parser.getString().equals(JSON_TASKS))) {
                event = parser.next();
            }
            
            event = parser.next();
            if (event != Event.START_ARRAY) {
                throw new InvalidFileFormatException("Tasks is not an array.");
            }
            
            event = parser.next();
            while (event == Event.START_OBJECT) {
                taskInfoQueue.offer(parseTaskInfo(parser));
                event = parser.next();
            } 
            
            if (event == Event.END_ARRAY) {
                parser.close();
                
            } else {
                throw new InvalidFileFormatException("End of tasks array not found");
            }
            
        } catch (NoSuchElementException e) {
            throw new InvalidFileFormatException("Reached end of file unexpectedly.");
        } catch (JsonParsingException e) {
            throw new InvalidFileFormatException("Invalid JSON encountered.");
        } catch (JsonException e) {
            throw new InvalidFileFormatException("Unable to read file.");
        }
        
        TaskInfo[] taskInfos = new TaskInfo[taskInfoQueue.size()];
        for (int i = 0; i < taskInfos.length; i++) {
            taskInfos[i] = taskInfoQueue.poll();
        }
        
        return taskInfos;
    }
    
    
    private static TaskInfo parseTaskInfo(JsonParser parser)
            throws InvalidFileFormatException {
        
        TaskInfo taskInfo = TaskInfo.create();
        
        Event event = parser.next();
        while (event != Event.END_OBJECT) {
            
            if (event != Event.KEY_NAME) {
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_WRONG_EVENT + event.name());
            }
            String key = parser.getString();
            
            event = parser.next();
            if (event == Event.VALUE_STRING) {
                String value = parser.getString();
                readKeyValuePair(taskInfo, key, value);
                
            } else if (event == Event.START_ARRAY) {
                readKeyStringArrayPair(taskInfo, key, parser);
            
            } else {
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_WRONG_EVENT + event.name());
            }
            
            event = parser.next();
        }
        
        return taskInfo;
    }
    
    private static void readKeyValuePair(TaskInfo taskInfo,
            String key, String value) throws InvalidFileFormatException {
        
        switch(key) {
            case JSON_NAME :
                taskInfo.name = JsonItemParser.jsonStringToString(value);
                break;
            case JSON_START_TIME :
                taskInfo.startTime = JsonItemParser.stringToLocalTime(value);
                break;
            case JSON_START_DATE :
                taskInfo.startDate = JsonItemParser.stringToLocalDate(value);
                break;
            case JSON_END_TIME :
                taskInfo.endTime = JsonItemParser.stringToLocalTime(value);
                break;
            case JSON_END_DATE :
                taskInfo.endDate = JsonItemParser.stringToLocalDate(value);
                break;
            case JSON_TAGS :
                if (JsonItemParser.isNullString(value))
                    taskInfo.tags = null;
                else
                    throw new InvalidFileFormatException("Unable to read tags");
                break;
            case JSON_DETAILS :
                taskInfo.details = JsonItemParser.jsonStringToString(value);
                break;
            case JSON_PRIORITY :
                try {
                    taskInfo.priority = JsonItemParser.stringToPriority(value);
                } catch (IllegalArgumentException e) {
                    throw new InvalidFileFormatException("Unable to read priority");
                }
                break;
            case JSON_STATUS :
                try {
                    taskInfo.status = JsonItemParser.stringToStatus(value);
                } catch (IllegalArgumentException e) {
                    throw new InvalidFileFormatException("Unable to read status");
                }
                break;
            default :
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_UNKNOWN_ELEMENT + key);
        }
    }
    
    private static void readKeyStringArrayPair(TaskInfo taskInfo, String key,
            JsonParser parser) throws InvalidFileFormatException {
        
        Queue<String> stringQueue = new LinkedList<>();
        
        Event event = parser.next();
        while (event != Event.END_ARRAY) {
            stringQueue.offer(parser.getString());
            event = parser.next();
        }
        
        switch(key) {
            case JSON_TAGS:
                Tag[] tags = new Tag[stringQueue.size()];
                for (int i = 0; i < tags.length; i++) {
                    tags[i] = new Tag(stringQueue.poll());
                }
                taskInfo.tags = tags;
                break;
            default:
                throw new InvalidFileFormatException(
                        JsonReaderWriter.ERROR_UNKNOWN_ELEMENT + key);
        }
    }

    private static JsonObjectBuilder createJsonObjectBuilder(
            TaskInfo taskInfo) {
        
        JsonObjectBuilder builder = Json.createObjectBuilder();
        
        builder.add(JSON_NAME,
                JsonItemParser.stringToJsonString(taskInfo.name));
        builder.add(JSON_START_TIME,
                JsonItemParser.localTimeToString(taskInfo.startTime));
        builder.add(JSON_START_DATE,
                JsonItemParser.localDateToString(taskInfo.startDate));
        builder.add(JSON_END_TIME,
                JsonItemParser.localTimeToString(taskInfo.endTime));
        builder.add(JSON_END_DATE,
                JsonItemParser.localDateToString(taskInfo.endDate));
        builder.add(JSON_DETAILS,
                JsonItemParser.stringToJsonString(taskInfo.details));
        
        builderAddTags(taskInfo.tags, builder);
        
        builder.add(JSON_PRIORITY,
                JsonItemParser.priorityToString(taskInfo.priority));
        builder.add(JSON_STATUS,
                JsonItemParser.statusToString(taskInfo.status));
        
        // PENDING IMPLEMENTATION
        //builder.add(JSON_NUMBER_OF_TIMES, taskInfo.numberOfTimes);
        //builder.add(JSON_REPEAT_INTERVAL, taskInfo.repeatInterval);
        
        return builder;
    }


    private static void builderAddTags(Tag[] tags, JsonObjectBuilder builder) {
        if (tags == null) {
            builder.add(JSON_TAGS, JsonItemParser.STRING_NULL);
            
        } else {
            JsonArrayBuilder tagArrayJson = Json.createArrayBuilder();
            for (Tag tag : tags) {
                tagArrayJson.add(tag.toString());
            }
            
            builder.add(JSON_TAGS, tagArrayJson);
        }
    }
}

	// End of segment: src\io\json\JsonTaskInfoParser.java





	/**
	 * origin: src\io\test\FileInputOutputTest.java
	 */

public class FileInputOutputTest {

    @Test
    public void test() {
        testFileHash();
    }
    
    private void testFileHash() {
        String message = "Hello World! This is a test file!";
        
        try {
            FileWriter writer = new FileWriter("testFile.txt");
            writer.write(message);
            writer.flush();
            writer.close();
        
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            FileWriter writer = new FileWriter("fileTest.txt");
            writer.write("THIS IS A WRONG TEST FILE!");
            writer.flush();
            writer.close();
        
        } catch (IOException e) {
            e.printStackTrace();
        }

        String correctHash = "6bd6955dce300739cdea07fa4fc574aa";
        
        String hash1 = IFileInputOutput.computeHash("testFile.txt");
        String hash2 = IFileInputOutput.computeHash("fileTest.txt");
        
        assertEquals(correctHash, hash1);
        assertEquals(correctHash.length(), hash2.length());
        assertFalse(correctHash.equals(hash2));
    }

}

	// End of segment: src\io\test\FileInputOutputTest.java





	/**
	 * origin: src\io\test\IoTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    FileInputOutputTest.class,
    JsonReaderWriterTest.class,
    JsonItemParserTest.class
})
public class IoTestSuite {

}

	// End of segment: src\io\test\IoTestSuite.java





	/**
	 * origin: src\io\test\JsonItemParserTest.java
	 */

public class JsonItemParserTest {

    @Test
    public void testDateTimeConversion() {
        Duration duration;
        String durationString;

        duration = Duration.ofHours(15);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));
        
        duration = Duration.ofDays(10000);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));
        
        duration = Duration.ofSeconds(3);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));
        
        duration = Duration.ofSeconds(1200);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));
        
        duration = Duration.ofHours(0);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));
        
        duration = Duration.ofHours(24);
        durationString = JsonItemParser.durationToString(duration);
        assertEquals(duration, JsonItemParser.stringToDuration(durationString));

        durationString = "test";
        assertEquals(null, JsonItemParser.stringToDuration(durationString));

        LocalTime time;
        String timeString;
        
        time = LocalTime.of(5, 4, 3);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(0, 1, 1);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(1, 0, 1);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(1, 1, 0);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(0, 0, 0);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(23, 59, 59);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));
        
        time = LocalTime.of(11, 10, 3);
        timeString = JsonItemParser.localTimeToString(time);
        assertEquals(time, JsonItemParser.stringToLocalTime(timeString));

        LocalDate date;
        String dateString;
        
        date = LocalDate.of(2013, 12, 31);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));
        
        date = LocalDate.of(1990, 2, 2);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));
        
        date = LocalDate.of(2012, 2, 29);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));
        
        date = LocalDate.of(1, 1, 1);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));

        date = LocalDate.of(3012, 7, 4);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));

        date = LocalDate.of(1000, 7, 7);
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));

        date = LocalDate.now();
        dateString = JsonItemParser.localDateToString(date);
        assertEquals(date, JsonItemParser.stringToLocalDate(dateString));
    }

}

	// End of segment: src\io\test\JsonItemParserTest.java





	/**
	 * origin: src\io\test\JsonReaderWriterTest.java
	 */

public class JsonReaderWriterTest {

    @Test
    public void testJsonParsing() {
        TaskInfo taskInfo = TaskInfo.create();
        taskInfo.name = "A little boy going to the market";
        taskInfo.details = "The market is very big.";
        taskInfo.startDate = LocalDate.of(1999, 8, 15);
        taskInfo.startTime = LocalTime.of(11, 12, 0);
        taskInfo.endDate = LocalDate.now();
        taskInfo.endTime = LocalTime.of(14, 0, 0);
        taskInfo.priority = Priority.MEDIUM;
        taskInfo.status = Status.DONE;
        taskInfo.tags = new Tag[]{new Tag("boy"), new Tag("market")};

        TaskInfo taskInfo2 = TaskInfo.create();
        taskInfo2.name = "kasjfklaf\n\n\n^%#^#$%@%lkA<FZ>>>>???>></////||||||()()()%%%DDDD\r\n";
        taskInfo2.details = null;
        taskInfo.startDate = null;
        taskInfo.startTime = null;
        taskInfo2.endDate = null;
        taskInfo2.endTime = null;
        taskInfo2.priority = null;
        taskInfo2.status = null;
        taskInfo2.tags = null;

        TaskInfo taskInfo3 = TaskInfo.create();
        taskInfo2.name = "";
        taskInfo2.details = "";
        taskInfo.startDate = null;
        taskInfo.startTime = LocalTime.of(0, 15, 16);
        taskInfo.endDate = LocalDate.of(160, 2, 29);
        taskInfo2.endTime = null;
        taskInfo2.priority = Priority.NONE;
        taskInfo2.status = Status.UNDONE;
        taskInfo2.tags = new Tag[0];

        TaskInfo taskInfo4 = TaskInfo.create();
        taskInfo.name = "null";
        taskInfo.details = "null";
        taskInfo.endDate = LocalDate.of(2, 2, 2);
        taskInfo.endTime = LocalTime.of(0, 0, 0);
        taskInfo.endDate = LocalDate.of(1, 1, 1);
        taskInfo.endTime = LocalTime.of(0, 59, 59);
        taskInfo.priority = null;
        taskInfo.status = Status.UNDONE;
        taskInfo.tags = new Tag[]{new Tag("boy"), new Tag("market"),
                new Tag("market"), new Tag("market"), new Tag("market"),
                new Tag("market"), new Tag("boy"), new Tag("market"),
                new Tag("market")};
        
        
        
        TaskInfo[] taskInfos = new TaskInfo[2];
        taskInfos[0] = taskInfo;
        taskInfos[1] = taskInfo2;
        testJsonParsing(taskInfos);

        
        taskInfos = new TaskInfo[0];
        testJsonParsing(taskInfos);
        

        taskInfos = new TaskInfo[20];
        for (int i = 0; i < 5; i++) {
            taskInfos[4 * i + 0] = taskInfo;
            taskInfos[4 * i + 1] = taskInfo2;
            taskInfos[4 * i + 2] = taskInfo3;
            taskInfos[4 * i + 3] = taskInfo4;
        }
        
        testJsonParsing(taskInfos);
    }

    private void testJsonParsing(TaskInfo[] taskInfos) {
        IReaderWriter readerWriter = new JsonReaderWriter();
        
        String json = readerWriter.tasksToJsonString(taskInfos);

        TaskInfo[] expectedResult = createExpectedResult(taskInfos);
        TaskInfo[] loadTaskInfos = null;
        
        try {
            loadTaskInfos = readerWriter.jsonStringToTasks(json);
        } catch (InvalidFileFormatException e) {
            e.printStackTrace();
        }

        assertEquals(taskInfos.length, loadTaskInfos.length);
        
        for (int i = 0; i < taskInfos.length; i++) {
            assertEquals(expectedResult[i], loadTaskInfos[i]);
        }
        
        String json2 = readerWriter.tasksToJsonString(loadTaskInfos);
        assertEquals(json, json2);
    }
    
    private TaskInfo[] createExpectedResult(TaskInfo[] taskInfos) {
        TaskInfo[] expectedResult = new TaskInfo[taskInfos.length];
        
        for (int i = 0; i < taskInfos.length; i++) {
            expectedResult[i] = new TaskInfo(taskInfos[i]);
            
            if (expectedResult[i].status == null) {
                expectedResult[i].status = Status.defaultStatus();
            }
            if (expectedResult[i].priority == null) {
                expectedResult[i].priority = Priority.defaultPriority();
            }
        }
        return expectedResult;
    }

}

	// End of segment: src\io\test\JsonReaderWriterTest.java





	/**
	 * origin: src\main\command\alias\AliasController.java
	 */

    private String tryReplaceWithCustom(String command) {
        String[] split = command.split(" ", 2);
        assert split.length >= 1;

        String replacement = getCustomAlias(split[0]);
        if (replacement == null) {
            return command;
        }

        String argument;

        if (split.length <= 1) {
            argument = "";
        } else {
            assert split.length == 2;
            argument = split[1];
        }

        replacement = replacement.replace(AliasStorage.VARIABLE_STRING,
                argument);
        return replacement;
    }

	// End of segment: src\main\command\alias\AliasController.java





	/**
	 * origin: src\main\command\alias\AliasController.java
	 */

    public BiFunction<String, ManagerHolder, Command> getReservedCommand(
            String cmdString) {
        return aliasStorage.getDefaultCommand(cmdString.toLowerCase());
    }

	// End of segment: src\main\command\alias\AliasController.java





	/**
	 * origin: src\main\command\alias\AliasController.java
	 */

    public String getCustomAlias(String possibleAlias) {
        return aliasStorage.getCustomCommand(possibleAlias.toLowerCase());
    }

	// End of segment: src\main\command\alias\AliasController.java





	/**
	 * origin: src\main\command\alias\AliasStorage.java
	 */

public class AliasStorage implements IAliasStorage, IAliasStorageFileInputOutput {
    // Variable string: \$ (String replaced with user's argument when aliased)
    public static final String VARIABLE_STRING = "\\$";

    private HashSet<String> unoverridableStringSet;
    private HashMap<String, BiFunction<String, ManagerHolder, Command>> defaultMap;
    private HashMap<String, String> customMap;

    public AliasStorage() {
        defaultMap = new HashMap<>();
        customMap = new HashMap<>();
        unoverridableStringSet = new HashSet<>();

        initialiseUnoverriableStrings();
        initialiseDefaultCommands();
    }

    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#getDefaultCommand(java.lang.String)
     */
    @Override
    public BiFunction<String, ManagerHolder, Command> getDefaultCommand(
            String commandString) {

        BiFunction<String, ManagerHolder, Command> makeCommandFunction;

        makeCommandFunction = defaultMap.get(commandString);
        if (makeCommandFunction == null) {
            return defaultMakeCommand(commandString);
        } else {
            return makeCommandFunction;
        }
    }

    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#getCustomCommand(java.lang.String)
     */
    @Override
    public String getCustomCommand(String commandString) {
        return customMap.get(commandString);
    }

    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#createCustomCommand(java.lang.String, java.lang.String)
     */
    @Override
    public String createCustomCommand(String alias, String replacement) {
        assert canOverride(alias);

        String[] keywords = replacement.split(" ", 2);
        String value;
        if (keywords.length == 1) {
            value = keywords[0] + " " + VARIABLE_STRING;
        } else {
            value = replacement;
        }

        put(alias, value);
        return value;
    }
    
    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#canOverride(java.lang.String)
     */
    @Override
    public boolean canOverride(String alias) {
        return !unoverridableStringSet.contains(alias);
    }
    
    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#deleteCustomCommand(java.lang.String)
     */
    @Override
    public String deleteCustomCommand(String alias) {
        return customMap.remove(alias);
    }

    
    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorage#isAlreadyBinded(java.lang.String)
     */
    @Override
    public boolean isAlreadyBinded(String alias) {
        boolean alreadyBinded = customMap.containsKey(alias) ||
                defaultMap.containsKey(alias);        
        return alreadyBinded;
    }
    
    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorageFileInputOutput#getAllCustomAliases()
     */
    @Override
    public AliasValuePair[] getAllCustomAliases() {
        AliasValuePair[] aliases = new AliasValuePair[customMap.size()];
        Set<Map.Entry<String, String>> entrySet = customMap.entrySet();

        int index = 0;
        for (Map.Entry<String, String> entry : entrySet) {
            String alias = entry.getKey();
            String value = entry.getValue();
            aliases[index] = new AliasValuePair(alias, value);
            index++;
        }
        
        return aliases;
    }
    
    /* (non-Javadoc)
     * @see main.command.alias.IAliasStorageFileInputOutput#setAllCustomAliases(main.command.alias.AliasValuePair[])
     */
    @Override
    public boolean setAllCustomAliases(AliasValuePair[] aliases) {
        HashMap<String, String> backupCustomMap = customMap;
        customMap = new HashMap<>();

        boolean successful = tryPutAllCustomAliases(aliases);
        
        if (successful) {
            return true;
        } else {
            customMap = backupCustomMap;
            return false;
        }
    }


    @Override
    public String[] getAllBindedStrings() {
        int totalSize = customMap.size() + defaultMap.size();
        HashSet<String> stringSet = new HashSet<>(totalSize);
        
        Set<String> customSet = customMap.keySet();
        Set<String> defaultSet = defaultMap.keySet();

        stringSet.addAll(customSet);
        stringSet.addAll(defaultSet);
        
        return stringSet.toArray(new String[0]);
    }

    private boolean tryPutAllCustomAliases(AliasValuePair[] aliases) {
        for (AliasValuePair aliasValuePair : aliases) {
            String alias = aliasValuePair.alias;
            String value = aliasValuePair.value;
            
            if (canOverride(alias)) {
                put(alias, value);
            } else {
                return false;
            }
        }
        return true;
    }

    /**
     * Returns the default command that is executed when the command string fits
     * none of the other commands.
     * @param input the first token of the input string.
     * @return an ArgumentCommand, which is the default command.
     */
    private BiFunction<String, ManagerHolder, Command> defaultMakeCommand(
            String input) {

        return (args, managerHolder) ->
                new ArgumentCommand(input + " " + args, managerHolder);
    }

    
    /**
     * Initialise all the default commands in taskline here.
     */
    private void initialiseDefaultCommands() {

        defineDefaultCommands(
                (args, managerHolder) -> new AddCommand(args, managerHolder),
                "add", "create");

        defineDefaultCommands(
                (args, managerHolder) -> new SearchCommand(args, managerHolder),
                "show", "search", "list", "view", "tasks");

        defineDefaultCommands(
                (args, managerHolder) -> new EditCommand(args, managerHolder),
                "edit", "set", "modify", "change");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.MARK),
                "mark", "done");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.UNMARK),
                "unmark");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.STATUS),
                "status");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.PRIORITY),
                "priority");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.URGENT),
                "urgent");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.RESCHEDULE),
                "reschedule", "time", "date", "datetime");

        defineDefaultCommands(
                (args, managerHolder) ->
                new EditCommand(args, managerHolder, ParseType.RENAME),
                "rename", "name");

        defineDefaultCommands(
                (args, managerHolder) -> new UndoCommand(args, managerHolder),
                "undo");

        defineDefaultCommands(
                (args, managerHolder) -> new RedoCommand(args, managerHolder),
                "redo");

        defineDefaultCommands(
                (args, managerHolder) -> new ReportCommand(managerHolder),
                "report");

        defineDefaultCommands(
                (args, managerHolder) ->
                new FreeDaySearchCommand(args, managerHolder),
                "freeday", "freedays", "freedate", "freedates");

        defineDefaultCommands(
                (args, managerHolder) ->
                new FreeTimeSearchCommand(args, managerHolder),
                "freetime", "freeslot");

        defineDefaultCommands(
                (args, managerHolder) -> new DeleteCommand(args, managerHolder),
                "delete", "del", "remove", "rm");

        defineDefaultCommands(
                (args, managerHolder) -> new DetailsCommand(args, managerHolder),
                "detail", "details", "info");

        defineDefaultCommands(
                (args, managerHolder) -> new BackCommand(managerHolder),
                "back", "return");

        defineDefaultCommands(
                (args, managerHolder) -> new ExitCommand(managerHolder),
                "quit", "exit");

        defineDefaultCommands(
                (args, managerHolder) -> new AliasCommand(args, managerHolder),
                "alias", "custom", "bind");

        defineDefaultCommands(
                (args, managerHolder) -> new AliasDeleteCommand(args, managerHolder),
                "unalias", "unbind");

        defineDefaultCommands(
                (args, managerHolder) -> new ViewAliasCommand(managerHolder),
                "aliases", "viewalias", "viewaliases");

    }

    private void initialiseUnoverriableStrings() {
        unoverridableStringSet.add("custom");
        unoverridableStringSet.add("alias");
        unoverridableStringSet.add("unalias");
        unoverridableStringSet.add("bind");
        unoverridableStringSet.add("unbind");
    }

    private void defineDefaultCommands(
            BiFunction<String, ManagerHolder, Command> commandFunction,
            String... commandStrings) {

        for (String commandString : commandStrings) {
            assert !commandString.contains(" ") : "Error in command: [" +
                    commandString + "] - Command cannot have multiple words.";
            defaultMap.put(commandString, commandFunction);
        }
    }
    
    private void put(String alias, String value) {
        customMap.put(alias, value);
    }
}

	// End of segment: src\main\command\alias\AliasStorage.java





	/**
	 * origin: src\main\command\alias\AliasValuePair.java
	 */

/**
 * Contains an alias and the value it is mapped to.<br>
 * e.g. if "hp" is mapped to "edit \$ priority high", then we have:<br>
 * alias = "hp"<br>
 * value = "edit \$ priority high"<br>
 * <br>
 * Immutable
 */
public class AliasValuePair {
    public final String alias;
    public final String value;
    
    public AliasValuePair(String alias, String value) {
        this.alias = alias;
        this.value = value;
    }
}

	// End of segment: src\main\command\alias\AliasValuePair.java





	/**
	 * origin: src\main\command\alias\IAliasStorage.java
	 */

/**
 * The interface used for setting and retrieving aliases from AliasStorage.
 */
public interface IAliasStorage {

    public abstract BiFunction<String, ManagerHolder, Command> getDefaultCommand(
            String commandString);

    public abstract String getCustomCommand(String commandString);

    /**
     * @param alias from this keyword (must be one word)
     * @param replacement to this string
     * @return the string the alias is binded to.
     */
    public abstract String createCustomCommand(String alias, String replacement);

    /**
     * @param alias alias string to test.
     * @return true iff this alias is overridable. (e.g. custom is not
     * overridable)
     */
    public abstract boolean canOverride(String alias);

    /**
     * @param alias delete the custom command that uses this alias
     * @return the value the alias is binded to. Returns null iff alias did
     * not originally exist
     */
    public abstract String deleteCustomCommand(String alias);

    /**
     * @param alias check this alias (key).
     * @return true iff the alias is already binded to something
     */
    public abstract boolean isAlreadyBinded(String alias);

    /**
     * @return Get the entire list of custom aliases.
     */
    public abstract AliasValuePair[] getAllCustomAliases();
}
	// End of segment: src\main\command\alias\IAliasStorage.java





	/**
	 * origin: src\main\command\alias\IAliasStorageFileInputOutput.java
	 */

/**
 * The interface used by File IO to synchronise the aliases in memory with an
 * external file.
 */
public interface IAliasStorageFileInputOutput {

    /**
     * @return Get the entire list of custom aliases.
     */
    public abstract AliasValuePair[] getAllCustomAliases();

    /**
     * @return Get the entire list of default and custom aliases.
     */
    public abstract String[] getAllBindedStrings();

    /**
     * Registers a custom command, alias is assumed to be overridable.
     *
     * @param aliases Overwrites the original set of custom aliases with these.
     * @return true if successful. If unsuccessful, no change will be made to
     * AliasStorage.
     */
    public abstract boolean setAllCustomAliases(AliasValuePair[] aliases);

}
	// End of segment: src\main\command\alias\IAliasStorageFileInputOutput.java





	/**
	 * origin: src\main\command\AliasCommand.java
	 */

public class AliasCommand extends Command {

    private final AliasManager aliasManager;
    private String alias;
    private String value;
    
    public AliasCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        aliasManager = managerHolder.getAliasManager();
                
        parse(args);
    }
    
    private void parse(String args) {
        String[] tokens = args.split(" ", 2);
        if (tokens.length < 2) {
            alias = null;
            return;
        } else {
            alias = tokens[0];
            value = tokens[1];
        }
    }

    @Override
    protected boolean isValidArguments() {
        return (alias != null);
    }

    @Override
    protected boolean isCommandAllowed() {
        return true;
    }

    @Override
    protected Result executeAction() {
        Result result = aliasManager.createAlias(alias, value);
        return result;
    }

}

	// End of segment: src\main\command\AliasCommand.java





	/**
	 * origin: src\main\command\AliasDeleteCommand.java
	 */

public class AliasDeleteCommand extends Command {

    private final AliasManager aliasManager;
    private String alias;
    
    public AliasDeleteCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        aliasManager = managerHolder.getAliasManager();
                
        parse(args);
    }
    
    private void parse(String args) {
        alias = args;
    }

    @Override
    protected boolean isValidArguments() {
        return (alias != null && alias.length() != 0);
    }

    @Override
    protected boolean isCommandAllowed() {
        return true;
    }

    @Override
    protected Result executeAction() {
        Result result = aliasManager.deleteAlias(alias);
        return result;
    }

}

	// End of segment: src\main\command\AliasDeleteCommand.java





	/**
	 * origin: src\main\command\ArgumentCommand.java
	 */

public class ArgumentCommand extends TargetedCommand {

    public ArgumentCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        parse(args);
    }

    private void parse(String args) {
        String remaining = tryParseIdsIntoSet(args);
        if (remaining.length() > 0) {
            targetTaskIdSet = null;
        }
    }
    
    @Override
    public Response execute() {
        if (!isValidArguments()) {
            return updateInvalidCommand();
        }
        
        if (!isCommandAllowed()) {
            return updateCannotExecuteCommand();
        }

        TargetedCommand command = stateManager.retrieveStoredCommand();
        command.setTargets(targetTaskIdSet);
        
        return command.execute();
    }

    @Override
    protected boolean isValidArguments() {
        return targetTaskIdSet != null;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.isWaitingForArguments();
    }

    @Override
    protected Result executeAction() {
        assert false : "This method is not supported.";
        throw new UnsupportedOperationException("This method is not supported.");
    }
    
}

	// End of segment: src\main\command\ArgumentCommand.java





	/**
	 * origin: src\main\command\BackCommand.java
	 */

public class BackCommand extends Command {
    
    public BackCommand (ManagerHolder managerHolder) {
        super(managerHolder);
    }

    @Override
    protected boolean isValidArguments() {
        return true;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canGoBack();
    }

    @Override
    protected Result executeAction() {
        Result result = new SimpleResult(Result.Type.GO_BACK);
        return result;
    }
}

	// End of segment: src\main\command\BackCommand.java





	/**
	 * origin: src\main\command\Command.java
	 */

/**
 * The base Command class.<br>
 * All commands should extend this class.<br>
 * Overwrite the isValidArguments(), isCommandAllowed() and executeAction() to
 * implement the command's functionality.<br>
 * <br>
 * If you wish for the command to be executed on existing tasks, try extending
 * TargetedCommand, which extends this class, instead.
 */
public abstract class Command {
    protected final StateManager stateManager;
    
    public Command(ManagerHolder managerHolder) {
        stateManager = managerHolder.getStateManager();
        stateManager.beforeCommandUpdate();
    }


    public Response execute() {
        if (!isValidArguments()) {
            return updateInvalidArguments();
        }
        
        if (isCommandAllowed()) {
            Result result = executeAction();
            Response response = stateManager.update(result);
            return response;
            
        } else {
            return updateCannotExecuteCommand();
        }
    }

    protected Response updateInvalidArguments() {
        Result result = new SimpleResult(Result.Type.INVALID_ARGUMENT);
        Response response = stateManager.update(result);
        return response;
    }

    protected Response updateCannotExecuteCommand() {
        EnumMessage message = EnumMessage.cannotExecuteCommand();
        EmptyModeInfo modeInfo = new EmptyModeInfo();
        return new Response(message, modeInfo);
    }

    protected Response updateInvalidCommand() {
        Result result = new SimpleResult(Result.Type.INVALID_COMMAND);
        Response response = stateManager.update(result);
        return response;
    }
    
    /**
     * If the parsing parsed something invalid, (e.g. delete with no tasks
     * specified), make this return false. This will cause the program to
     * print an "invalid arguments" message to the user.
     * @return true iff the arguments parse into something that's valid.
     */
    protected abstract boolean isValidArguments();
    /**
     * This is the check with the StateManager for clearance to use the
     * command.<br>
     * e.g. for add command, this will look like:<br>
     * return stateManager.canAdd();
     * @return true iff StateManager approves the execution of the command.
     */
    protected abstract boolean isCommandAllowed();
    /**
     * The command's functionality should be written here. Make the necessary
     * calls to the managers involved here. Get the execution result from the
     * manager.
     * @return a result, which will automatically be used to update the
     * StateManager.
     */
    protected abstract Result executeAction();
}
	// End of segment: src\main\command\Command.java





	/**
	 * origin: src\main\command\CommandController.java
	 */

/**
 * Handles the parsing of commands.
 * Commands are returned to MainController for execution.
 */
public class CommandController {
    private ManagerHolder managerHolder;
    private AliasController aliasController;

    public CommandController(ManagerHolder managerHolder,
            IAliasStorage aliasStorage, IFileInputOutput aliasFileInputOutput) {
        this.managerHolder = managerHolder;
        aliasController = new AliasController(aliasStorage, aliasFileInputOutput);
    }

    /**
     * Retrieves a command object given an input string.<br>
     * The default command bindings are stored in
     * AliasStorage.initialiseDefaultCommands()
     *
     * @param commandString the input string
     * @return a Command object that is ready to be executed.
     */
    public Command getCommand(String commandString) {

        commandString = aliasController.replaceAlias(commandString);

        String[] split = commandString.split(" ", 2);
        String commandType = extractFirstToken(split);
        String arguments = extractSecondToken(split);

        BiFunction<String, ManagerHolder, Command> makeCommand;
        makeCommand = aliasController.getReservedCommand(commandType);

        Command command = makeCommand.apply(arguments, managerHolder);

        return command;
    }

    protected String extractSecondToken(String[] split) {
        String arguments = "";
        if (split.length >= 2) {
            assert split.length == 2;
            arguments = split[1];
        }
        return arguments;
    }

    protected String extractFirstToken(String[] split) {
        String commandType = "";
        if (split.length >= 1) {
            commandType = split[0];
        }
        return commandType;
    }
}

	// End of segment: src\main\command\CommandController.java





	/**
	 * origin: src\main\command\DeleteCommand.java
	 */

public class DeleteCommand extends TargetedCommand {
    private final DeleteManager deleteManager;

    public DeleteCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        deleteManager = managerHolder.getDeleteManager();
        
        parse(args);
    }

    private void parse(String args) {
        String remaining = tryParseIdsIntoSet(args);
        if (remaining.length() > 0) {
            targetTaskIdSet = null;
        }
        if (targetTaskIdSet == null) {
            parseAsSearchString(args);
        }
    }
    
    @Override
    protected boolean isValidArguments() {
        return targetTaskIdSet != null;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canDelete();
    }

    @Override
    protected Result executeAction() {
        Result result = deleteManager.deleteTask(targetTaskIdSet);
        return result;
    }

}

	// End of segment: src\main\command\DeleteCommand.java





	/**
	 * origin: src\main\command\DetailsCommand.java
	 */

public class DetailsCommand extends TargetedCommand {
    private final SearchManager searchManager;

    public DetailsCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        searchManager = managerHolder.getSearchManager();

        parse(args);
    }

    private void parse(String args) {
        String remaining = tryParseIdsIntoSet(args);
        if (remaining.length() > 0) {
            targetTaskIdSet = null;
        }
        if (targetTaskIdSet == null) {
            parseAsSearchString(args);
        }
    }

    @Override
    protected boolean isValidArguments() {
        return targetTaskIdSet != null;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canSearch();
    }

    @Override
    protected Result executeAction() {
        Result result = searchManager.details(targetTaskIdSet);
        return result;
    }

}

	// End of segment: src\main\command\DetailsCommand.java





	/**
	 * origin: src\main\command\EditCommand.java
	 */

public class EditCommand extends TargetedCommand {
    private static final String ARGUMENT_CLEAR = "clear";
    private static final String ARGUMENT_DESCRIPTION = "details";
    private static final String ARGUMENT_DESCRIPTION_2 = "description";
    private static final String ARGUMENT_DATE = "date";
    private static final String ARGUMENT_TIME = "time";
    private static final String ARGUMENT_TAG = "tag";
    private static final String ARGUMENT_TAG_2 = "tags";
    private static final String ARGUMENT_PRIORITY = "priority";
    private static final String ARGUMENT_NAME = "name";
    private static final String ARGUMENT_DATETIME = "datetime";
    private static final String ARGUMENT_STATUS = "status";
    private static final String ARGUMENT_ADD = "add";
    private static final String ARGUMENT_DELETE = "del";
    private static final String ARGUMENT_DELETE_2 = "delete";

    private final EditManager editManager;
    private TaskInfo taskToEdit;
    private Operation specialOperation = Operation.NONE;
    private Info infoToClear = null;
    private final ParseType parseType;

    private enum Operation {
        NONE,
        EDIT_MODE,
        TAG_ADD,
        TAG_DELETE,
        CLEAR_INFO
    }

    public enum Info {
        DATE,
        TIME,
        DATETIME,
        PRIORITY,
        STATUS,
        DESCRIPTION,
        TAGS
    }

    public enum ParseType {
        NORMAL,
        MARK,
        UNMARK,
        STATUS,
        RESCHEDULE,
        PRIORITY,
        URGENT,
        RENAME
    }

    public EditCommand(String args, ManagerHolder managerHolder)
            throws NoSuchElementException {
        super(managerHolder);
        editManager = managerHolder.getEditManager();

        this.parseType = ParseType.NORMAL;
        parse(args);
    }


    public EditCommand(String args, ManagerHolder managerHolder, ParseType parseType) {
        super(managerHolder);
        editManager = managerHolder.getEditManager();

        this.parseType = parseType;
        parse(args);
    }

    private void parse(String args) {
        if (stateManager.inEditMode()) {
            // edit mode
            targetTaskIdSet = editManager.getEditingTasks();
            taskToEdit = parseCommandParams(args);
        } else {
            // not edit mode
            args = tryParseIdsIntoSet(args);
            if (targetTaskIdSet == null) {
                taskToEdit = parseKeywordAndEditParams(args);
            } else {
                taskToEdit = parseCommandParams(args);
            }
        }
    }

    private TaskInfo parseKeywordAndEditParams(String args) {
        StringBuilder keywords = new StringBuilder();

        TaskInfo taskInfo = parseCommandParams(args);
        while (!args.isEmpty() && (taskInfo == null || keywords.length() == 0)) {
            String[] split = args.split(" ", 2);
            keywords.append(split[0]).append(" ");

            if (split.length > 1) {
                args = split[1];
                taskInfo = parseCommandParams(args);
            } else {
                args = "";
            }
        }

        taskInfo = parseCommandParams(args);
        parseAsSearchString(keywords.toString());
        return taskInfo;
    }


    private TaskInfo parseCommandParams(String args) {
        assert args != null : "There should not be a null passed in.";

        switch (parseType) {
            case NORMAL :
                return parseEditParams(args);
            case MARK :
                return parseMarkParams(args);
            case UNMARK :
                return parseUnmarkParams(args);
            case STATUS :
                return parseStatusParams(args);
            case RESCHEDULE :
                return parseRescheduleParams(args);
            case PRIORITY :
                return parsePriorityParams(args);
            case URGENT :
                return parseUrgentParams(args);
            case RENAME :
                return parseRenameParams(args);
            default :
                throw new UnsupportedOperationException("Unknown Parse Type: " +
                        parseType.name());
        }
    }

    private TaskInfo parseMarkParams(String args) {
        TaskInfo taskInfo = TaskInfo.createEmpty();

        args = args.trim();
        if (args.length() == 0) {
            taskInfo.status = Status.DONE;
            return taskInfo;
        }

        return parseEditParams(ARGUMENT_STATUS + " " + args);
    }

    private TaskInfo parseUnmarkParams(String args) {
        TaskInfo taskInfo = TaskInfo.createEmpty();

        args = args.trim();
        if (args.length() == 0) {
            taskInfo.status = Status.UNDONE;
            return taskInfo;
        }
        return null;
    }

    private TaskInfo parseStatusParams(String args) {
        return parseEditParams(ARGUMENT_STATUS + " " + args);
    }

    private TaskInfo parseRescheduleParams(String args) {
        return parseEditParams(ARGUMENT_DATETIME + " " + args);
    }

    private TaskInfo parsePriorityParams(String args) {
        return parseEditParams(ARGUMENT_PRIORITY + " " + args);
    }

    private TaskInfo parseUrgentParams(String args) {
        TaskInfo taskInfo = TaskInfo.createEmpty();

        args = args.trim();
        if (args.length() == 0) {
            taskInfo.priority = Priority.HIGH;
            return taskInfo;
        }
        return null;
    }

    private TaskInfo parseRenameParams(String args) {
        return parseEditParams(ARGUMENT_NAME + " " + args);
    }

	// End of segment: src\main\command\EditCommand.java





	/**
	 * origin: src\main\command\EditCommand.java
	 */

            case ARGUMENT_CLEAR :
                if (clearInfo(editParam)) {
                    setSpecialOperation(Operation.CLEAR_INFO);
                    editTask = TaskInfo.createEmpty();
                } else {
                    editTask = null;
                }
                break;
	// End of segment: src\main\command\EditCommand.java





	/**
	 * origin: src\main\command\EditCommand.java
	 */

    protected void tryChangeToStartEditModeCommand() {
        if (parseType == ParseType.NORMAL && taskToEdit == null) {
            setSpecialOperation(Operation.EDIT_MODE);
        }
    }

	// End of segment: src\main\command\EditCommand.java





	/**
	 * origin: src\main\command\EditCommand.java
	 */

    private boolean clearInfo(String info) {
        info = info.trim();
        switch(info) {
            case ARGUMENT_DESCRIPTION :
            case ARGUMENT_DESCRIPTION_2 :
                infoToClear = Info.DESCRIPTION;
                break;
            case ARGUMENT_DATE :
                infoToClear = Info.DATE;
                break;
            case ARGUMENT_TIME :
                infoToClear = Info.TIME;
                break;
            case ARGUMENT_DATETIME :
                infoToClear = Info.DATETIME;
                break;
            case ARGUMENT_TAG :
            case ARGUMENT_TAG_2 :
                infoToClear = Info.TAGS;
                break;
            case ARGUMENT_PRIORITY :
                infoToClear = Info.PRIORITY;
                break;
            case ARGUMENT_STATUS :
                infoToClear = Info.STATUS;
                break;
        }

        return (infoToClear != null);
    }

    private void setSpecialOperation(Operation operation) {
        specialOperation = operation;
    }

    public TaskId convertStringtoTaskId(String stringId){
    	return TaskId.makeTaskId(stringId);
    }

    @Override
    protected boolean isValidArguments() {
        if (specialOperation != Operation.EDIT_MODE &&
                specialOperation != Operation.CLEAR_INFO) {

            if (taskToEdit == null || taskToEdit.isEmpty()) {
                return false;
            }
        }
        return targetTaskIdSet != null;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canEdit();
    }

    @Override
    protected Result executeAction() {
        Result result;

        switch (specialOperation) {
            case EDIT_MODE :
                assert taskToEdit == null;
                result = editManager.startEditMode(targetTaskIdSet);
                break;
            case CLEAR_INFO :
                assert taskToEdit.isEmpty();
                assert infoToClear != null;
                result = editManager.clearInfo(targetTaskIdSet, infoToClear);
                break;
            case NONE :
                assert taskToEdit != null;
                result = editManager.editTask(taskToEdit, targetTaskIdSet);
                break;
            case TAG_ADD :
                assert taskToEdit != null;
                result = editManager.addTaskTags(taskToEdit.tags, targetTaskIdSet);
                break;
            case TAG_DELETE :
                assert taskToEdit != null;
                result = editManager.deleteTaskTags(taskToEdit.tags, targetTaskIdSet);
                break;
            default :
                throw new UnsupportedOperationException("Invalid operation: " +
                        specialOperation.name());
        }

        return result;
    }

}

	// End of segment: src\main\command\EditCommand.java





	/**
	 * origin: src\main\command\ExitCommand.java
	 */

public class ExitCommand extends Command {

    public ExitCommand(ManagerHolder managerHolder) {
        super(managerHolder);
    }

    @Override
    protected boolean isValidArguments() {
        return true;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canExit();
    }

    @Override
    protected Result executeAction() {
        return new SimpleResult(Result.Type.EXIT);
    }

}

	// End of segment: src\main\command\ExitCommand.java





	/**
	 * origin: src\main\command\FreeDaySearchCommand.java
	 */

public class FreeDaySearchCommand extends Command {
    private FreeDaySearchManager freeDaySearchManager;
    private DateTimePair dateTimePair;

    public FreeDaySearchCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        this.freeDaySearchManager = managerHolder.getFreeDaySearchManager();
        parse(args);
    }

    private void parse(String args) {
        dateTimePair = CommandParser.parseDateTimes(args);
    }

    @Override
    protected boolean isValidArguments() {
        if (dateTimePair == null) {
            return false;
        }
        if (!dateTimePair.hasFirstDate() || !dateTimePair.hasSecondDate()) {
            return false;
        }
        if (dateTimePair.hasFirstTime() != dateTimePair.hasSecondTime()) {
            return false;
        }
        if (dateTimePair.getFirstDate().isAfter(dateTimePair.getSecondDate())) {
            return false;
        }
        if (dateTimePair.hasFirstTime()) {
            if (dateTimePair.getFirstTime().isAfter(dateTimePair.getSecondTime())) {
                return false;
            }
        }
        
        return true;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canSearch();
    }

    @Override
    protected Result executeAction() {
        if (dateTimePair.hasFirstTime()) {
            return freeDaySearchManager.searchFreeDay(
                    dateTimePair.getFirstTime(),
                    dateTimePair.getFirstDate(),
                    dateTimePair.getSecondTime(),
                    dateTimePair.getSecondDate());
        } else {
            return freeDaySearchManager.searchFreeDay(
                    dateTimePair.getFirstDate(),
                    dateTimePair.getSecondDate());
        }
    }

}

	// End of segment: src\main\command\FreeDaySearchCommand.java





	/**
	 * origin: src\main\command\FreeTimeSearchCommand.java
	 */

public class FreeTimeSearchCommand extends Command {

	private FreeTimeSearchManager freeTimeSearchManager;
	private LocalDate date;
	
	public FreeTimeSearchCommand(String args, ManagerHolder managerHolder) {
		super(managerHolder);
		this.freeTimeSearchManager = managerHolder.getFreeTimeSearchManager();
		parse(args);
	}
	
	private void parse(String args) {
		DateTimePair dateTimePair = CommandParser.parseDateTimes(args);
		
		if (dateTimePair.getNumOfDates() == 1 && 
		        dateTimePair.getNumOfTimes() == 0) {
		    
		    assert dateTimePair.getSecondDate() == null;
		    date = dateTimePair.getFirstDate();
		} else {
		    date = null;
		}
	}

	@Override
	protected boolean isValidArguments() {
	    return date != null;
	}

	@Override
	protected boolean isCommandAllowed() {
	    return stateManager.canSearch();
	}

	@Override
	protected Result executeAction() {
	    Result result = freeTimeSearchManager.searchFreeTimeSlot(date);
	    return result;
	}
	
}

	// End of segment: src\main\command\FreeTimeSearchCommand.java





	/**
	 * origin: src\main\command\parser\test\CommandParserTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    CommandParserTest.class,
    DateTimeParserTest.class
})
public class CommandParserTestSuite {

}
	// End of segment: src\main\command\parser\test\CommandParserTestSuite.java





	/**
	 * origin: src\main\command\ReportCommand.java
	 */

public class ReportCommand extends Command {
    private final ReportManager reportManager;

    public ReportCommand(ManagerHolder managerHolder) {
        super(managerHolder);
        reportManager = managerHolder.getReportManager();
    }

    @Override
    protected boolean isValidArguments() {
        return true;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canGetReport();
    }

    @Override
    protected Result executeAction() {
        Result result = reportManager.report();
        return result;
    }

}

	// End of segment: src\main\command\ReportCommand.java





	/**
	 * origin: src\main\command\TargetedCommand.java
	 */

/**
 * Any command that "acts" on existing tasks should extend TargetedCommand.<br>
 * TargetedCommand gives the functionality to parse task numbers, absolute task
 * Ids, and to act on tasks by specifying keywords.
 * (e.g. delete orange juice)
 * Examples: edit, delete.
 */
public abstract class TargetedCommand extends Command {

    private static final char DELIMITER_WHITESPACE = ' ';
    private static final char DELIMITER_COMMA = ',';
    private static final char DELIMITER_DASH = '-';
    private static final String DELIMITER_DASH_STRING = "-";

    private final SearchManager searchManager;
    
    protected TaskIdSet targetTaskIdSet;
    protected KeywordFilter keywordFilter;

    public TargetedCommand(ManagerHolder managerHolder) {
        super(managerHolder);
        searchManager = managerHolder.getSearchManager();
    }

    @Override
    public Response execute() {
        if (targetTaskIdSet == null) {
            if (keywordFilter == null) {
                return updateInvalidArguments();
            } else {
                return keywordFilterExecute();
            }
        } else {
            assert keywordFilter == null;
            return super.execute();
        }
    }

    /**
     * Add target taskIds to a stored TargetedCommand, so that the command
     * will be executed on these taskIds.
     * @param taskIds the taskIds to be added.
     */
    public void setTargets(TaskIdSet taskIdSet){
        this.targetTaskIdSet = taskIdSet;
    }

    /**
     * Attempts to parse a String containing Task IDs into the targetTaskIdSet.
     * targetTaskIdSet will be set to null if this is unsuccessful.
     * @param args A string that possibly specifies task IDs. The task IDs
     * should be at the front of the string.
     * @return The remaining string that after cutting out the task ids.<br>
     * returns the original string if parsing is unsuccessful.
     */
    protected String tryParseIdsIntoSet(String args) {
        targetTaskIdSet = new TaskIdSet();
        try {
            String remainingArgs = parseIdsIntoSet(args);
            return remainingArgs;

        } catch (IllegalArgumentException e) {
            targetTaskIdSet = null;
            return args;
        }
    }

    /**
     * Parse a string as a substitute for Task IDs and make this command
     * execute a search instead, and store itself in StateManager for later
     * execution by the confirmation.
     * @param searchString
     */
    protected void parseAsSearchString(String searchString) {
        assert targetTaskIdSet == null : "targetTaskIdSet needs to be null";

        searchString = CommandParser.stripIgnoreSymbols(searchString);
        if (!searchString.isEmpty()) {
            String[] keywords = searchString.split(" ");
            keywordFilter = new KeywordFilter(keywords);
        }
    }

    /**
     * @param args String form of task ID. Can be relative or absolute.
     * @return a TaskId object corresponding to the relative or absolute id.<br>
     * null if it is unsuccessful. (e.g. not in search mode for relative ids).
     */
    private TaskId parseTaskId(String args) {
        assert args != null : "There should not be a null passed in.";
        if (args.isEmpty()) {
            return null;
        }

        try {
            int relativeTaskId = Integer.parseInt(args);
            return retrieveAbsoluteTaskId(relativeTaskId);
        } catch (NumberFormatException e) {
            String absoluteTaskId = args;
            TaskId taskId = TaskId.makeTaskId(absoluteTaskId);
            if (taskId != null && searchManager.getTaskInfo(taskId) != null) {
                return taskId;
            } else {
                return null;
            }
        }
    }


    private String parseIdsIntoSet(String args) throws IllegalArgumentException{
        int currentIndex = 0;
        int tokenStart = currentIndex;

        boolean readingCharacters = false;
        boolean lastTokenHadDelimiter = true;
        LinkedList<String> idStrings = new LinkedList<>();

        while (currentIndex < args.length()) {
            char c = args.charAt(currentIndex);

            if (c == DELIMITER_COMMA) {
                idStrings.add(args.substring(tokenStart, currentIndex));
                tokenStart = currentIndex+1;
                lastTokenHadDelimiter = true;
                readingCharacters = false;

            } else if (c == DELIMITER_DASH) {
                lastTokenHadDelimiter = true;
                readingCharacters = false;

            } else if (c == DELIMITER_WHITESPACE) {
                readingCharacters = false;

            } else {
                if (!readingCharacters && !lastTokenHadDelimiter) {
                    break;
                }
                lastTokenHadDelimiter = false;
                readingCharacters = true;
            }
            currentIndex++;
        }

        idStrings.add(args.substring(tokenStart, currentIndex));
        parseStringsIntoSet(idStrings);
        return args.substring(currentIndex);
    }

    private void parseStringsIntoSet(LinkedList<String> idStrings) {
        for (String idString : idStrings) {
            ensureIdStringLength(idString);

            String[] args = idString.split(DELIMITER_DASH_STRING);
            if (args.length == 1) {
                addToSet(args[0]);
            } else if (args.length == 2) {
                addToSet(args[0], args[1]);
            } else {
                throw new IllegalArgumentException("Invalid string");
            }
        }
    }

    private void ensureIdStringLength(String idString) {
        if (idString.length() == 0 ||
                idString.charAt(idString.length()-1) == DELIMITER_DASH) {
            throw new IllegalArgumentException("Invalid string");
        }
    }

    private void addToSet(String arg) {
        TaskId taskId = parseTaskId(arg.trim());
        if (taskId == null) {
            throw new IllegalArgumentException("Invalid task Id");
        }
        targetTaskIdSet.add(taskId);
    }

    private void addToSet(String arg1, String arg2) {
        int rangeStart, rangeEnd;

        try {
            rangeStart = Integer.parseInt(arg1.trim());
            rangeEnd = Integer.parseInt(arg2.trim());
        } catch (NumberFormatException e) {
            throw new IllegalArgumentException("Invalid string");
        }

        if (rangeEnd < rangeStart) {
            throw new IllegalArgumentException("Invalid range");
        }

        for (int i = rangeStart; i <= rangeEnd; i++) {
            TaskId taskId = retrieveAbsoluteTaskId(i);
            if (taskId == null) {
                throw new IllegalArgumentException("Invalid range");
            }
            targetTaskIdSet.add(taskId);
        }
    }

    private TaskId retrieveAbsoluteTaskId(int relativeTaskId) {
        if (stateManager.canQuerySearchManager()) {
            try {
                TaskId result = searchManager.getAbsoluteIndex(relativeTaskId);
                return result;
            } catch (IndexOutOfBoundsException e) {
                return null;
            }
        } else {
            return null;
        }
    }

    /**
     * This is used to execute the command using a keyword filter instead
     * of a target TaskIdSet. (aka delete by name)
     * @return
     */
    private Response keywordFilterExecute() {
        if (isCommandAllowed() && stateManager.canSearch()) {
            Filter[] filters = new Filter[]{keywordFilter};
            keywordFilter = null;

            Result result = searchManager.searchTasksWithoutSplit(filters);
            Response response = null;
            if (onlyOneSearchResult(result)) {
                response = executeOnSearchResult(result);
            } else {
                response = stateManager.updateAndStoreCommand(result, this);
            }
            return response;

        } else {
            return updateCannotExecuteCommand();
        }
    }

    private boolean onlyOneSearchResult(Result result) {
        if (result.getType() != Result.Type.SEARCH_SUCCESS) {
            return false;
        }
        SearchResult searchResult = (SearchResult)result;
        return searchResult.onlyOneSearchResult();
    }

    private Response executeOnSearchResult(Result result) {
        assert result.getType() == Result.Type.SEARCH_SUCCESS;
        SearchResult searchResult = (SearchResult)result;

        targetTaskIdSet = new TaskIdSet();
        targetTaskIdSet.add(searchResult.getOnlySearchResult());
        keywordFilter = null;

        return execute();
    }
}

	// End of segment: src\main\command\TargetedCommand.java





	/**
	 * origin: src\main\command\TaskIdSet.java
	 */

/**
 * A set of task IDs that is used for a command operation.
 * 
 */
public class TaskIdSet implements Iterable<TaskId>{
    private ArrayList<TaskId> idList;
    
    public TaskIdSet() {
        idList = new ArrayList<>();
    }

    /**
     * @return a non-modifiable iterator for the TargetIdSet.
     */
    @Override
    public Iterator<TaskId> iterator() {
        final Iterator<TaskId> iterator = idList.iterator();
        return new Iterator<TaskId>() {
            public boolean hasNext(){
                return iterator.hasNext();
            }
            public TaskId next(){
                return iterator.next();
            }
            public void remove(){
                throw new UnsupportedOperationException("You can't remove from this iterator!");
            }
        };
    }
    
    public boolean contains(TaskId taskId) {
        return idList.contains(taskId);
    }
    
    /**
     * Note: will not add repeat values.
     * @param taskId
     * @return true iff there was a change.
     */
    public boolean add(TaskId taskId) {
        if (!idList.contains(taskId)) {
            return idList.add(taskId);
        } else {
            return false;
        }
    }
    
    public int size() {
        return idList.size();
    }
    
    @Override
    public String toString() {
        return idList.toString();
    }
    
    public String numericIdString() {
        StringBuilder sb = new StringBuilder();
        
        String comma = "";
        for (TaskId id : idList) {
            sb.append(comma);
            sb.append(TaskId.toIntId(id.toString()));
            comma = ",";
        }
        return sb.toString();
    }
}

	// End of segment: src\main\command\TaskIdSet.java





	/**
	 * origin: src\main\command\test\CommandTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    TargetedCommandTest.class,
    AddCommandTest.class,
    SearchCommandTest.class,
    EditCommandTest.class
})
public class CommandTestSuite {
}

	// End of segment: src\main\command\test\CommandTestSuite.java





	/**
	 * origin: src\main\command\test\EditCommandTest.java
	 */

public class EditCommandTest {

    @Test
    public void test() {
        ManagerHolder managerHolder = new StubManagerHolder();
        StubEditManager editManager = (StubEditManager)managerHolder.getEditManager();
        StubStateManager stateManager = (StubStateManager)managerHolder.getStateManager();

        stateManager.canEdit = true;
        stateManager.inEditMode = false;
        
        TaskInfo editTaskInfo = TaskInfo.createEmpty();
        
        // Expected: rename 1 to orange.
        executeEdit("1 name orange", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1);
        editTaskInfo.name = "orange";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: rename 1, 4-7 to orange.
        executeEdit("1 , 4 - 7 name orange", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 4, 5, 6, 7);
        editTaskInfo.name = "orange";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: start edit mode on 1, 4-7
        executeEdit("1 , 4 - 7", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.START_EDIT_MODE, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 4, 5, 6, 7);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);

        
        // Expected: invalid arguments.
        executeEdit("2, 4 name", managerHolder);
        assertInvalidArguments(stateManager);


        // Expected: invalid arguments.
        executeEdit("2 oraerkj", managerHolder);
        assertInvalidArguments(stateManager);
        

        // Expected: invalid arguments.
        executeEdit("2 time", managerHolder);
        assertInvalidArguments(stateManager);
        
        // Expected: invalid arguments.
        executeEdit("", managerHolder);
        assertInvalidArguments(stateManager);

        // Expected: search "name orange" and try to start edit mode.
        executeEdit("name orange", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 2, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.START_EDIT_MODE, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        

        // Expected: search "name 1 orange" and try to start edit mode.
        executeEdit("name 1 orange", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 2, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.START_EDIT_MODE, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);

        
        // Expected: search "name" and try to add the tag #name.
        executeEdit("name tag add name", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 2, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.ADD_TASK_TAGS, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        assertNull(editManager.lastTaskInfo);
        assertTags(editManager, "name");

        
        // Expected: delete tag #name from tasks 1 to 3.
        executeEdit("3 - 4 tag delete d", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.DELETE_TASK_TAGS, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 3, 4);
        assertNull(editManager.lastTaskInfo);
        assertTags(editManager, "d");


        
        // Expected: store command - change details to "status priority"
        executeEdit("name details status priority", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 4, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 3, 4);
        editTaskInfo.details = "status priority";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: store command - change status to undone.
        executeEdit("priority status undone", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 3, 4
        executeStoredCommand(stateManager, managerHolder, 1, 4, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 3, 4);
        editTaskInfo.status = Status.UNDONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: store command - change priority to high.
        executeEdit("tag priority high", managerHolder);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] start edit mode on tasks 1, 5
        executeStoredCommand(stateManager, managerHolder, 1, 5);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 5);
        editTaskInfo.priority = Priority.HIGH;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();



        // Expected: search "done" and try to mark it
        executeEdit("done", managerHolder, EditCommand.ParseType.MARK);
        assertStoreCommand(stateManager);


        // Expected: set status of 1 to done.
        executeEdit("1 done", managerHolder, EditCommand.ParseType.MARK);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1);
        editTaskInfo.status = Status.DONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();


        // Expected: set status of 1-3 to done.
        executeEdit("1-3", managerHolder, EditCommand.ParseType.MARK);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        editTaskInfo.status = Status.DONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();


        // Expected: set status of 1, 3 to undone.
        executeEdit("1, 3", managerHolder, EditCommand.ParseType.UNMARK);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 3);
        editTaskInfo.status = Status.UNDONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();



        // Expected: search for "meep" and store command.
        executeEdit("meep", managerHolder, EditCommand.ParseType.UNMARK);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] unmark tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 2, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        editTaskInfo.status = Status.UNDONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: search for "done" and store command.
        executeEdit("done", managerHolder, EditCommand.ParseType.UNMARK);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] unmark tasks 1, 2, 3
        executeStoredCommand(stateManager, managerHolder, 1, 2, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2, 3);
        editTaskInfo.status = Status.UNDONE;
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        
        // Expected: invalid command (trying to unmark 1, 2 as done)
        executeEdit("1, 2 done", managerHolder, EditCommand.ParseType.UNMARK);
        assertInvalidArguments(stateManager);


        // Expected: Reschedule tasks 1, 2 to 2pm.
        executeEdit("1, 2 2pm", managerHolder, EditCommand.ParseType.RESCHEDULE);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2);
        editTaskInfo.endTime = LocalTime.of(14, 0);
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

        // Expected: Store command: reschedule command "orange" to 2pm 14 oct 2012.
        executeEdit("orange 2pm 14 Oct 2012", managerHolder, EditCommand.ParseType.RESCHEDULE);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] reschedule 1 to 2pm 14 oct 2012.
        executeStoredCommand(stateManager, managerHolder, 1);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1);
        editTaskInfo.endTime = LocalTime.of(14, 0);
        editTaskInfo.endDate = LocalDate.of(2012, 10, 14);
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();


        // Expected: Store command: rename task "rename" to rename.
        executeEdit("rename rename", managerHolder, EditCommand.ParseType.RENAME);
        assertStoreCommand(stateManager);

        // Expected: [Stored Command] rename task "rename" to rename.
        executeStoredCommand(stateManager, managerHolder, 1);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1);
        editTaskInfo.name = "rename";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();

    }
    
    @Test
    public void invertedCommaTest() {
        ManagerHolder managerHolder = new StubManagerHolder();
        StubEditManager editManager = (StubEditManager)managerHolder.getEditManager();
        StubStateManager stateManager = (StubStateManager)managerHolder.getStateManager();
        StubSearchManager searchManager = (StubSearchManager)managerHolder.getSearchManager();

        stateManager.canEdit = true;
        stateManager.inEditMode = false;
        
        TaskInfo editTaskInfo = TaskInfo.createEmpty();
        

        // Expected: Store command: search for 1
        executeEdit("\"1\" name 2", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "1");

        // Expected: [Stored Command] rename 3, 4 to "2".
        executeStoredCommand(stateManager, managerHolder, 3, 4);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 3, 4);
        editTaskInfo.name = "2";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();


        // Expected: Store command: start edit mode on "1 name"
        executeEdit("\"1 name\"", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "1", "name");

        // Expected: [Stored Command] start edit mode on "1 name" for 1,3.
        executeStoredCommand(stateManager, managerHolder, 1, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.START_EDIT_MODE, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 3);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);


        // Expected: Invalid command
        executeEdit("1 \"name\"", managerHolder);
        assertInvalidArguments(stateManager);


        // Expected: Invalid command
        executeEdit("1, 2 \"name\"", managerHolder);
        assertInvalidArguments(stateManager);


        // Expected: Rename 1, 2 to orange juice
        executeEdit("1, 2 name \"orange juice\"", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.EDIT_TASK, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2);
        editTaskInfo.name = "orange juice";
        assertEquals(editTaskInfo, editManager.lastTaskInfo);
        editTaskInfo = TaskInfo.createEmpty();


        // Expected: Invalid arguments
        executeEdit("1, 2 time \"tuesday\"", managerHolder);
        assertInvalidArguments(stateManager);
        
    }
    

    @Test
    public void clearTest() {
        ManagerHolder managerHolder = new StubManagerHolder();
        StubEditManager editManager = (StubEditManager)managerHolder.getEditManager();
        StubStateManager stateManager = (StubStateManager)managerHolder.getStateManager();
        StubSearchManager searchManager = (StubSearchManager)managerHolder.getSearchManager();

        stateManager.canEdit = true;
        stateManager.inEditMode = false;
        

        // Expected: Clear tags
        executeEdit("1, 2 clear tags", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 2);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.TAGS, editManager.lastInfoToClear);


        // Expected: Invalid command
        executeEdit("1, 2 clear name", managerHolder);
        assertInvalidArguments(stateManager);

        
        // Expected: Clear description
        executeEdit("2-4 clear details", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 2, 3, 4);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.DESCRIPTION, editManager.lastInfoToClear);

        
        // Expected: Clear datetime
        executeEdit("1 clear datetime", managerHolder);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.DATETIME, editManager.lastInfoToClear);

        
        // Expected: Store command - Clear Status
        executeEdit("orange clear status", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "orange");

        // Expected: [Stored Command] clear status for 2, 5, 7
        executeStoredCommand(stateManager, managerHolder, 2, 5, 7);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 2, 5, 7);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.STATUS, editManager.lastInfoToClear);


        // Expected: Store command - Clear time
        executeEdit("clear clear time", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "clear");

        // Expected: [Stored Command] clear time for 1, 3
        executeStoredCommand(stateManager, managerHolder, 1, 3);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 1, 3);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.TIME, editManager.lastInfoToClear);


        // Expected: Store command - Clear date
        executeEdit("date clear date", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "date");

        // Expected: [Stored Command] clear date for 2, 7
        executeStoredCommand(stateManager, managerHolder, 2, 7);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 2, 7);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.DATE, editManager.lastInfoToClear);


        // Expected: Store command - clear priority
        executeEdit("clear status clear priority", managerHolder);
        assertStoreCommand(stateManager);
        assertLastSearch(searchManager, "clear", "status");

        // Expected: [Stored Command] clear priority for 2
        executeStoredCommand(stateManager, managerHolder, 2);
        assertNormalExecution(stateManager);
        assertEquals(StubEditManager.Method.CLEAR_INFO, editManager.lastMethodCall);
        assertTaskNumbers(editManager, 2);
        assertNull(editManager.lastTaskInfo);
        assertNull(editManager.lastTags);
        assertEquals(EditCommand.Info.PRIORITY, editManager.lastInfoToClear);
    }
    
    private void assertLastSearch(StubSearchManager searchManager,
            String...keywords) {
        Filter[] filters = searchManager.filters;
        assertEquals(1, filters.length);
        KeywordFilter keywordFilter = (KeywordFilter)filters[0];
        List<String> searchKeywords = Arrays.asList(keywordFilter.getKeywords());
        
        for (String keyword : keywords) {
            assertTrue(searchKeywords.contains(keyword));
        }
        assertEquals(keywords.length, searchKeywords.size());
    }
    
    
    private void assertInvalidArguments(StubStateManager stateManager) {
        assertEquals(StubStateManager.Update.INVALID_ARGUMENTS,
                stateManager.getLastUpdate());
    }
    
    private void assertNormalExecution(StubStateManager stateManager) {
        assertEquals(StubStateManager.Update.NORMAL_EXECUTION,
                stateManager.getLastUpdate());
    }
    
    private void assertStoreCommand(StubStateManager stateManager) {
        assertEquals(StubStateManager.Update.STORE_COMMAND,
                stateManager.getLastUpdate());
    }
    
    private void assertTaskNumbers(StubEditManager editManager, int... ids) {
        TaskIdSet taskIdSet = editManager.lastTaskIdSet;
        for (int id : ids) {
            TaskId taskId = new TaskId(id);
            assertTrue(taskIdSet.contains(taskId));
        }
        assertEquals(taskIdSet.size(), ids.length);
    }
    
    private void assertTags(StubEditManager editManager, String... tagStrings) {
        Tag[] tags = editManager.lastTags;
        ArrayList<Tag> tagList = new ArrayList<>(tagStrings.length);
        for (String tagString : tagStrings) {
            tagList.add(new Tag(tagString));
        }
        
        for (Tag tag : tags) {
            assertTrue("last tags do not contain " + tag, tagList.contains(tag));
        }
        
        assertEquals(tags.length, tagList.size());
    }
    
    private Response executeStoredCommand(StubStateManager stateManager,
            ManagerHolder managerHolder, int... ids) {
        TargetedCommand command = stateManager.getStoredCommand();
        assertNotNull(command);

        TaskIdSet taskIdSet = new TaskIdSet();
        for (int id : ids) {
            TaskId taskId = new TaskId(id);
            taskIdSet.add(taskId);
        }
        command.setTargets(taskIdSet);
        
        return command.execute();
    }
    
    private Response executeEdit(String args, ManagerHolder managerHolder) {
        EditCommand command = new EditCommand(args, managerHolder);
        return command.execute();
    }
    
    private Response executeEdit(String args, ManagerHolder managerHolder,
            EditCommand.ParseType parseType) {
        EditCommand command = new EditCommand(args, managerHolder, parseType);
        return command.execute();
    }
    

}

	// End of segment: src\main\command\test\EditCommandTest.java





	/**
	 * origin: src\main\command\test\StubManagerHolder.java
	 */

/**
 * A set of stubs for testing the Commands
 */
class StubManagerHolder extends ManagerHolder {
    private StubAddManager stubAddManager;
    private StubSearchManager stubSearchManager;
    private StubStateManager stubStateManager;
    private StubEditManager stubEditManager;

    public StubManagerHolder() {
        super(null, null, null, null);
        stubAddManager = new StubAddManager();
        stubSearchManager = new StubSearchManager();
        stubStateManager = new StubStateManager();
        stubEditManager = new StubEditManager();
    }

    @Override
    public StateManager getStateManager() {
        return stubStateManager;
    }

    @Override
    public StubAddManager getAddManager() {
        return stubAddManager;
    }

    @Override
    public StubSearchManager getSearchManager() {
        return stubSearchManager;
    }

    @Override
    public EditManager getEditManager() {
        return stubEditManager;
    }

    @Override
    public DeleteManager getDeleteManager() {
        return new StubDeleteManager();
    }

    @Override
    public FreeDaySearchManager getFreeDaySearchManager() {
        return new StubFreeDaySearchManager();
    }

}



class StubAddManager extends AddManager {
    public TaskInfo taskInfo;

    public StubAddManager() {
        super(null);
    }

    @Override
    public Result addTask(TaskInfo taskInfo) {
        this.taskInfo = taskInfo;
        return null;
    }
}

class StubDeleteManager extends DeleteManager {
    public StubDeleteManager() {
        super(null);
    }

    @Override
    public Result deleteTask(TaskIdSet taskIdSet) {
        return null;
    }
}

class StubEditManager extends EditManager {
    public TaskIdSet lastTaskIdSet;
    public Tag[] lastTags;
    public TaskInfo lastTaskInfo;
    public Method lastMethodCall;
    public Info lastInfoToClear;

    public enum Method {
        START_EDIT_MODE,
        ADD_TASK_TAGS,
        DELETE_TASK_TAGS,
        EDIT_TASK,
        CLEAR_INFO
    }

    public StubEditManager() {
        super(null);
    }

    public void clearMemory() {
        lastTaskIdSet = null;
        lastTags = null;
        lastTaskInfo = null;
        lastMethodCall = null;
    }

    @Override
    public Result startEditMode(TaskIdSet taskIdSet) {
        clearMemory();
        lastMethodCall = Method.START_EDIT_MODE;
        lastTaskIdSet = taskIdSet;
        return null;
    }

    @Override
    public Result addTaskTags(Tag[] tags, TaskIdSet taskIdSet) {
        clearMemory();
        lastMethodCall = Method.ADD_TASK_TAGS;
        lastTaskIdSet = taskIdSet;
        lastTags = tags;
        return null;
    }

    @Override
    public Result deleteTaskTags(Tag[] tags, TaskIdSet taskIdSet) {
        clearMemory();
        lastMethodCall = Method.DELETE_TASK_TAGS;
        lastTaskIdSet = taskIdSet;
        lastTags = tags;
        return null;
    }

    @Override
    public Result editTask(TaskInfo taskInfo, TaskIdSet taskIdSet) {
        clearMemory();
        lastMethodCall = Method.EDIT_TASK;
        lastTaskIdSet = taskIdSet;
        lastTaskInfo = taskInfo;
        return null;
    }

    @Override
    public Result clearInfo(TaskIdSet taskIdSet, Info infoToClear) {
        clearMemory();
        lastMethodCall = Method.CLEAR_INFO;
        lastTaskIdSet = taskIdSet;
        lastInfoToClear = infoToClear;
        return null;
    }

}

class StubFreeDaySearchManager extends FreeDaySearchManager {
    public StubFreeDaySearchManager() {
        super(null);
    }
}

class StubSearchManager extends SearchManager {
    public Filter[] filters;

    public StubSearchManager() {
        super(null);
    }

    @Override
    public TaskId getAbsoluteIndex(int relativeTaskId) {
        return new TaskId(relativeTaskId);
    }

    @Override
    public Result searchTasks(Filter[] filters) {
        this.filters = filters;

        TaskInfo[] tasks = new TaskInfo[0];
        TaskId[] taskIds = new TaskId[0];
        return new SearchResult(tasks, taskIds, filters);
    }
    
    @Override
    public Result searchTasksWithoutSplit(Filter[] filters) {
        this.filters = filters;
        
        TaskInfo[] tasks = new TaskInfo[0];
        TaskId[] taskIds = new TaskId[0];
        return new SearchResult(tasks, taskIds, filters);
    }

    @Override
    public Result details(TaskIdSet taskIdSet) {
        return null;
    }
}

class StubStateManager extends StateManager {
    public boolean canEdit = true;
    public boolean inEditMode = false;

    private TargetedCommand storedCommand;
    private Update lastUpdate;

    public enum Update {
        NORMAL_EXECUTION,
        INVALID_ARGUMENTS,
        STORE_COMMAND
    }

    public StubStateManager() {
        super(null, null, null, null);
    }

    @Override
    public void beforeCommandUpdate() {
        return;
    }


    @Override
    public Response updateAndStoreCommand(Result result, TargetedCommand command) {
        clearLastUpdate();
        storedCommand = command;
        lastUpdate = Update.STORE_COMMAND;

        return null;
    }

    @Override
    public Response update(Result result) {
        clearLastUpdate();
        if (result != null && result.getType() == Result.Type.INVALID_ARGUMENT) {
            lastUpdate = Update.INVALID_ARGUMENTS;
        } else {
            lastUpdate = Update.NORMAL_EXECUTION;
        }
        return null;
    }

    @Override
    public boolean canQuerySearchManager() {
        return true;
    }

    @Override
    public boolean canEdit() {
        return canEdit;
    }

    @Override
    public boolean inEditMode() {
        return inEditMode;
    }

    public Update getLastUpdate() {
        return lastUpdate;
    }

    public TargetedCommand getStoredCommand() {
        return storedCommand;
    }

    private void clearLastUpdate() {
        lastUpdate = null;
        storedCommand = null;
    }

}
	// End of segment: src\main\command\test\StubManagerHolder.java





	/**
	 * origin: src\main\command\test\TargetedCommandTest.java
	 */

public class TargetedCommandTest {

    @Test
    public void test() {
        StubTargetedCommand command = new StubTargetedCommand();

        String input;
        String result;

        // Valid inputs
        input = "1,2 , 3, 4 , 5-8 , 9 - 10   , 11   oran";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2,3,4,5,6,7,8,9,10,11", command.toString());
        assertEquals("oran", result);

        input = "  2    ,  4 -    5   , 555 -  558 3333 3333 , 3333";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("2,4,5,555,556,557,558", command.toString());
        assertEquals("3333 3333 , 3333", result);

        input = "1,2,3,4,3-6 7";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2,3,4,5,6", command.toString());
        assertEquals("7", result);

        input = "1- 2   oran";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2", command.toString());
        assertEquals("oran", result);

        input = "1 -3   oran";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2,3", command.toString());
        assertEquals("oran", result);

        input = "1- 4   ";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2,3,4", command.toString());
        assertEquals("", result);

        input = "   1  , 4   ";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,4", command.toString());
        assertEquals("", result);

        input = " 1";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1", command.toString());
        assertEquals("", result);

        input = " 1 2";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1", command.toString());
        assertEquals("2", result);

        input = " 1,2";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("1,2", command.toString());
        assertEquals("", result);

        input = "12";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("12", command.toString());
        assertEquals("", result);

        input = "3,3,4";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("3,4", command.toString());
        assertEquals("", result);

        input = "3,3-3,4 3";
        result = command.tryParseIdsIntoSet(input);
        assertEquals("3,4", command.toString());
        assertEquals("3", result);



        // Invalid inputs
        assertInvalidInput("3,3-3,e 3", command);
        assertInvalidInput("3 , - 3 a", command);
        assertInvalidInput("3,,3", command);
        assertInvalidInput("3,3--3", command);
        assertInvalidInput("1-1000,", command);
        assertInvalidInput("1-1000,-,", command);
        assertInvalidInput("-", command);
        assertInvalidInput(",", command);
        assertInvalidInput(",3", command);
        assertInvalidInput("-3", command);
        assertInvalidInput("3-", command);
        assertInvalidInput("3,", command);
        assertInvalidInput("3-2", command);
        assertInvalidInput("--", command);
        assertInvalidInput(",,", command);
        assertInvalidInput("1,e,2,3,4", command);
        assertInvalidInput("e", command);
        assertInvalidInput("!", command);
        assertInvalidInput("3,%", command);
        assertInvalidInput("$-1", command);
        assertInvalidInput("4-p", command);
        assertInvalidInput("2, 3, 4, 4 - p 4", command);
        assertInvalidInput("1, 2, 4 - 6 - 8", command);
        assertInvalidInput("1, 2, 2-4-5", command);
        assertInvalidInput("1-4-2", command);
        assertInvalidInput("1 -, 3", command);

    }

    private void assertInvalidInput(String args, StubTargetedCommand command) {
        String result = command.tryParseIdsIntoSet(args);
        assertEquals(null, command.getTargetIdSet());
        assertEquals(args, result);
    }

}

class StubTargetedCommand extends TargetedCommand {

    public StubTargetedCommand() {
        super(new StubManagerHolder());
    }

    @Override
    public String toString() {
        return targetTaskIdSet.numericIdString();
    }

    public TaskIdSet getTargetIdSet() {
        return targetTaskIdSet;
    }

    @Override
    public String tryParseIdsIntoSet(String args) {
        return super.tryParseIdsIntoSet(args);
    }

    @Override
    protected boolean isValidArguments() {
        return false;
    }

    @Override
    protected boolean isCommandAllowed() {
        return false;
    }

    @Override
    protected Result executeAction() {
        return null;
    }

}


	// End of segment: src\main\command\test\TargetedCommandTest.java





	/**
	 * origin: src\main\command\UndoCommand.java
	 */

public class UndoCommand extends Command {
    private final UndoManager undoManager;
    int times;

    public UndoCommand(String args, ManagerHolder managerHolder) {
        super(managerHolder);
        undoManager = managerHolder.getUndoManager();
        
        parse(args);
    }
    
    private void parse(String args) {
        if (args.isEmpty()) {
            times = 1;
        } else {
            try {
                times = Integer.parseInt(args);
            } catch (NumberFormatException e) {
                times = -1;
            }
        }
    }

    @Override
    protected boolean isValidArguments() {
        return times >= 1;
    }

    @Override
    protected boolean isCommandAllowed() {
        return stateManager.canUndo();
    }

    @Override
    protected Result executeAction() {
        Result result = undoManager.undo(times);
        return result;
    }

}

	// End of segment: src\main\command\UndoCommand.java





	/**
	 * origin: src\main\command\ViewAliasCommand.java
	 */

public class ViewAliasCommand extends Command {
    private final AliasManager aliasManager;

    public ViewAliasCommand(ManagerHolder managerHolder) {
        super(managerHolder);
        this.aliasManager = managerHolder.getAliasManager();
    }

    @Override
    protected boolean isValidArguments() {
        return true;
    }

    @Override
    protected boolean isCommandAllowed() {
        return true;
    }

    @Override
    protected Result executeAction() {
        Result result = aliasManager.viewAliases();
        return result;
    }

}

	// End of segment: src\main\command\ViewAliasCommand.java





	/**
	 * origin: src\main\formatting\AliasFormatter.java
	 */

/**
 * Formatter for Alias Messages (success/failure, bind/unbind).
 */
public class AliasFormatter {
    private static final String MESSAGE_DELETE_FAIL =
            "Unable to unbind alias: %1$s" + System.lineSeparator() + 
            "Alias does not exist." + System.lineSeparator();
    private static final String MESSAGE_DELETE_SUCCESS =
            "Unbinded alias: %1$s" + System.lineSeparator() +
            "Previously binded to: %2$s" + System.lineSeparator();
    private static final String MESSAGE_SET_FAIL =
            "Unable to set alias: %1$s" + System.lineSeparator() +
            "The keyword is reserved." + System.lineSeparator();
    private static final String MESSAGE_SET_SUCCESS =
            "The alias: %1$s" + System.lineSeparator() +
            "has been binded to: %2$s" + System.lineSeparator();
    private static final String MESSAGE_SET_SUCCESS_OVERWRITE =
            "Previous binding for %1$s has been overwritten." +
            System.lineSeparator();

    public String format(AliasMessage aliasMessage) {
        String alias = aliasMessage.getAlias();
        String value = aliasMessage.getValue();
        boolean isReplacePrevious = aliasMessage.getIsReplacePrevious();
        AliasType messageType = aliasMessage.getMessageType();
        
        switch(messageType) {
            case ALIAS_DELETE_FAILURE :
                return deleteFailureFormat(alias);
            case ALIAS_DELETE_SUCCESS :
                return deleteSuccessFormat(alias, value);
            case ALIAS_SET_FAILURE :
                return setFailureFormat(alias);
            case ALIAS_SET_SUCCESS :
                return setSuccessFormat(alias, value, isReplacePrevious);
        }

        throw new UnsupportedOperationException("Unknown message type");
    }

    private String deleteFailureFormat(String alias) {
        return String.format(MESSAGE_DELETE_FAIL, alias);
    }

    private String deleteSuccessFormat(String alias, String value) {
        return String.format(MESSAGE_DELETE_SUCCESS, alias, value);
    }

    private String setFailureFormat(String alias) {
        return String.format(MESSAGE_SET_FAIL, alias);
    }

    private String setSuccessFormat(String alias, String value,
            boolean isReplacePrevious) {
        
        String result = String.format(MESSAGE_SET_SUCCESS, alias, value);
        if (isReplacePrevious) {
            result += String.format(MESSAGE_SET_SUCCESS_OVERWRITE, alias);
        }

        return result;
    }

}

	// End of segment: src\main\formatting\AliasFormatter.java





	/**
	 * origin: src\main\formatting\FreeTimeSearchFormatter.java
	 */

/**
 * Formatter for Free Time Messages
 */
public class FreeTimeSearchFormatter {

    private final static String FORMAT_TIME = "Time: From %1$s - %2$s";
    private final static String FORMAT_DATE = "Free time slots for %1$s";
    private final static String DATETIME_FORMAT_TIME = "HH:mm (a)";
    private final static String DATETIME_FORMAT_DATE = "EEEE, d MMM Y";


    
    public String format(FreeTimeSearchMessage freeTimeMessage) {
        ArrayList<Interval> intervalList = freeTimeMessage.getFreeTimelist();
        LocalDate date = freeTimeMessage.getDate();
        
        return formatFreeTimes(intervalList, date);
    }
    
    private String formatFreeTimes(ArrayList<Interval> intervalList,
            LocalDate date) {
        

        StringBuilder sb = new StringBuilder();
        sb.append(String.format(FORMAT_DATE, formatDate(date)));
        sb.append(System.lineSeparator());
        
        for (Interval interval : intervalList) {
            sb.append(formatInterval(interval));
            sb.append(System.lineSeparator());
        }
        return sb.toString();
    }
    
    private String formatInterval(Interval interval) {
        LocalTime startTime = interval.getStartTime();
        LocalTime endTime = interval.getRoundedEndTime();

        return String.format(FORMAT_TIME, formatTime(startTime), formatTime(endTime));
    }
    

    private String formatTime(LocalTime time) {
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern(DATETIME_FORMAT_TIME);
        return formatter.format(time);
    }

    private String formatDate(LocalDate date) {
        DateTimeFormatter formatter =
                DateTimeFormatter.ofPattern(DATETIME_FORMAT_DATE);
        return formatter.format(date);
    }

}

	// End of segment: src\main\formatting\FreeTimeSearchFormatter.java





	/**
	 * origin: src\main\formatting\test\FormatterTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    AddSuccessfulFormatterTest.class,
    DeleteSuccessfulFormatterTest.class,
    EditSuccessfulFormatterTest.class,
    ReportFormatterTest.class,
    SearchModeFormatterTest.class,
    WaitingModeFormatterTest.class
})
public class FormatterTestSuite {
}

	// End of segment: src\main\formatting\test\FormatterTestSuite.java





	/**
	 * origin: src\main\formatting\ViewAliasFormatter.java
	 */

/**
 * Formatter for ViewAliasMessage. (when the user uses the view alias command)
 */
public class ViewAliasFormatter {
    private static final String ALIAS_HEADER = "Aliases currently binded:" +
            System.lineSeparator();
    private static final String ALIAS_FORMAT = "[%1$d]: %2$s --> %3$s";

    public String format(ViewAliasMessage aliasMessage) {
        AliasValuePair[] aliases = aliasMessage.getAliases();
        
        StringBuilder sb = new StringBuilder();
        
        sb.append(ALIAS_HEADER);
        
        int index = 1;
        for (AliasValuePair alias : aliases) {
            sb.append(formatAlias(index, alias));
            sb.append(System.lineSeparator());
            
            index++;
        }
        
        return sb.toString();
    }

    private String formatAlias(int index, AliasValuePair aliasValuePair) {
        return String.format(ALIAS_FORMAT, index, aliasValuePair.alias,
                aliasValuePair.value);
    }

}

	// End of segment: src\main\formatting\ViewAliasFormatter.java





	/**
	 * origin: src\main\message\AliasMessage.java
	 */

public class AliasMessage implements Message {

    private String alias;
    private String value;
    private boolean isReplacePrevious;
    private AliasType type;
    
    public enum AliasType {
        ALIAS_SET_SUCCESS,
        ALIAS_SET_FAILURE,
        ALIAS_DELETE_SUCCESS,
        ALIAS_DELETE_FAILURE
    }
    
    public AliasMessage(String alias, String value, AliasType type) {
        this.alias = alias;
        this.value = value;
        this.type = type;
    }
    
    public AliasMessage(String alias, String value, boolean isReplacePrevious,
            AliasType type) {
        this.alias = alias;
        this.value = value;
        this.type = type;
        this.isReplacePrevious = isReplacePrevious;
    }
    
    /**
     * Note: used for all message types.
     * @return the alias keyword
     */
    public String getAlias() {
        return alias;
    }

    /**
     * Note: only used for ALIAS_SET_SUCCESS, ALIAS_SET_FAILURE and
     * ALIAS_DELETE_SUCCESS
     * @return 
     * ALIAS_SET_SUCCESS: the string it is binded to
     * ALIAS_DELETE_SUCCESS: return the string it was previously binded to.
     * ALIAS_SET_FAILURE: return the value string the player tried to type.
     */
    public String getValue() {
        return value;
    }

    /**
     * Note: only used for ALIAS_SET_SUCCESS
     * @return true iff the new alias overwrites an old one.
     */
    public boolean getIsReplacePrevious() {
        return isReplacePrevious;
    }

    public AliasType getMessageType() {
        return type;
    }

    @Override
    public Type getType() {
        return Type.EDIT_ALIAS;
    }
}

	// End of segment: src\main\message\AliasMessage.java





	/**
	 * origin: src\main\message\ViewAliasMessage.java
	 */

public class ViewAliasMessage implements Message {

    private AliasValuePair[] aliases;

    public ViewAliasMessage(AliasValuePair[] aliases) {
        this.aliases = aliases;
    }

    @Override
    public Type getType() {
        return Type.VIEW_ALIAS;
    }
    
    public AliasValuePair[] getAliases() {
        return aliases;
    }

}

	// End of segment: src\main\message\ViewAliasMessage.java





	/**
	 * origin: src\manager\datamanager\AbstractManager.java
	 */

public abstract class AbstractManager {
    protected final ITaskData taskData;
    
    public AbstractManager(TaskData taskData) {
        this.taskData = taskData;
    }
    
}

	// End of segment: src\manager\datamanager\AbstractManager.java





	/**
	 * origin: src\manager\datamanager\AliasManager.java
	 */

public class AliasManager extends AbstractManager {
    private final IAliasStorage aliasStorage;

    public AliasManager(IAliasStorage aliasStorage, TaskData taskData) {
        super(taskData);
        this.aliasStorage = aliasStorage;
    }
    
    public Result createAlias(String alias, String target) {
        boolean canOverride = aliasStorage.canOverride(alias);
        if (canOverride) {
            String value;
            boolean isAlreadyBinded = aliasStorage.isAlreadyBinded(alias);
            value = aliasStorage.createCustomCommand(alias, target);
            
            return new AliasSetResult(alias, value, isAlreadyBinded,
                    Result.Type.ALIAS_SUCCESS);
            
        } else {
            return new AliasSetResult(alias, target, false,
                    Result.Type.ALIAS_FAILURE);
        }
    }

    public Result deleteAlias(String alias) {
        String value = aliasStorage.deleteCustomCommand(alias);
        if (value != null) {
            return new AliasDeleteResult(alias, value,
                    Result.Type.ALIAS_DELETE_SUCCESS);
        }
        else {
            return new AliasDeleteResult(alias, null,
                    Result.Type.ALIAS_DELETE_FAILURE);
        }
    }
    
    public Result viewAliases() {
        AliasValuePair[] aliasValuePairs = aliasStorage.getAllCustomAliases();
        return new ViewAliasResult(aliasValuePairs);
    }
}

	// End of segment: src\manager\datamanager\AliasManager.java





	/**
	 * origin: src\manager\datamanager\searchfilter\test\FilterTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    DateTimeFilterTest.class,
    KeywordFilterTest.class,
    SuggestionFilterTest.class
})
public class FilterTestSuite {
}

	// End of segment: src\manager\datamanager\searchfilter\test\FilterTestSuite.java





	/**
	 * origin: src\manager\datamanager\suggestion\test\SuggestionTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    EditDistanceTest.class
})
public class SuggestionTestSuite {
}

	// End of segment: src\manager\datamanager\suggestion\test\SuggestionTestSuite.java





	/**
	 * origin: src\manager\datamanager\test\DataManagerTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    UndoManagerTest.class,
    FreeDayManagerTest.class,
    FreeTimeManagerTest.class,
    SearchManagerTest.class
})
public class DataManagerTestSuite {
}

	// End of segment: src\manager\datamanager\test\DataManagerTestSuite.java





	/**
	 * origin: src\manager\datamanager\test\UndoManagerTest.java
	 */

public class UndoManagerTest {

    @Test
    public void test() {
        TaskData taskData = new TaskData();
        UndoManager undoManager = new UndoManager(taskData);
        
        assertElements(taskData);
        
        
        TaskId task1Id = taskData.add(dummyTask("task1"));
        undoManager.updateUndoHistory();
        assertElements(taskData, "task1");
        
        
        taskData.add(dummyTask("task2"));
        undoManager.updateUndoHistory();
        assertElements(taskData, "task1", "task2");

        
        Result result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1");

        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1", "task2");

        
        // Undo until it you can't undo further.
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1");

        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData);

        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_FAILURE);
        assertElements(taskData);
        

        // Redo everything to get back all tasks. Until you can't redo further.
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1");
        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1", "task2");
        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_FAILURE);
        assertElements(taskData, "task1", "task2");

        
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1");
        
        
        TaskId task3Id = taskData.add(dummyTask("task3"));
        undoManager.updateUndoHistory();
        assertElements(taskData, "task1", "task3");
        

        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_FAILURE);
        assertElements(taskData, "task1", "task3");
        

        taskData.add(dummyTask("task4"));
        taskData.add(dummyTask("task5"));
        undoManager.updateUndoHistory();
        assertElements(taskData, "task1", "task3", "task4", "task5");
        

        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1", "task3");

        
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1");

        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1", "task3");
        
        
        TaskId task6Id = taskData.add(dummyTask("task6"));
        taskData.setTaskName(task1Id, "editTask1");
        undoManager.updateUndoHistory();
        assertElements(taskData, "editTask1", "task3", "task6");
        

        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1", "task3");
        

        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "editTask1", "task3", "task6");
        
        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_FAILURE);
        assertElements(taskData, "editTask1", "task3", "task6");


        taskData.setTaskName(task1Id, "editEditTask1");
        taskData.setTaskName(task3Id, "editTask3");
        taskData.setTaskName(task1Id, "editEditEditTask1");
        undoManager.updateUndoHistory();
        assertElements(taskData, "editEditEditTask1", "editTask3", "task6");

        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_FAILURE);
        //assertElements(taskData, "editEditEditTask1", "editTask3", "task6");

        
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "editTask1", "task3", "task6");

        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "editEditEditTask1", "editTask3", "task6");

        
        taskData.remove(task6Id);
        taskData.setTaskName(task3Id, "editEditTask3");
        undoManager.updateUndoHistory();
        assertElements(taskData, "editEditEditTask1", "editEditTask3");
        

        while (taskData.getSize() > 0) {
            taskData.remove(taskData.getFirst());
        }
        undoManager.updateUndoHistory();
        assertElements(taskData);

        
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "editEditEditTask1", "editEditTask3");
        
        
        
        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "editEditEditTask1", "editTask3", "task6");
        

        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "editTask1", "task3", "task6");


        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1", "task3");


        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData, "task1");


        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_SUCCESS);
        assertElements(taskData);


        result = undoManager.undo();
        assertEquals(result.getType(), Result.Type.UNDO_FAILURE);
        assertElements(taskData);


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1");


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "task1", "task3");


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "editTask1", "task3", "task6");


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "editEditEditTask1", "editTask3", "task6");


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData, "editEditEditTask1", "editEditTask3");


        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_SUCCESS);
        assertElements(taskData);
        
        
        result = undoManager.redo();
        assertEquals(result.getType(), Result.Type.REDO_FAILURE);
        assertElements(taskData);

    }
    
    private TaskInfo dummyTask(String name) {
        TaskInfo taskInfo = TaskInfo.create();
        taskInfo.name = name;
        return taskInfo;
    }
    
    private void assertSize(ITaskData taskData, int size) {
        assertEquals(size, taskData.getSize());
    }
    
    private void assertElements(ITaskData taskData, String... taskNames) {
        TaskId current = taskData.getFirst();
        
        for (String taskName : taskNames) {
            String actualName = taskData.getTaskName(current);
            assertEquals(taskName, actualName);
            current = taskData.getNext(current);
        }
        assertSize(taskData, taskNames.length);
        
        assertFalse(current.isValid());
    }

}

	// End of segment: src\manager\datamanager\test\UndoManagerTest.java





	/**
	 * origin: src\manager\datamanager\UndoManager.java
	 */

public class UndoManager extends AbstractManager {
    private static int UNDO_LIMIT = 100;
    private LinkedList<UndoSnapshot> undoHistory;
    private LinkedList<UndoSnapshot> redoHistory;
    private final ITaskDataUndo taskDataUndo;

    public UndoManager(TaskData taskData) {
        super(taskData);
        taskDataUndo = taskData;
        undoHistory = new LinkedList<>();
        redoHistory = new LinkedList<>();
    }

    /**
     * Clears both the undo and redo history.
     */
    public void clearHistory() {
        undoHistory.clear();
        redoHistory.clear();
    }
    
    /**
     * Whenever you call this, the UndoManager retrieves a snapshot of the
     * latest updates to taskData from taskData.<br>
     * If there has been a change since the last retrieval, undoManager adds
     * the change to the undo stack and clears the redo history.
     */
    public void updateUndoHistory() {
        UndoSnapshot undoSnapshot = taskDataUndo.retrieveUndoSnapshot();
        if (undoSnapshot.hasChanges()) {
            clearRedoHistory();
            
            undoHistory.push(undoSnapshot);
            if (undoHistory.size() > UNDO_LIMIT) {
                undoHistory.removeLast();
            }
        }
    }

    /**
     * Call to execute an undo command.
     * @param times You can execute a multi-undo. e.g. undo(5) executes 5 undos.
     * Use undo(1) for normal usage.
     * @return a result stating whether the undo was a success or failure.<br>
     * An undo can fail when there is nothing to undo.
     */
    public Result undo(int times) {
        assert times >= 1;
        if (undoHistory.isEmpty()) {
            return new SimpleResult(Result.Type.UNDO_FAILURE);
        }
        if (undoHistory.size() < times) {
            times = undoHistory.size();
        }
        
        TaskId[] taskIds = multipleExecute(times, () -> executeUndo());
        
        return new UndoResult(Result.Type.UNDO_SUCCESS, taskIds, times);
    }

    /**
     * Call to execute a redo command.
     * @param times You can execute a multi-redo. e.g. redo(5) executes 5 redos.
     * Use redo(1) for normal usage.
     * @return a result stating whether the redo was a success or failure.<br>
     * A redo can fail if there is nothing to redo.
     */
    public Result redo(int times) {
        assert times >= 1;
        if (redoHistory.isEmpty()) {
            return new SimpleResult(Result.Type.UNDO_FAILURE);
        }
        if (redoHistory.size() < times) {
            times = redoHistory.size();
        }
        
        TaskId[] taskIds = multipleExecute(times, () -> executeRedo());
        
        return new UndoResult(Result.Type.REDO_SUCCESS, taskIds, times);
    }

    
    public Result undo() {
        if (undoHistory.isEmpty()) {
            return new SimpleResult(Result.Type.UNDO_FAILURE);
        }
        
        TaskId[] taskIds = executeUndo();
        
        return new UndoResult(Result.Type.UNDO_SUCCESS, taskIds, 1);
    }

    
    public Result redo() {
        if (redoHistory.isEmpty()) {
            return new SimpleResult(Result.Type.REDO_FAILURE);
        }

        TaskId[] taskIds = executeRedo();

        return new UndoResult(Result.Type.REDO_SUCCESS, taskIds, 1);
    }
    
    private TaskId[] executeUndo() {
        UndoSnapshot undoSnapshot = undoHistory.pop();
        
        TaskId[] taskIds = undoSnapshot.getChangedList();
        undoSnapshot.applySnapshotChange();
        
        retrieveRedoSnapshot();
        return taskIds;
    }

    private TaskId[] executeRedo() {
        UndoSnapshot redoSnapshot = redoHistory.pop();

        TaskId[] taskIds = redoSnapshot.getChangedList();        
        redoSnapshot.applySnapshotChange();
        
        retrieveUndoSnapshot();
        return taskIds;
    }

    private TaskId[] multipleExecute(int times, Operation function) {
        
        HashSet<TaskId> taskIdSet = new HashSet<>();
        for (int i = 0; i < times; i++) {
            TaskId[] taskIds = function.execute();
            for (TaskId taskId : taskIds) {
                taskIdSet.add(taskId);
            }
        }
        
        TaskId[] taskIds = new TaskId[taskIdSet.size()];
        taskIds = taskIdSet.toArray(taskIds);
        return taskIds;
    }
    
    private void clearRedoHistory() {
        redoHistory.clear();
    }


    private void retrieveUndoSnapshot() {
        UndoSnapshot undoSnapshot = taskDataUndo.retrieveUndoSnapshot();
        undoHistory.push(undoSnapshot);
    }
    
    private void retrieveRedoSnapshot() {
        UndoSnapshot redoSnapshot = taskDataUndo.retrieveUndoSnapshot();
        redoHistory.push(redoSnapshot);
    }
    
    /**
     * Functional interface.
     */
    interface Operation {
        public abstract TaskId[] execute();
    }
    
}

	// End of segment: src\manager\datamanager\UndoManager.java





	/**
	 * origin: src\manager\ManagerHolder.java
	 */

/**
 * A class which packages all the managers. It is passed into a Command object
 * to allow the command to act on the managers.
 */
public class ManagerHolder {
    private final StateManager stateManager;
    private final AddManager addManager;
    private final SearchManager searchManager;
    private final EditManager editManager;
    private final DeleteManager deleteManager;
    private final UndoManager undoManager;
    private final FreeDaySearchManager freeDaySearchManager;
    private final FreeTimeSearchManager freeTimeSearchManager;
    private final AliasManager aliasManager;
    private final ReportManager reportManager;


    public ManagerHolder(TaskData taskData, IFileInputOutput fileInputOutput, 
            IAliasStorage aliasStorage, IFileInputOutput aliasFileInputOutput) {
        
        addManager = new AddManager(taskData);
        searchManager = new SearchManager(taskData);
        editManager = new EditManager(taskData);
        deleteManager = new DeleteManager(taskData);
        undoManager = new UndoManager(taskData);
        freeDaySearchManager = new FreeDaySearchManager(taskData);
        freeTimeSearchManager = new FreeTimeSearchManager(taskData);
        reportManager = new ReportManager(taskData);
        aliasManager = new AliasManager(aliasStorage, taskData);
        
        stateManager = new StateManager(fileInputOutput, aliasFileInputOutput,
                undoManager, searchManager);
    }

    public StateManager getStateManager() {
        return stateManager;
    }

    public AddManager getAddManager() {
        return addManager;
    }

    public SearchManager getSearchManager() {
        return searchManager;
    }

    public EditManager getEditManager() {
        return editManager;
    }

    public DeleteManager getDeleteManager() {
        return deleteManager;
    }

    public UndoManager getUndoManager() {
        return undoManager;
    }

    public FreeDaySearchManager getFreeDaySearchManager() {
        return freeDaySearchManager;
    }
    
    public FreeTimeSearchManager getFreeTimeSearchManager() {
    	return freeTimeSearchManager;
    }

    public ReportManager getReportManager() {
        return reportManager;
    }

    public AliasManager getAliasManager() {
        return aliasManager;
    }
}

	// End of segment: src\manager\ManagerHolder.java





	/**
	 * origin: src\manager\result\AliasDeleteResult.java
	 */

public class AliasDeleteResult implements Result {

    private final String alias;
    private final String value;
    private final Type type;
    
    public AliasDeleteResult(String alias, String value, Type type) {
        this.alias = alias;
        this.value = value;
        
        assert type == Type.ALIAS_DELETE_SUCCESS ||
                type == Type.ALIAS_DELETE_FAILURE;
        this.type = type;
    }
    
    public String getAlias() {
        return alias;
    }
    
    public String getValue() {
        return value;
    }

    @Override
    public Type getType() {
        return type;
    }
}

	// End of segment: src\manager\result\AliasDeleteResult.java





	/**
	 * origin: src\manager\result\AliasSetResult.java
	 */

public class AliasSetResult implements Result {

    private final String alias;
    private final String value;
    private final boolean replacePrevious;
    private final Type type;
    
    public AliasSetResult(String alias, String value, boolean replacePrevious,
            Type type) {
        this.alias = alias;
        this.value = value;
        this.replacePrevious = replacePrevious;
        
        assert type == Type.ALIAS_SUCCESS ||
                type == Type.ALIAS_FAILURE;
        this.type = type;
    }

    @Override
    public Type getType() {
        return type;
    }
    
    public String getAlias() {
        return alias;
    }

    public String getValue() {
        return value;
    }

    public boolean isReplacePrevious() {
        return replacePrevious;
    }

}

	// End of segment: src\manager\result\AliasSetResult.java





	/**
	 * origin: src\manager\result\Result.java
	 */

/**
 * The result returned from the manager to the command after an operation.<br>
 * The result is used by the command to update the StateManager on the result
 * of the command execution.
 */
public interface Result {
    public enum Type {
        ADD_SUCCESS,
        ADD_FAILURE,
        DELETE_SUCCESS,
        DELETE_FAILURE,
        UNDO_SUCCESS,
        UNDO_FAILURE,
        REDO_SUCCESS,
        REDO_FAILURE,
        EDIT_MODE_START,
        EDIT_MODE_END,
        SEARCH_MODE_END,
        GO_BACK,
        EDIT_SUCCESS,
        EDIT_FAILURE,
        SEARCH_SUCCESS,
        SEARCH_FAILURE,
        TAG_ADD_SUCCESS,
        TAG_ADD_FAILURE,
        TAG_DELETE_FAILURE,
        TAG_DELETE_SUCCESS,
        DETAILS,
        INVALID_COMMAND,
        INVALID_ARGUMENT,
        FREE_DAY,
        FREE_DAY_FAILURE,
        FREE_TIME,
        REPORT,
        EXIT,
        ALIAS_SUCCESS,
        ALIAS_FAILURE,
        ALIAS_DELETE_SUCCESS,
        ALIAS_DELETE_FAILURE,
        VIEW_ALIAS_SUCCESS
    }

    public Type getType();    // implement this with the correct type.
}

	// End of segment: src\manager\result\Result.java





	/**
	 * origin: src\manager\result\SimpleResult.java
	 */

/**
 * A simple result that carries no additional information.<br>
 * Only carries the result type.
 * 
 */
public class SimpleResult implements Result {
    private final Type type;
    
    public SimpleResult(Type type) {
        this.type = type;
    }

    @Override
    public Type getType() {
        return type;
    }
}

	// End of segment: src\manager\result\SimpleResult.java





	/**
	 * origin: src\manager\result\UndoResult.java
	 */

public class UndoResult implements Result {
    private final TaskId[] taskIds;
    private final Type type;
    private final int times;
    
    public UndoResult(Type type, TaskId[] taskIds, int times) {
        assert type == Type.UNDO_SUCCESS || type == Type.REDO_SUCCESS;
        this.taskIds = taskIds;
        this.type = type;
        this.times = times;
    }
    
    @Override
    public Type getType() {
        return type;
    }
    
    public TaskId[] getTaskIds() {
        return taskIds;
    }
    
    public int getNumberOfTimes() {
        return times;
    }

}

	// End of segment: src\manager\result\UndoResult.java





	/**
	 * origin: src\manager\result\ViewAliasResult.java
	 */

public class ViewAliasResult implements Result {
    private final AliasValuePair[] aliasValuePairs;
    
    public ViewAliasResult(AliasValuePair[] aliasValuePairs) {
        this.aliasValuePairs = Arrays.copyOf(aliasValuePairs,
                aliasValuePairs.length);
    }
    
    public AliasValuePair[] getAliases() {
        return aliasValuePairs;
    }

    @Override
    public Type getType() {
        return Type.VIEW_ALIAS_SUCCESS;
    }
}

	// End of segment: src\manager\result\ViewAliasResult.java





	/**
	 * origin: src\manager\test\ManagerTestSuite.java
	 */

@RunWith(Suite.class)
@Suite.SuiteClasses({
    StateManagerTest.class
})
public class ManagerTestSuite {
}

	// End of segment: src\manager\test\ManagerTestSuite.java





	/**
	 * origin: src\taskline\debug\Taskline.java
	 */

/**
 * Does the main initialization of the program structure.<br>
 * <br>
 * How to put a logger in your class:<br>
 * private static final Logger log = Logger.getLogger(Taskline.LOGGER_NAME);
 *
 */
public class Taskline {

    public static void main(String[] args) {
        TasklineLogger.setupLogger();

        String fileName = "tasks.txt";
        String aliasFileName = "alias.txt";

        MainController mainController = setupTaskLine(fileName, aliasFileName);
        
        UIDisplay uiDisplay = new UIDisplay(mainController);

        startCommandLoopWithLogger(uiDisplay);
    }

    public static MainController setupTaskLine(String fileName,
            String aliasFileName) {
        
        SimpleCompletor simpleCompletor = new SimpleCompletor(new String[]{});  
        AutoCompleteDictionary autoCompleteDictionary =
                new AutoCompleteDictionary(simpleCompletor);
        
        AliasStorage aliasStorage = new AliasStorage();
        IFileInputOutput aliasFileInputOutput = new AliasFileInputOutput(
                aliasStorage, aliasFileName, autoCompleteDictionary);

        TaskData taskData = new TaskData();
        IFileInputOutput fileInputOutput =
                new FileInputOutput(taskData, fileName);
        
        ManagerHolder managerHolder = new ManagerHolder(taskData,
                fileInputOutput, aliasStorage, aliasFileInputOutput);
        MainController mainController = new MainController(managerHolder,
                aliasStorage, aliasFileInputOutput);
        return mainController;
    }

    private static void startCommandLoopWithLogger(UIDisplay uiDisplay) {
        Logger log = TasklineLogger.getLogger();
        try {
            startCommandLoop(uiDisplay);
        } catch (Exception e) {
            log.log(Level.SEVERE, e.getMessage(), e);
            throw e;
        } finally {
            TasklineLogger.closeLoggerFileHandler();
        }
    }

    private static void startCommandLoop(UIDisplay uiDisplay) {
        while (!uiDisplay.isReadyToExit()) {
            uiDisplay.commandLoopIteration();
        }
    }
}

	// End of segment: src\taskline\debug\Taskline.java





	/**
	 * origin: src\taskline\Taskline.java
	 */

/**
 * Does the main initialization of the program structure.
 *
 */
public class Taskline {

    public static void main(String[] args) throws IOException {
        AnsiConsole.systemInstall();
        TasklineLogger.setupLogger();

        String fileName = "tasks.txt";
        String aliasFileName = "alias.txt";

        SimpleCompletor simpleCompletor = new SimpleCompletor(new String[]{});
        AutoCompleteDictionary autoCompleteDictionary =
                new AutoCompleteDictionary(simpleCompletor);
        
        ArgumentCompletor argumentCompletor = new ArgumentCompletor(
                new Completor[]{simpleCompletor, new NullCompletor()});
        
        AliasStorage aliasStorage = new AliasStorage();
        IFileInputOutput aliasFileInputOutput = new AliasFileInputOutput(
                aliasStorage, aliasFileName, autoCompleteDictionary);

        TaskData taskData = new TaskData();
        IFileInputOutput fileInputOutput =
                new FileInputOutput(taskData, fileName);
        
        ManagerHolder managerHolder = new ManagerHolder(taskData,
                fileInputOutput, aliasStorage, aliasFileInputOutput);
        MainController mainController = new MainController(managerHolder,
                aliasStorage, aliasFileInputOutput);
        
        UIDisplay uiDisplay = new UIDisplay(mainController, argumentCompletor);

        startCommandLoop(uiDisplay);
        TasklineLogger.closeLoggerFileHandler();
        startCommandLoopWithLogger(uiDisplay);
    }

    private static void startCommandLoopWithLogger(UIDisplay uiDisplay) {
        Logger log = TasklineLogger.getLogger();
        try {
            startCommandLoop(uiDisplay);
        } catch (Exception e) {
            log.log(Level.SEVERE, e.getMessage(), e);
            throw e;
        } finally {
            TasklineLogger.closeLoggerFileHandler();
        }
    }

    private static void startCommandLoop(UIDisplay uiDisplay) {
        while (!uiDisplay.isReadyToExit()) {
            uiDisplay.commandLoopIteration();
        }
    }
}

	// End of segment: src\taskline\Taskline.java





	/**
	 * origin: src\taskline\TasklineLogger.java
	 */

public class TasklineLogger {
    private static final String LOGGER_FILENAME = "taskline.log";
    private static String LOGGER_NAME = "Taskline";

    private static FileHandler loggerFileHandler;

    public static void setupLogger() {
        Logger log = Logger.getLogger(LOGGER_NAME);
        log.setUseParentHandlers(false);

        try {
            Path path = Paths.get(LOGGER_FILENAME + ".lck");
            Files.deleteIfExists(path);

            loggerFileHandler = new FileHandler(LOGGER_FILENAME, true);
            SimpleFormatter formatter = new SimpleFormatter();
            loggerFileHandler.setFormatter(formatter);

            log.addHandler(loggerFileHandler);
            log.setLevel(Level.FINEST);

        } catch (SecurityException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }

        log.log(Level.INFO, "Taskline initialised.");
    }

    public static void closeLoggerFileHandler() {
        if (loggerFileHandler != null) {
            loggerFileHandler.close();
        }
    }
    
    public static Logger getLogger() {
        return Logger.getLogger(LOGGER_NAME);
    }
}

	// End of segment: src\taskline\TasklineLogger.java





	/**
	 * origin: src\test\crashtest\AbstractCrashTest.java
	 */

/**
 * Carries the framework for a crash test.
 */
public abstract class AbstractCrashTest {
    
    private final int logQueueSize;
    private final int SIZE_INITIAL_HASHSET = 3000;

    private final int randomSeed;

    private TasklineInstanceContainer tasklineInstanceContainer;
    private KeywordDictionary keywordLibrary;
    private HashSet<String> testedStrings;
    private ArrayBlockingQueue<String> logQueue;
    private int totalStrings;
    private boolean success = false;
    
    /**
     * @param tasklineInstanceContainer contains one or more instances
     * of taskline that is used by the CrashTest.
     * @param startingSeed random seed. (for deterministic testing)
     * @param logQueueLength The maximum length of the log queue. CrashTest logs
     * input and output during the test to a queue. If the test fails, it prints
     * out the logs. Previous logs are deleted when the log queue length is
     * exceeded.
     */
    public AbstractCrashTest(TasklineInstanceContainer tasklineInstanceContainer,
            int startingSeed, int logQueueLength) {
        this.tasklineInstanceContainer = tasklineInstanceContainer;
        
        this.randomSeed = startingSeed;
        this.logQueueSize = logQueueLength;
        
    }

    public void close() {
        if (!success) {
            printLog();
        }
    }
    
    public void runTest() {
        
        keywordLibrary = new KeywordDictionary(randomSeed);
        
        testedStrings = new HashSet<>(SIZE_INITIAL_HASHSET);
        totalStrings = 0;
        logQueue = new ArrayBlockingQueue<String>(logQueueSize);

        knownCrashTest();
        fuzzyTest();
        
        System.out.println("Crash Test successful - Unique inputs: " +
                        testedStrings.size() + " out of " + totalStrings);
        success = true;
    }
    
    /**
     * Tests random strings from the KeywordLibrary.
     */
    protected abstract void fuzzyTest();
    
    /**
     * Tests strings that have been known to crash the program before
     */
    private void knownCrashTest() {

        test("edit po1");
        test("add tue 2pm tue 4pm");
        test("add today 2pm yesterday 2pm");
        test("report");
        test("add \"task\"");
        test("edit task");
        test("edit \"task\"");

        test("add meep 2pm tomorrow");
        test("add meepietwo");
        test("edit meepietwo date tomorrow");
        test("search     ");
        
        test("add yesterday 1300 0pm tomorrow");
        test("freeday today yesterday");

        test("add task 3am 29 oct 2014 3am 29 oct 2014");
        test("add sat after undone done 2pm tomorrow 2pm ##");
        
        test("alias show orange");
        test("show $4");
        test("unalias show");
    }
    
    /**
     * Tests a string made out of the specified combination of ListTypes.<br>
     * The combination is used in that order.
     * @param times the number of times to test that combination
     * @param listTypes the combination of ListTypes to use.
     */
    protected void testRandom(int times, ListType...listTypes) {
        for (int i = 0; i < times; i++) {
            testRandom(listTypes);
        }
    }
    
    /**
     * Tests a string made out of the specified combination of ListTypes.<br>
     * The combination is used in that order.<br>
     * This has a chance of searching before each test.
     * @param times the number of times to test that combination
     * @param listTypes the combination of ListTypes to use.
     */
    protected void testRandomMaybeSearch(int times, ListType...listTypes) {
        ListType[] maybeSearch = {ListType.SEARCH, ListType.NONE};
        
        for (int i = 0; i < times; i++) {
            test(keywordLibrary.getRandom(maybeSearch));
            testRandom(listTypes);
        }
    }
    
    
    protected void testRandom(ListType...listTypes) {
        StringBuilder inputString = new StringBuilder();
        
        String spacebar = "";
        for (ListType listType : listTypes) {
            inputString.append(spacebar);
            inputString.append(keywordLibrary.getRandom(listType));
            spacebar = " ";
        }
        
        test(inputString.toString());
    }

    /**
     * Tests a string made out of the specified combination of ListTypes.<br>
     * The combination is used in that order.
     * @param times the number of times to test that combination
     * @param listTypes the combination of ListTypes to use.
     */
    protected void testRandom(int times, ListType[]...listTypes) {
        for (int i = 0; i < times; i++) {
            testRandom(listTypes);
        }
    }

    /**
     * Tests a string made out of the specified combination of ListTypes.<br>
     * The combination is used in that order.<br>
     * This has a chance of searching before each test.
     * @param times the number of times to test that combination
     * @param listTypes the combination of ListTypes to use.
     */
    protected void testRandomMaybeSearch(int times, ListType[]...listTypes) {
        ListType[] maybeSearch = {ListType.SEARCH, ListType.NONE};
        
        for (int i = 0; i < times; i++) {
            test(keywordLibrary.getRandom(maybeSearch));
            testRandom(listTypes);
        }
    }
    
    
    protected void testRandom(ListType[]...listTypes) {
        StringBuilder inputString = new StringBuilder();
        
        String spacebar = "";
        for (ListType[] listType : listTypes) {
            inputString.append(spacebar);
            inputString.append(keywordLibrary.getRandom(listType));
            spacebar = " ";
        }
        
        test(inputString.toString());
    }
    
    /**
     * Tests a specific string by sending it into the taskline instance.
     * @param input the user input to test. e.g. "add orange juice 2pm"
     */
    protected void test(String input) {
        totalStrings++;
        testedStrings.add(input);
        
        if (totalStrings%100 == 0) {
            System.out.println("Tested: " + testedStrings.size() + " / " +
                    totalStrings + " tested");
        }
        
        try {
            MainController mainController = getNextMainController();
            log("[" + getInstanceIndex() + "] Input: " + input);
            String result = mainController.runCommand(input);
            log(result);
        } catch (Exception e) {
            System.out.println("Exception Thrown!");
            System.out.println(" Attempted Input: [" + input + "]");
            printLog();
            e.printStackTrace();
            throw e;
        }
    }
    
    private void log(String result) {
        if (logQueue.remainingCapacity() <= 0) {
            logQueue.poll();
        }
        logQueue.offer(result);
    }

    private void printLog() {
        while (!logQueue.isEmpty()) {
            System.out.println("*******");
            System.out.println(logQueue.poll());
        }
    }
    
    private MainController getNextMainController() {
        return tasklineInstanceContainer.getNextInstance();
    }
    
    private int getInstanceIndex() {
        return tasklineInstanceContainer.indexOfLastInstance();
    }
}

	// End of segment: src\test\crashtest\AbstractCrashTest.java





	/**
	 * origin: src\test\crashtest\KeywordDictionary.java
	 */

/**
 * A dictionary of commonly used keywords or strings used for the crash tester.
 * <br>
 * Keywords are sorted into categories (ListType). When you query the
 * dictionary for a certain keyword type, it retrieves a random (seeded random)
 * keyword from that list. 
 */
public class KeywordDictionary {
    
    private static final int RECURSE_PROBABILITY = 4;
    private static final boolean AGAIN = true;
    
    private Random rand;

    private ListType[] allListTypes;
    private ArrayList<ArrayList<KeywordToken>> libraryLists;
    
    public enum ListType {
        NONE,
        CONNECTOR,
        DATETIMECONNECTOR,
        COMMAND,
        DATETIME,
        ITEM,
        NUMBER,
        VALIDNUMBER,
        TASKID,
        VALIDTASKID,
        RANDOM,
        SYMBOL,
        COMMA,
        EDITKEYWORD,
        CLEAR,
        EDIT,
        DELETE,
        SEARCH,
        DETAILS,
        ADD,
        RETURN,
        QUIT,
        ALIAS,
        UNALIAS,
        FREEDAY,
        FREETIME,
        REPORT,
        ALL
    }
    
    public KeywordDictionary(int seed) {
        rand = new Random(seed);
        createLists();
        addContent();
    }
    
    /**
     * @param listType the category of keywords you want to query
     * @return a random keyword from the category specified
     */
    public String getRandom(ListType listType) {
        ArrayList<KeywordToken> list = getList(listType);
        return getRandomKeywordAndProcessRecursively(list, listType);
    }
    
    /**
     * @param listTypes the categories of keywords you want to query
     * @return a random keyword from a random category out of the list of
     * categories specified.
     */
    public String getRandom(ListType...listTypes) {
        if (listTypes.length == 1) {
            return getRandom(listTypes[0]);
        } else {
            ArrayList<KeywordToken> list = getRandomList(listTypes);
            return getRandomKeywordAndProcessRecursively(list, listTypes);
        }
    }

    private String getRandomKeywordAndProcessRecursively(
            ArrayList<KeywordToken> list, ListType...listTypes) {
        
        KeywordToken keyword = getRandomElement(list);
        
        int next = rand.nextInt(RECURSE_PROBABILITY);
        if (next == 0) {
            if (keyword.again) {
                return keyword.token + " " + getRandom(listTypes);
            } else if (keyword.successor != null) {
                return keyword.token + " " + getRandom(keyword.successor);
            } else {
                return keyword.token;
            }
        } else {
            return keyword.token;
        }
    }
    
    private void addContent() {

        addToList("", NONE, DATETIMECONNECTOR, CONNECTOR, RANDOM);
        addToList("to", DATETIMECONNECTOR, CONNECTOR, TASKID, RANDOM);
        addToList("-", DATETIMECONNECTOR, RANDOM);
        addToList("until", DATETIMECONNECTOR, CONNECTOR);
        
        addToList("at", CONNECTOR, TASKID, RANDOM);
        addToList("from", CONNECTOR, RANDOM);
        addToList("after", CONNECTOR);
        addToList("before", CONNECTOR);
        
        addToList(AGAIN, "2014", DATETIME, RANDOM);
        addToList("29 oct 2014", DATETIME, RANDOM);
        addToList(AGAIN, "2pm", DATETIME, TASKID, VALIDTASKID, RANDOM);
        addToList(AGAIN, "3am", DATETIME, TASKID, VALIDTASKID);
        addToList(AGAIN, "0pm", DATETIME, TASKID, VALIDTASKID);
        addToList(AGAIN, "12am", DATETIME, TASKID);
        addToList(AGAIN, "4 pm", DATETIME, NUMBER, RANDOM);
        addToList(AGAIN, "12 am", DATETIME);
        addToList(AGAIN, "13 am", DATETIME);
        addToList(AGAIN, "13 pm", DATETIME);
        addToList(AGAIN, "1300", DATETIME, NUMBER);
        addToList(AGAIN, "1300h", DATETIME, NUMBER);
        addToList(AGAIN, "12-am", DATETIME);
        addToList(AGAIN, "12-14pm", DATETIME);
        addToList(AGAIN, "tuesday", DATETIME);
        addToList(AGAIN, "oct", DATETIME, RANDOM);
        addToList(AGAIN, "may", DATETIME, TASKID, CONNECTOR);
        addToList(AGAIN, "mon", DATETIME, TASKID, RANDOM);
        addToList(AGAIN, "sun", DATETIME, TASKID);
        addToList(AGAIN, "sat", DATETIME, TASKID);
        addToList(AGAIN, "today", DATETIME);
        addToList(AGAIN, "tomorrow", DATETIME);
        addToList(AGAIN, "yesterday", DATETIME);
        addToList(AGAIN, "next week", DATETIME);
        addToList(AGAIN, "last month", DATETIME);
        addToList(AGAIN, "tonight", DATETIME);
        addToList(AGAIN, "day", DATETIME, TASKID);
        addToList(AGAIN, "lunchtime", DATETIME);
        addToList(AGAIN, "noon", DATETIME);
        addToList(AGAIN, "midnight", DATETIME);
        addToList(AGAIN, "evening", DATETIME);
        addToList(AGAIN, "morning", DATETIME);
        addToList(AGAIN, "this week", DATETIME);
        addToList(AGAIN, "next tuesday", DATETIME);

        addToList("+high", ITEM);
        addToList("+low", ITEM);
        addToList("+medium", ITEM);
        addToList("+med", ITEM);
        addToList("#taskline", ITEM);
        addToList("#orange", ITEM);
        addToList("#tag", ITEM);
        addToList("##", ITEM);
        addToList("done", ITEM);
        addToList("undone", ITEM);
        addToList("++high", ITEM);

        addToList("show", COMMAND, SEARCH);
        addToList("search", COMMAND, SEARCH);
        addToList("view", COMMAND, SEARCH);
        addToList("ls", COMMAND, SEARCH, RANDOM);
        addToList("set", COMMAND, EDIT, TASKID, RANDOM);
        addToList("edit", COMMAND, EDIT);
        addToList("change", COMMAND, EDIT);
        addToList("modify", COMMAND, EDIT);
        addToList("remove", COMMAND, DELETE);
        addToList("rm", COMMAND, DELETE);
        addToList("detail", COMMAND, DETAILS);
        addToList("details", COMMAND, DETAILS);
        addToList("return", COMMAND, RETURN);
        addToList("back", COMMAND, RETURN);
        addToList("quit", COMMAND, QUIT);
        addToList("exit", COMMAND, QUIT);
        addToList("alias", COMMAND, ALIAS);
        addToList("custom", COMMAND, ALIAS);
        addToList("unalias", COMMAND, UNALIAS);
        addToList("freeday", COMMAND, FREEDAY);
        addToList("freetime", COMMAND, FREETIME);
        addToList("report", COMMAND, REPORT);
        addToList("urgent", COMMAND);
        addToList("mark", COMMAND);
        addToList("done", COMMAND);
        addToList("unmark", COMMAND);
        addToList("reschedule", COMMAND);
        addToList("aliases", COMMAND);
        addToList("viewalias", COMMAND);
        addToList("viewaliases", COMMAND);

        addToList(AGAIN, "tag", COMMAND, EDIT, EDITKEYWORD, TASKID);
        addToList("add", COMMAND, ADD, EDITKEYWORD, TASKID, RANDOM);
        addToList("delete", COMMAND, DELETE, EDITKEYWORD, RANDOM);
        addToList("del", COMMAND, DELETE, EDITKEYWORD, TASKID);

        addToList("clear", CLEAR);
        addToList(AGAIN, "clear", COMMAND, EDITKEYWORD);
        addToList("time", COMMAND, EDITKEYWORD);
        addToList("name", COMMAND, EDITKEYWORD, RANDOM);
        addToList("date", COMMAND, EDITKEYWORD, RANDOM);
        addToList("datetime", COMMAND, EDITKEYWORD);
        addToList("priority", COMMAND, EDITKEYWORD);
        addToList("status", COMMAND, EDITKEYWORD);
        addToList("details", EDITKEYWORD);
        addToList("edit", EDITKEYWORD);
        addToList("tag add", EDITKEYWORD);
        addToList("tag del", EDITKEYWORD);
        
        addToList(COMMA, "1", NUMBER, VALIDNUMBER);
        addToList(COMMA, "2", NUMBER, VALIDNUMBER);
        addToList(COMMA, "-1", NUMBER);
        addToList(COMMA, "-34", NUMBER);
        addToList(COMMA, "431", NUMBER);
        addToList(COMMA, "4,31", NUMBER);
        addToList(COMMA, "67", NUMBER);
        addToList(COMMA, "5-1", NUMBER);
        addToList(COMMA, "5--6", NUMBER);
        addToList(COMMA, "2-4,3", NUMBER, VALIDNUMBER);
        addToList(COMMA, "5", NUMBER, VALIDNUMBER);
        addToList(COMMA, "1,3", NUMBER, VALIDNUMBER);
        addToList(COMMA, "2-5", NUMBER, VALIDNUMBER, RANDOM);
        addToList(COMMA, "8, 3, 1", NUMBER, VALIDNUMBER);
        addToList(COMMA, "1-5, 6", NUMBER, VALIDNUMBER, RANDOM);
        addToList(COMMA, "3.534", NUMBER);
        addToList(COMMA, "123(", NUMBER);
        addToList(COMMA, "^", NUMBER, SYMBOL);
        addToList(COMMA, "#", NUMBER, SYMBOL);
        addToList(COMMA, "@2", NUMBER, RANDOM);
        addToList(COMMA, "+341", NUMBER, RANDOM);
        addToList(COMMA, "%123", NUMBER, TASKID);
        addToList(COMMA, "-84", NUMBER);
        addToList(COMMA, "-pi", NUMBER, TASKID);
        addToList(COMMA, "sqrt(2)", NUMBER);
        addToList(COMMA, "255", NUMBER);
        addToList(COMMA, "2147483647", NUMBER);
        addToList(COMMA, "2147483648", NUMBER);
        addToList(COMMA, "-2147483648", NUMBER);
        addToList(COMMA, "999999999999999", NUMBER);
        addToList(COMMA, "0", NUMBER);
        addToList(COMMA, "$4", NUMBER);
        addToList(COMMA, "i", NUMBER);
        addToList(COMMA, "", NUMBER);
        addToList(COMMA, "000", NUMBER, RANDOM);
        
        for (int i = 5; i < 30; i++) {
            addToList(COMMA, i + "", VALIDNUMBER);
            addToList(COMMA, i + "-" + (i+5), VALIDNUMBER);
        }

        addToList(COMMA, "ab9", TASKID, VALIDTASKID);
        addToList(COMMA, "9ab", TASKID, VALIDTASKID);
        addToList(COMMA, "1aa", TASKID, VALIDTASKID);
        addToList(COMMA, "aa0", TASKID, VALIDTASKID);
        addToList(COMMA, "po9", TASKID, VALIDTASKID);
        addToList(COMMA, "c93", TASKID);
        addToList(COMMA, "999", TASKID, RANDOM);
        addToList(COMMA, "aca", TASKID);
        addToList(COMMA, "12", NUMBER, TASKID);
        addToList(COMMA, "oct", DATETIME);
        addToList(COMMA, "op2", TASKID, VALIDTASKID, RANDOM);
        addToList(COMMA, "9sds", TASKID);
        addToList(COMMA, "s9asd", TASKID);
        addToList(COMMA, "4rea", TASKID);
        addToList(COMMA, "%53", TASKID);
        addToList(COMMA, "%%%", TASKID, RANDOM);
        addToList(COMMA, "#ta3", TASKID);

        addToList("a", RANDOM);
        addToList("%", RANDOM, SYMBOL);
        addToList("aj3", RANDOM);
        addToList("T##", RANDOM);
        addToList("\"test\"", RANDOM);
        addToList("\"", RANDOM, SYMBOL);
        addToList("\n", RANDOM);
        addToList("five", RANDOM);
        addToList(AGAIN, "    ", RANDOM);
        addToList("___", RANDOM);
        addToList("orange", RANDOM, ITEM);
        addToList("apple", RANDOM, ITEM);
        addToList("pear pear", RANDOM, ITEM);
        addToList("-", RANDOM, SYMBOL, CONNECTOR);
        addToList(",", RANDOM, SYMBOL, CONNECTOR, COMMA);
        addToList("+", RANDOM, SYMBOL);
        addToList(">", RANDOM, SYMBOL);
        addToList("\\", RANDOM, SYMBOL);
    }

    private KeywordToken getRandomElement(ArrayList<KeywordToken> list) {
        int next = rand.nextInt(list.size());
        return list.get(next);
    }

    private ArrayList<KeywordToken> getRandomList(ListType...listTypes) {
        int next = rand.nextInt(listTypes.length);
        return getList(listTypes[next]);
    }

    private ArrayList<KeywordToken> getList(ListType listType) {
        if (listType == ListType.ALL) {
            return getRandomList(allListTypes);
        } else {
            int index = listType.ordinal();
            return libraryLists.get(index);
        }
    }
    
    private void createLists() {
        int nTypes = ListType.values().length;
        
        libraryLists = new ArrayList<>();
        allListTypes = new ListType[nTypes - 1];
        
        for (int i = 0; i < nTypes; i++) {
            ListType currentListType = ListType.values()[i];
            
            if (currentListType != ListType.ALL) {
                libraryLists.add(new ArrayList<KeywordToken>());
                allListTypes[i] = currentListType;
            }
        }
    }
    
    private void addToList(ListType successor, String token, ListType...listTypes) {
        for (ListType listType : listTypes) {
            ArrayList<KeywordToken> list = getList(listType);
            list.add(new KeywordToken(token, successor));
        }
    }
    
    private void addToList(boolean again, String token, ListType...listTypes) {
        for (ListType listType : listTypes) {
            ArrayList<KeywordToken> list = getList(listType);
            list.add(new KeywordToken(token, again));
        }
    }
    
    private void addToList(String token, ListType...listTypes) {
        for (ListType listType : listTypes) {
            ArrayList<KeywordToken> list = getList(listType);
            list.add(new KeywordToken(token));
        }
    }
}

class KeywordToken {
    public final String token;
    
    /**
     * If again is true, there is a chance that another token of the same
     * keyword type will be added again after this keyword.
     */
    public final boolean again;
    public final ListType successor;

    public KeywordToken(String token) {
        this.token = token;
        this.again = false;
        this.successor = null;
    }
    
    public KeywordToken(String token, boolean repeat) {
        this.token = token;
        this.again = repeat;
        this.successor = null;
    }
    
    public KeywordToken(String token, ListType successor) {
        this.token = token;
        this.again = false;
        this.successor = successor;
    }
}

	// End of segment: src\test\crashtest\KeywordDictionary.java





	/**
	 * origin: src\test\crashtest\MultiInstanceCrashTest.java
	 */

/**
 * The crash test configuration for a multi-instance crash test. Focus is on
 * checking whether the other taskline functions properly when one of them is
 * constantly adding and deleting tasks.
 */
public class MultiInstanceCrashTest extends AbstractCrashTest {

    public MultiInstanceCrashTest(
            TasklineInstanceContainer tasklineInstanceContainer,
            int startingSeed, int logQueueLength) {
        super(tasklineInstanceContainer, startingSeed, logQueueLength);
    }
    
    
    @Override
    protected void fuzzyTest() {
        ListType[] edit = {ListType.EDIT};
        ListType[] add = {ListType.ADD};
        ListType[] delete = {ListType.DELETE};

        ListType[] clear = {ListType.CLEAR};

        ListType[] dateTime = {ListType.DATETIME};
        
        ListType[] editKeywords = {ListType.EDITKEYWORD};
        ListType[] validTargets = {ListType.VALIDNUMBER, ListType.NONE,
                ListType.VALIDTASKID};
        ListType[] validItems = {ListType.DATETIME, ListType.ITEM};

        ListType[] randomTargets = {ListType.NUMBER, ListType.NONE, ListType.TASKID};
        ListType[] randomItems = {ListType.DATETIME, ListType.ITEM, ListType.NONE,
                ListType.RANDOM, ListType.SYMBOL, ListType.CONNECTOR};
        
        for (int i = 0; i <12; i++) {
            testRandom(3, ListType.ADD, ListType.ALL);
            testRandom(3, ListType.ADD, ListType.RANDOM, ListType.ITEM);
            testRandom(3, ListType.ADD, ListType.DATETIME, ListType.DATETIME,
                    ListType.DATETIME, ListType.DATETIME);
            testRandom(3, add, randomItems, randomItems, randomItems,
                    validItems, validItems, validItems);
    
            testRandomMaybeSearch(5, ListType.ALL, ListType.ALL);
            
            testRandomMaybeSearch(3, ListType.DELETE, ListType.ALL);
            testRandomMaybeSearch(3, ListType.DELETE, ListType.RANDOM);
            testRandomMaybeSearch(3, ListType.DELETE, ListType.TASKID);
    
            testRandom(delete, validTargets);
            testRandom(delete, validTargets, validTargets);
            testRandom(delete, validTargets, validTargets, validTargets);
            testRandom(edit, validTargets, editKeywords, dateTime);
            testRandom(edit, validTargets, validTargets, editKeywords, dateTime);
    
            testRandom(ListType.ADD, ListType.ALL);
            testRandomMaybeSearch(1, ListType.DELETE, ListType.ALL);
            
            testRandomMaybeSearch(3, ListType.ALL, ListType.ALL);
    
            testRandom(2, ListType.SEARCH, ListType.ALL, ListType.ALL);
            
            testRandom(1, ListType.FREEDAY, ListType.DATETIME);
            testRandom(1, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME);
            testRandom(1, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME,
                    ListType.DATETIME);
    
            testRandom(3, ListType.SEARCH, ListType.ALL, ListType.ALL);
            
            testRandom(1, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME,
                    ListType.DATETIME, ListType.DATETIME);
            testRandom(2, ListType.FREEDAY, ListType.ALL, ListType.ALL,
                    ListType.ALL, ListType.ALL);
    
            testRandomMaybeSearch(5, ListType.ALL, ListType.ALL);
    
            testRandom(ListType.ADD, ListType.ALL);
            testRandomMaybeSearch(1, ListType.DELETE, ListType.ALL);
            
            testRandom(1, ListType.FREETIME, ListType.DATETIME);
            testRandom(1, ListType.FREETIME, ListType.DATETIME, ListType.DATETIME);
            testRandom(2, ListType.FREETIME, ListType.ALL, ListType.ALL);
            
            testRandomMaybeSearch(5, ListType.ALL, ListType.ALL);
            testRandom(3, ListType.UNALIAS, ListType.COMMAND);
            
            testRandom(ListType.SEARCH);
    
            testRandom(2, ListType.SEARCH, ListType.ALL);
    
            testRandom(2, ListType.COMMAND, ListType.ALL);
            testRandom(2, ListType.COMMAND, ListType.ALL, ListType.ALL);
            testRandom(2, ListType.COMMAND, ListType.ALL, ListType.ALL, ListType.ALL);
            testRandom(3, ListType.UNALIAS, ListType.COMMAND);
    
    
            testRandomMaybeSearch(2, ListType.EDIT, ListType.EDITKEYWORD);
            
            testRandom(3, ListType.SEARCH, ListType.ALL, ListType.ALL);
            
            testRandomMaybeSearch(2, ListType.EDIT, ListType.EDITKEYWORD, ListType.RANDOM);
            testRandomMaybeSearch(2, ListType.EDIT, ListType.RANDOM, ListType.RANDOM);
            
            testRandomMaybeSearch(6, edit, validTargets, clear, editKeywords);
            testRandomMaybeSearch(2, edit, validTargets, editKeywords, validItems);
            testRandomMaybeSearch(3, edit, validTargets, clear, editKeywords);
            testRandomMaybeSearch(2, edit, validTargets, validTargets, editKeywords,
                    validItems);
            testRandomMaybeSearch(2, edit, validTargets, validTargets, validTargets,
                    editKeywords, validItems,
                    validItems);
            testRandomMaybeSearch(2, edit, randomTargets, randomTargets, randomTargets,
                    editKeywords, randomItems, randomItems);

            testRandomMaybeSearch(15, ListType.DELETE, ListType.ALL);
            testRandomMaybeSearch(15, ListType.DELETE, ListType.RANDOM);
            testRandomMaybeSearch(15, ListType.DELETE, ListType.TASKID);
        }

        // Random aliasing
        for (int i = 0; i < 80; i++) {
            testRandom(3, ListType.ALIAS, ListType.ALL, ListType.COMMAND,
                    ListType.ALL);
            testRandom(2, ListType.COMMAND, ListType.ALL);
            
            testRandom(3, ListType.ALIAS, ListType.ALL, ListType.ALL,
                    ListType.ALL);

            testRandom(3, ListType.UNALIAS, ListType.ALL);
    
            testRandom(3, ListType.ALL, ListType.ALL);
            testRandom(3, ListType.ALL, ListType.ALL, ListType.ALL);
            testRandom(3, ListType.ALL, ListType.ALL, ListType.ALL,
                    ListType.ALL);
        }
    }

}

	// End of segment: src\test\crashtest\MultiInstanceCrashTest.java





	/**
	 * origin: src\test\crashtest\SingleInstanceCrashTest.java
	 */

/**
 * The crash test configuration for a single-instance crash test. Focus is on
 * testing as many different types of input as possible, to see whether anything
 * causes the program to crash.
 */
public class SingleInstanceCrashTest extends AbstractCrashTest {

    public SingleInstanceCrashTest(
            TasklineInstanceContainer tasklineInstanceContainer,
            int startingSeed, int logQueueLength) {
        super(tasklineInstanceContainer, startingSeed, logQueueLength);
    }

    @Override
    protected void fuzzyTest() {
        ListType[] edit = {ListType.EDIT};
        ListType[] add = {ListType.ADD};
        ListType[] delete = {ListType.DELETE};

        ListType[] clear = {ListType.CLEAR};

        ListType[] dateTime = {ListType.DATETIME};
        
        ListType[] editKeywords = {ListType.EDITKEYWORD};
        ListType[] validTargets = {ListType.VALIDNUMBER, ListType.NONE,
                ListType.VALIDTASKID};
        ListType[] validItems = {ListType.DATETIME, ListType.ITEM};

        ListType[] randomTargets = {ListType.NUMBER, ListType.NONE, ListType.TASKID};
        ListType[] randomItems = {ListType.DATETIME, ListType.ITEM, ListType.NONE,
                ListType.RANDOM, ListType.SYMBOL, ListType.CONNECTOR};

        testRandom(30, ListType.UNALIAS, ListType.COMMAND);
        
        for (int i = 0; i < 30; i++) {
            testRandom(1, ListType.ADD, ListType.ALL);
            testRandom(1, ListType.ADD, ListType.RANDOM, ListType.ITEM);
            testRandom(2, ListType.ADD, ListType.DATETIME, ListType.DATETIME,
                    ListType.DATETIME, ListType.DATETIME);
            testRandom(ListType.REPORT);
            testRandom(1, add, randomItems, randomItems, randomItems,
                    validItems, validItems, validItems);
        }

        
        for (int i = 0 ; i < 100; i++) {
            testRandom(ListType.SEARCH, ListType.RANDOM);
            testRandom(delete, validTargets);
            testRandom(ListType.SEARCH, ListType.RANDOM);
            testRandom(delete, validTargets, validTargets);
            testRandom(ListType.SEARCH, ListType.RANDOM);
            testRandom(delete, validTargets, validTargets, validTargets);
            testRandom(ListType.SEARCH, ListType.RANDOM);
            testRandom(edit, validTargets, editKeywords, dateTime);
            testRandom(ListType.SEARCH, ListType.RANDOM);
            testRandom(edit, validTargets, validTargets, editKeywords, dateTime);
        }

        testRandom(10, ListType.FREEDAY, ListType.DATETIME);
        testRandom(10, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME);
        testRandom(10, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME,
                ListType.DATETIME);
        testRandom(10, ListType.FREEDAY, ListType.DATETIME, ListType.DATETIME,
                ListType.DATETIME, ListType.DATETIME);
        testRandom(40, ListType.FREEDAY, ListType.ALL, ListType.ALL,
                ListType.ALL, ListType.ALL);

        testRandom(30, ListType.FREETIME, ListType.DATETIME);
        testRandom(10, ListType.FREETIME, ListType.DATETIME, ListType.DATETIME);
        testRandom(40, ListType.FREETIME, ListType.ALL, ListType.ALL);
        
        testRandomMaybeSearch(30, ListType.DELETE, ListType.ALL);
        testRandomMaybeSearch(30, ListType.DELETE, ListType.RANDOM);
        testRandomMaybeSearch(30, ListType.DELETE, ListType.TASKID);
        
        
        testRandomMaybeSearch(200, ListType.ALL, ListType.ALL);
        testRandom(30, ListType.UNALIAS, ListType.COMMAND);
        
        testRandom(ListType.SEARCH);

        testRandom(150, ListType.COMMAND, ListType.ALL);
        testRandom(150, ListType.COMMAND, ListType.ALL, ListType.ALL);
        testRandom(150, ListType.COMMAND, ListType.ALL, ListType.ALL, ListType.ALL);
        testRandom(30, ListType.UNALIAS, ListType.COMMAND);

        testRandom(100, ListType.SEARCH, ListType.ALL);
        testRandom(50, ListType.SEARCH, ListType.RANDOM);
        testRandom(50, ListType.SEARCH, ListType.RANDOM, ListType.RANDOM);
        testRandom(50, ListType.SEARCH, ListType.RANDOM, ListType.RANDOM, ListType.RANDOM);
        testRandom(200, ListType.SEARCH, ListType.ALL, ListType.ALL, ListType.ALL);
        testRandom(50, ListType.SEARCH, ListType.DATETIME, ListType.DATETIME);
        testRandom(50, ListType.SEARCH, ListType.DATETIME, ListType.RANDOM, ListType.DATETIME);
        testRandom(50, ListType.SEARCH, ListType.DATETIME, ListType.CONNECTOR, ListType.DATETIME);
        testRandom(50, ListType.SEARCH, ListType.DATETIME, ListType.SYMBOL, ListType.DATETIME);

        testRandomMaybeSearch(20, ListType.EDIT, ListType.EDITKEYWORD);
        testRandomMaybeSearch(20, ListType.EDIT, ListType.EDITKEYWORD, ListType.RANDOM);
        testRandomMaybeSearch(20, ListType.EDIT, ListType.RANDOM, ListType.RANDOM);
        
        testRandomMaybeSearch(120, edit, validTargets, clear, editKeywords);
        testRandomMaybeSearch(200, edit, validTargets, editKeywords, validItems);
        testRandomMaybeSearch(30, edit, validTargets, clear, editKeywords);
        testRandomMaybeSearch(200, edit, validTargets, validTargets, editKeywords,
                validItems);
        testRandomMaybeSearch(200, edit, validTargets, validTargets, validTargets,
                editKeywords, validItems,
                validItems);
        testRandomMaybeSearch(200, edit, randomTargets, randomTargets, randomTargets,
                editKeywords, randomItems, randomItems);

        // Random aliasing
        for (int i = 0; i < 3; i++) {
            testRandom(20, ListType.ALIAS, ListType.ALL, ListType.COMMAND,
                    ListType.ALL);
            testRandom(20, ListType.ALIAS, ListType.ALL, ListType.ALL,
                    ListType.ALL);
    
            testRandom(20, ListType.ALL, ListType.ALL);
            testRandom(20, ListType.ALL, ListType.ALL, ListType.ALL);
            testRandom(20, ListType.ALL, ListType.ALL, ListType.ALL,
                    ListType.ALL);
        }

        testRandom(50, ListType.COMMAND, ListType.ALL);
    }
    
    

}

	// End of segment: src\test\crashtest\SingleInstanceCrashTest.java





	/**
	 * origin: src\test\crashtest\TasklineInstanceContainer.java
	 */

/**
 * Carries either one or two instances of taskline. If it is created in
 * multi-instance mode, it randomly chooses between the two tasklines based
 * on the probability ratio (0<ratio<1) given.
 */
public class TasklineInstanceContainer {
    private final String fileName;
    private final String aliasFileName;

    private final float ratio;
    private final MainController[] mainControllers;
    private final boolean multiple;
    private final Random rand;

    private int indexOfLastInstance;

    private TasklineInstanceContainer(String fileName, String aliasFileName,
            int seed, boolean multiple, float ratio) {
        this.fileName = fileName;
        this.aliasFileName = aliasFileName;
        deleteTestFiles();
        
        this.ratio = ratio;
        this.multiple = multiple;
        rand = new Random(seed);
        
        if (multiple) {
            mainControllers = new MainController[2];
            mainControllers[0] = Taskline.setupTaskLine(fileName, aliasFileName);
            mainControllers[1] = Taskline.setupTaskLine(fileName, aliasFileName);
        } else {
            mainControllers = new MainController[1];
            mainControllers[0] = Taskline.setupTaskLine(fileName, aliasFileName);
        }
    }
    
    /**
     * @param fileName file name of task list
     * @param aliasFileName file name of alias list
     * @return a TasklineInstanceContainer containing only one instance of
     * taskline.
     */
    public static TasklineInstanceContainer createMonoInstance(String fileName,
            String aliasFileName) {
        return new TasklineInstanceContainer(fileName, aliasFileName,
                0, false, 0);
    }
    
    /**
     * @param fileName file name of task list
     * @param aliasFileName file name of alias list
     * @param seed random seed used for getNextInstance()
     * @param ratio getNextInstance() randomly chooses between the two tasklines
     * based on the probability ratio (0<ratio<1) given.
     * @return a TasklineInstanceContainer containing two instances of taskline.
     */
    public static TasklineInstanceContainer createMultiInstance(String fileName,
            String aliasFileName, int seed, float ratio) {
        return new TasklineInstanceContainer(fileName, aliasFileName,
                seed, true, ratio);
    }
    
    /**
     * Retrieves a random instance of Taskline.<br>
     * If in mono-instance mode, it always returns the same instance.<br>
     * If in multi-instance mode, it randomly chooses between the two instances
     * to return, based on the ratio configured.<br>
     * @return an instance of taskline in the form of a MainController.
     */
    public MainController getNextInstance() {
        if (multiple) {
            if (rand.nextDouble() < ratio) {
                indexOfLastInstance = 1;
                return mainControllers[0];
            } else {
                indexOfLastInstance = 2;
                return mainControllers[1];
            }
        } else {
            indexOfLastInstance = 1;
            return mainControllers[0];
        }
    }
    
    /**
     * @return the index of the last instance retrieved. The tasklines are
     * labelled "1" and "2" respectively.
     */
    public int indexOfLastInstance() {
        return indexOfLastInstance;
    }

    public void close() {
        deleteTestFiles();
    }

    private void deleteTestFiles() {
        try {
            Path path = Paths.get(fileName);
            Files.deleteIfExists(path);
            path = Paths.get(aliasFileName);
            Files.deleteIfExists(path);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

	// End of segment: src\test\crashtest\TasklineInstanceContainer.java





	/**
	 * origin: src\test\MainTestSuite.java
	 */

/**
 * Runs all JUnit tests in the program.
 * ALWAYS RUN THIS BEFORE COMMITING.
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({
    data.test.DataTestSuite.class,
    io.test.IoTestSuite.class,
    main.command.parser.test.CommandParserTestSuite.class,
    main.command.test.CommandTestSuite.class,
    main.formatting.test.FormatterTestSuite.class,
    manager.datamanager.searchfilter.test.FilterTestSuite.class,
    manager.datamanager.suggestion.test.SuggestionTestSuite.class,
    manager.datamanager.test.DataManagerTestSuite.class,
    manager.test.ManagerTestSuite.class
})
public class MainTestSuite {
}

	// End of segment: src\test\MainTestSuite.java





	/**
	 * origin: src\test\MainTestSuiteAndCrashTest.java
	 */

/**
 * Runs both the main test suite and the crash tester.<br>
 * I usually run both separately because the crash tester can take a while.<br>
 * But this is good for seeing total test coverage.
 */
@RunWith(Suite.class)
@Suite.SuiteClasses({
    MainTestSuite.class,
    SingleInstanceCrashTester.class
})
public class MainTestSuiteAndCrashTest {
}

	// End of segment: src\test\MainTestSuiteAndCrashTest.java





	/**
	 * origin: src\test\MultiInstanceCrashTester.java
	 */

/**
 * Two separate instance of taskline operating on the same file.<br>
 * Used to check whether the file can be modified externally without crashing
 * taskline.<br>
 * It does this by creating two independent instances of Taskline which operate
 * on the same files testFile.txt and testAlias.txt and sends random input
 * to one of the two, picked randomly, to see if they are able to cause each
 * other to crash.
 */
public class MultiInstanceCrashTester {
    private static final String TEST_ALIAS_FILENAME = "testAlias.txt";
    private static final String TEST_FILENAME = "testTasks.txt";

    private static final int RANDOM_SEED = 3;
    private static final float RATIO = 0.3f;
    private static final int LOG_QUEUE_LENGTH = 40;

    private AbstractCrashTest crashTester;
    private TasklineInstanceContainer tasklineInstanceContainer;

    @After
    public void after() {
        crashTester.close();
        tasklineInstanceContainer.close();
    }
    
    @Test
    public void runCrashTest() {
        tasklineInstanceContainer = TasklineInstanceContainer.
                createMultiInstance(TEST_FILENAME, TEST_ALIAS_FILENAME,
                        RANDOM_SEED, RATIO);
        crashTester = new MultiInstanceCrashTest(tasklineInstanceContainer,
                RANDOM_SEED, LOG_QUEUE_LENGTH);
        
        crashTester.runTest();
    }
}

	// End of segment: src\test\MultiInstanceCrashTester.java





	/**
	 * origin: src\test\SingleInstanceCrashTester.java
	 */

/**
 * The original crash tester. Tests a bunch of random input, together with some
 * fixed input which have been known to crash the program before, to see if any
 * of the input causes the program to crash (exception / assertion) or infinite
 * loop.
 */
public class SingleInstanceCrashTester {
    private static final String TEST_ALIAS_FILENAME = "testAlias.txt";
    private static final String TEST_FILENAME = "testTasks.txt";
    
    private static final int RANDOM_SEED = 1;
    private static final int LOG_QUEUE_LENGTH = 40;

    private AbstractCrashTest crashTester;
    private TasklineInstanceContainer tasklineInstanceContainer;

    @After
    public void after() {
        crashTester.close();
        tasklineInstanceContainer.close();
    }
    
    @Test
    public void runCrashTest() {
        tasklineInstanceContainer = TasklineInstanceContainer.
                createMonoInstance(TEST_FILENAME, TEST_ALIAS_FILENAME);
        crashTester = new SingleInstanceCrashTest(tasklineInstanceContainer,
                RANDOM_SEED, LOG_QUEUE_LENGTH);
        
        crashTester.runTest();
    }
}

	// End of segment: src\test\SingleInstanceCrashTester.java





