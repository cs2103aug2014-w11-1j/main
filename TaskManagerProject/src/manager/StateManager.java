package manager;

import data.TaskId;
import io.FileInputOutput;
import main.response.AddSuccessResponse;
import main.response.EditSuccessResponse;
import main.response.EnumResponse;
import main.response.EnumResponse.MessageType;
import main.response.Response;
import manager.datamanager.UndoManager;
import manager.result.AddResult;
import manager.result.EditResult;
import manager.result.Result;


/**
 * This is a state manager that keep track of the availability 
 * of executing a certain command.
 * It can also update the state by giving a result generated by managers
 * and return a response to command.
 * @author BRUCE
 *
 */
public class StateManager {

    private final FileInputOutput fileInputOutput;
	private final UndoManager undoManager;
	private State currentState;
	private TaskId editingTaskId;

	public enum State {
	    AVAILABLE,      // Normal state
	    EDIT_MODE,      // Can edit the same task without re-specifying task ID
	    SEARCH_MODE,    // In search mode, searchAgain is called after each command
	    LOCKED_MODE     // In locked mode, no modifying data is allowed
	}

	public StateManager(FileInputOutput fileInputOutput, UndoManager undoManager) {
	    this.fileInputOutput = fileInputOutput;
		this.undoManager = undoManager;
	}

	public boolean canAdd() {
		return currentState == State.AVAILABLE;
	}

	public boolean canSearch() {
        return currentState == State.AVAILABLE;
	}

	public boolean canEdit() {
        return currentState == State.AVAILABLE || currentState == State.EDIT_MODE;
	}

	public boolean canDelete() {
        return currentState == State.AVAILABLE || currentState == State.EDIT_MODE;
	}

	public boolean canUndo() {
        return currentState == State.AVAILABLE;
	}
	
	private void setState(State newState) {
	    currentState = newState;
	}
	
	public boolean inState(State state) {
	    return (currentState == state);
	}
    
	public boolean enterEditMode(TaskId id){
		if (currentState != State.AVAILABLE){
			return false;
		}else{
			setState(State.EDIT_MODE);
			editingTaskId = id;
			return true;
		}
	}
	
	public boolean exitEditMode(){
		if (currentState == State.EDIT_MODE){
			setState(State.AVAILABLE);
			return true;
		}else{
			return false;
		}
	}

	/**
	 * Updates the program's state using the result obtained from the managers.
	 * 
	 * @param result
	 * @return
	 */
	public Response update(Result result) {
        
        undoManager.retrieveUndoSnapshot();
        
        switch (result.getType()){
            case EDIT_MODE_START :
                setState(State.EDIT_MODE);
                break;
                
            case EDIT_MODE_END :
                setState(State.AVAILABLE);
                break;
            case ADD_SUCCESS :
            	return new AddSuccessResponse(((AddResult)(result)).getTaskInfo(), ((AddResult)(result)).getTaskId());
            case ADD_FAILURE : 
            	return new EnumResponse(MessageType.ADD_FAILURE);
            case DELETE_SUCCESS :
                if (inState(State.EDIT_MODE)) {
                    setState(State.AVAILABLE);
                }
                if (inState(State.SEARCH_MODE)) {
                	//searchManager.searchAgain();
                }
                break;
            case DELETE_FAILURE : 
            	return new EnumResponse(MessageType.DELETE_FAILURE);
            case EDIT_SUCCESS : 
            	return new EditSuccessResponse(((EditResult)(result)).getTaskInfo(), ((EditResult)(result)).getTaskId(),(currentState == State.EDIT_MODE));
            case EDIT_FAILURE : 
            	return new EnumResponse(MessageType.EDIT_FAILURE);
            default:
                break;
        }
        

        writeToFile();
        throw new UnsupportedOperationException("Not Implemented Yet");    
    }

    
    /**
     * This method is called just before every command execution.
     */
    public void beforeCommandExecutionUpdate() {
        boolean fileChanged = readFromFile();
        
        if (fileChanged) {
            undoManager.clearUndoHistory();
        }
    }

    private boolean readFromFile() {
        return fileInputOutput.read();
    }

    private boolean writeToFile() {
        return fileInputOutput.write();
    }
}
